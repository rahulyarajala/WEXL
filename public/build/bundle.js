
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
var app = (function () {
    'use strict';

    function noop() { }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }

    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function to_number(value) {
        return value === '' ? null : +value;
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    function custom_event(type, detail) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, false, false, detail);
        return e;
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);
    function each(items, fn) {
        let str = '';
        for (let i = 0; i < items.length; i += 1) {
            str += fn(items[i], i);
        }
        return str;
    }

    function bind(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : options.context || []),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false
        };
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.37.0' }, detail)));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev('SvelteDOMSetProperty', { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    let questionL$1 = [
      'Yes, you got it!',
      'Correct!',
      'Wow, you are a champ!',
      'You are a winner!',
      'Splendid!',
      'You got it!',
      'You got the correct answer!',
      'You are doing great!',
      'Prefect!',
      'Super!'
    ];

    // returns a random response from questinL array
    function randomCorrect() {
       return (questionL$1[Math.floor(Math.random() * questionL$1.length)]);
    }

    let questionL = [
        'Sorry, you did not get it.',
        'Incorrect.',
        'Better luck next time, champ!',
        'Oops, you missed!',
        'Good try, but not correct.',
        'Sorry, try again!',
        'You did not get the answer.',
        'Sorry! Keep trying.',
        'Sorry, better luck next time.',
        'Yikes! missed it.'
      ];
      
      // returns a random response from questionL array
      function randomWrong() {
         return (questionL[Math.floor(Math.random() * questionL.length)]);
      }

    let task01$1J = {
        endValue : 0,
        endText : '',
        answer : 0,
        endTextArray : ["hundreds" , "tens","thousands","ten thousands","ones"]
    };

    const tenthousands$2 = 10000;
    const thousands$1 = 1000;
    const hundreds$1 = 100;
    const tens$1 = 10;


    function taskOne$1J(){
        task01$1J.endValue = Math.floor(Math.random() * 9)+1;  
        task01$1J.endText = task01$1J.endTextArray[(Math.floor(Math.random() * task01$1J.endTextArray.length))];
        if(task01$1J.endText == "hundreds"){
            task01$1J.answer = task01$1J.endValue * hundreds$1;
        }else if(task01$1J.endText == "tens"){
            task01$1J.answer = task01$1J.endValue * tens$1;
        }else if(task01$1J.endText == "thousands"){
            task01$1J.answer = task01$1J.endValue * thousands$1;
        }else if(task01$1J.endText == "ten thousands"){
            task01$1J.answer = task01$1J.endValue * tenthousands$2;
        }else if(task01$1J.endText == "ones"){
            task01$1J.answer = task01$1J.endValue * 1;
        }    
        return task01$1J;
    }

    /* src/components/taskComponents/GV_MA_A2.svelte generated by Svelte v3.37.0 */
    const file$2d = "src/components/taskComponents/GV_MA_A2.svelte";

    function create_fragment$2e(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h20;
    	let t1;
    	let div5;
    	let div2;
    	let h21;
    	let t3;
    	let div1;
    	let input;
    	let t4;
    	let h40;
    	let t6;
    	let h41;
    	let t7_value = /*task01*/ ctx[0].endValue + "";
    	let t7;
    	let t8;
    	let t9_value = /*task01*/ ctx[0].endText + "";
    	let t9;
    	let t10;
    	let div3;
    	let button0;
    	let t12;
    	let button1;
    	let t14;
    	let button2;
    	let t16;
    	let div4;
    	let h5;
    	let t17;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h20 = element("h2");
    			h20.textContent = "Convert between place values";
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h21 = element("h2");
    			h21.textContent = "Solve :";
    			t3 = space();
    			div1 = element("div");
    			input = element("input");
    			t4 = space();
    			h40 = element("h4");
    			h40.textContent = "=";
    			t6 = space();
    			h41 = element("h4");
    			t7 = text(t7_value);
    			t8 = space();
    			t9 = text(t9_value);
    			t10 = space();
    			div3 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t12 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t14 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			t16 = space();
    			div4 = element("div");
    			h5 = element("h5");
    			t17 = text(/*showPopUp*/ ctx[3]);
    			attr_dev(h20, "class", "text-center display-4 mb-0");
    			add_location(h20, file$2d, 54, 10, 1052);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$2d, 53, 6, 1002);
    			add_location(h21, file$2d, 61, 12, 1242);
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			add_location(input, file$2d, 63, 16, 1323);
    			add_location(h40, file$2d, 64, 16, 1409);
    			set_style(h41, "margin-left", "5px");
    			add_location(h41, file$2d, 65, 16, 1459);
    			attr_dev(div1, "class", "d-inline-flex p-2");
    			add_location(div1, file$2d, 62, 12, 1272);
    			add_location(div2, file$2d, 60, 8, 1223);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$2d, 72, 14, 1625);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$2d, 73, 14, 1723);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$2d, 74, 14, 1821);
    			attr_dev(div3, "class", "mt-3");
    			add_location(div3, file$2d, 71, 10, 1592);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$2d, 79, 13, 1956);
    			add_location(div4, file$2d, 78, 10, 1937);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$2d, 58, 6, 1150);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$2d, 52, 5, 954);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$2d, 51, 1, 920);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h20);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h21);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t4);
    			append_dev(div1, h40);
    			append_dev(div1, t6);
    			append_dev(div1, h41);
    			append_dev(h41, t7);
    			append_dev(h41, t8);
    			append_dev(h41, t9);
    			append_dev(div5, t10);
    			append_dev(div5, div3);
    			append_dev(div3, button0);
    			append_dev(div3, t12);
    			append_dev(div3, button1);
    			append_dev(div3, t14);
    			append_dev(div3, button2);
    			append_dev(div5, t16);
    			append_dev(div5, div4);
    			append_dev(div4, h5);
    			append_dev(h5, t17);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t7_value !== (t7_value = /*task01*/ ctx[0].endValue + "")) set_data_dev(t7, t7_value);
    			if (dirty & /*task01*/ 1 && t9_value !== (t9_value = /*task01*/ ctx[0].endText + "")) set_data_dev(t9, t9_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t17, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2e($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GV_MA_A2", slots, []);
    	let task01 = taskOne$1J();
    	let answer;
    	let showNext = "none";
    	let randomQst = 0;
    	let showPopUp;

    	let getRandomQuestion = function () {
    		randomQst = Math.floor(Math.random() * 4);
    	};

    	let CheckAnswer = function () {
    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			$$invalidate(2, showNext = "inline-block");
    			return;
    		} else {
    			$$invalidate(3, showPopUp = randomWrong());
    			$$invalidate(2, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(0, task01 = taskOne$1J());
    		$$invalidate(1, answer = null);
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GV_MA_A2> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1J,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		randomQst,
    		showPopUp,
    		getRandomQuestion,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("randomQst" in $$props) randomQst = $$props.randomQst;
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("getRandomQuestion" in $$props) getRandomQuestion = $$props.getRandomQuestion;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class GV_MA_A2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2e, create_fragment$2e, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GV_MA_A2",
    			options,
    			id: create_fragment$2e.name
    		});
    	}
    }

    let task01$1I = {
        question : "Which words make this statement true?",
        options : ["greater","lesser","equal"],
        valueRight : 0,
        valueLeft : 0,
        answer : ''
    };

    const tenthousands$1 = 10000;

    function taskOne$1I(){
       
        task01$1I.answer = task01$1I.options[(Math.floor(Math.random() * 3) + 1) -1];
        task01$1I.valueLeft = Math.floor( Math.random() * tenthousands$1);
        if(task01$1I.answer.toString() === "greater"){        
            task01$1I.valueRight = Math.floor(Math.random() * (task01$1I.valueLeft - 1)) + 1;
        }else if(task01$1I.answer.toString() === "lesser"){
            task01$1I.valueRight = Math.floor(Math.random() * ((tenthousands$1 + 10) - task01$1I.valueLeft)) + task01$1I.valueLeft;
        }else if(task01$1I.answer.toString() === "equal"){
            task01$1I.valueRight = task01$1I.valueLeft;
        }
        return task01$1I;
    }

    /* src/components/taskComponents/GV_MA_A3.svelte generated by Svelte v3.37.0 */
    const file$2c = "src/components/taskComponents/GV_MA_A3.svelte";

    function create_fragment$2d(ctx) {
    	let div8;
    	let div7;
    	let div0;
    	let h20;
    	let t1;
    	let div6;
    	let div2;
    	let h21;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let h40;
    	let t4_value = /*task01*/ ctx[0].valueLeft + "";
    	let t4;
    	let t5;
    	let h41;
    	let t7;
    	let h42;
    	let t8_value = /*task01*/ ctx[0].valueRight + "";
    	let t8;
    	let t9;
    	let div3;
    	let button0;
    	let t11;
    	let button1;
    	let t13;
    	let button2;
    	let t15;
    	let div4;
    	let button3;
    	let t17;
    	let button4;
    	let t19;
    	let div5;
    	let h5;
    	let t20;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div8 = element("div");
    			div7 = element("div");
    			div0 = element("div");
    			h20 = element("h2");
    			h20.textContent = "Compare numbers";
    			t1 = space();
    			div6 = element("div");
    			div2 = element("div");
    			h21 = element("h2");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			h40 = element("h4");
    			t4 = text(t4_value);
    			t5 = space();
    			h41 = element("h4");
    			h41.textContent = "_________";
    			t7 = space();
    			h42 = element("h4");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			button0 = element("button");
    			button0.textContent = "Greater";
    			t11 = space();
    			button1 = element("button");
    			button1.textContent = "Lesser";
    			t13 = space();
    			button2 = element("button");
    			button2.textContent = "Equal";
    			t15 = space();
    			div4 = element("div");
    			button3 = element("button");
    			button3.textContent = "Rerun";
    			t17 = space();
    			button4 = element("button");
    			button4.textContent = "Exit This Skill";
    			t19 = space();
    			div5 = element("div");
    			h5 = element("h5");
    			t20 = text(/*showPopUp*/ ctx[2]);
    			attr_dev(h20, "class", "text-center display-4 mb-0");
    			add_location(h20, file$2c, 58, 10, 1124);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$2c, 57, 6, 1074);
    			add_location(h21, file$2c, 65, 12, 1301);
    			add_location(h40, file$2c, 67, 16, 1391);
    			add_location(h41, file$2c, 68, 16, 1436);
    			add_location(h42, file$2c, 69, 16, 1473);
    			attr_dev(div1, "class", "d-inline-flex p-2");
    			add_location(div1, file$2c, 66, 12, 1340);
    			add_location(div2, file$2c, 64, 8, 1282);
    			attr_dev(button0, "class", "btn btn-outline-success");
    			add_location(button0, file$2c, 75, 14, 1610);
    			attr_dev(button1, "class", "btn btn-outline-success");
    			add_location(button1, file$2c, 76, 14, 1715);
    			attr_dev(button2, "class", "btn btn-outline-success");
    			add_location(button2, file$2c, 77, 14, 1818);
    			attr_dev(div3, "class", "mt-3");
    			add_location(div3, file$2c, 74, 10, 1577);
    			attr_dev(button3, "type", "button");
    			attr_dev(button3, "class", "btn toggle-btn");
    			add_location(button3, file$2c, 81, 12, 1966);
    			attr_dev(button4, "type", "button");
    			attr_dev(button4, "class", "btn toggle-btn");
    			add_location(button4, file$2c, 82, 12, 2062);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$2c, 80, 10, 1935);
    			set_style(h5, "display", /*showNext*/ ctx[1]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$2c, 87, 13, 2197);
    			add_location(div5, file$2c, 86, 9, 2178);
    			attr_dev(div6, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div6, file$2c, 62, 6, 1209);
    			attr_dev(div7, "class", "shadow-sm  bg-white rounded");
    			add_location(div7, file$2c, 56, 5, 1026);
    			attr_dev(div8, "class", "container mt-5");
    			add_location(div8, file$2c, 55, 1, 992);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div8, anchor);
    			append_dev(div8, div7);
    			append_dev(div7, div0);
    			append_dev(div0, h20);
    			append_dev(div7, t1);
    			append_dev(div7, div6);
    			append_dev(div6, div2);
    			append_dev(div2, h21);
    			append_dev(h21, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, h40);
    			append_dev(h40, t4);
    			append_dev(div1, t5);
    			append_dev(div1, h41);
    			append_dev(div1, t7);
    			append_dev(div1, h42);
    			append_dev(h42, t8);
    			append_dev(div6, t9);
    			append_dev(div6, div3);
    			append_dev(div3, button0);
    			append_dev(div3, t11);
    			append_dev(div3, button1);
    			append_dev(div3, t13);
    			append_dev(div3, button2);
    			append_dev(div6, t15);
    			append_dev(div6, div4);
    			append_dev(div4, button3);
    			append_dev(div4, t17);
    			append_dev(div4, button4);
    			append_dev(div6, t19);
    			append_dev(div6, div5);
    			append_dev(div5, h5);
    			append_dev(h5, t20);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*handleClick*/ ctx[4]("greater"), false, false, false),
    					listen_dev(button1, "click", /*handleClick*/ ctx[4]("lesser"), false, false, false),
    					listen_dev(button2, "click", /*handleClick*/ ctx[4]("equal"), false, false, false),
    					listen_dev(button3, "click", /*NextQuestion*/ ctx[3], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*task01*/ 1 && t4_value !== (t4_value = /*task01*/ ctx[0].valueLeft + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].valueRight + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 4) set_data_dev(t20, /*showPopUp*/ ctx[2]);

    			if (dirty & /*showNext*/ 2) {
    				set_style(h5, "display", /*showNext*/ ctx[1]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div8);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2d($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GV_MA_A3", slots, []);
    	let task01 = taskOne$1I();
    	let answer;
    	let showNext = "none";
    	let showPopUp;

    	let getRandomQuestion = function () {
    		randomQst = Math.floor(Math.random() * 4);
    	};

    	let CheckAnswer = function () {
    		if (answer === task01.answer) {
    			$$invalidate(2, showPopUp = randomCorrect());
    			$$invalidate(1, showNext = "inline-block");
    			return;
    		} else {
    			$$invalidate(2, showPopUp = randomWrong());
    			$$invalidate(1, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(0, task01 = taskOne$1I());
    		$$invalidate(1, showNext = "none");
    	};

    	const handleClick = parameter => () => {
    		answer = parameter;
    		CheckAnswer();
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GV_MA_A3> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1I,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		getRandomQuestion,
    		CheckAnswer,
    		NextQuestion,
    		handleClick
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) answer = $$props.answer;
    		if ("showNext" in $$props) $$invalidate(1, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(2, showPopUp = $$props.showPopUp);
    		if ("getRandomQuestion" in $$props) getRandomQuestion = $$props.getRandomQuestion;
    		if ("CheckAnswer" in $$props) CheckAnswer = $$props.CheckAnswer;
    		if ("NextQuestion" in $$props) $$invalidate(3, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [task01, showNext, showPopUp, NextQuestion, handleClick];
    }

    class GV_MA_A3 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2d, create_fragment$2d, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GV_MA_A3",
    			options,
    			id: create_fragment$2d.name
    		});
    	}
    }

    function convertNumberToWords(amount) {
        let words = new Array();
        words[0] = '';
        words[1] = 'One';
        words[2] = 'Two';
        words[3] = 'Three';
        words[4] = 'Four';
        words[5] = 'Five';
        words[6] = 'Six';
        words[7] = 'Seven';
        words[8] = 'Eight';
        words[9] = 'Nine';
        words[10] = 'Ten';
        words[11] = 'Eleven';
        words[12] = 'Twelve';
        words[13] = 'Thirteen';
        words[14] = 'Fourteen';
        words[15] = 'Fifteen';
        words[16] = 'Sixteen';
        words[17] = 'Seventeen';
        words[18] = 'Eighteen';
        words[19] = 'Nineteen';
        words[20] = 'Twenty';
        words[30] = 'Thirty';
        words[40] = 'Forty';
        words[50] = 'Fifty';
        words[60] = 'Sixty';
        words[70] = 'Seventy';
        words[80] = 'Eighty';
        words[90] = 'Ninety';
        amount = amount.toString();
        let atemp = amount.split(".");
        let number = atemp[0].split(",").join("");
        let n_length = number.length;
        let words_string = "";
        if (n_length <= 9) {
            let n_array = new Array(0, 0, 0, 0, 0, 0, 0, 0, 0);
            let received_n_array = new Array();
            for (let i = 0; i < n_length; i++) {
                received_n_array[i] = number.substr(i, 1);
            }
            for (let i = 9 - n_length, j = 0; i < 9; i++, j++) {
                n_array[i] = received_n_array[j];
            }
            for (let i = 0, j = 1; i < 9; i++, j++) {
                if (i == 0 || i == 2 || i == 4 || i == 7) {
                    if (n_array[i] == 1) {
                        n_array[j] = 10 + parseInt(n_array[j]);
                        n_array[i] = 0;
                    }
                }
            }
            let value = "";
            for (let i = 0; i < 9; i++) {
                if (i == 0 || i == 2 || i == 4 || i == 7) {
                    value = n_array[i] * 10;
                } else {
                    value = n_array[i];
                }
                if (value != 0) {
                    words_string += words[value] + " ";
                }
                if ((i == 1 && value != 0) || (i == 0 && value != 0 && n_array[i + 1] == 0)) {
                    words_string += "Crores ";
                }
                if ((i == 3 && value != 0) || (i == 2 && value != 0 && n_array[i + 1] == 0)) {
                    words_string += "Lakhs ";
                }
                if ((i == 5 && value != 0) || (i == 4 && value != 0 && n_array[i + 1] == 0)) {
                    words_string += "Thousand ";
                }
                if (i == 6 && value != 0 && (n_array[i + 1] != 0 && n_array[i + 2] != 0)) {
                    words_string += "Hundred and ";
                } else if (i == 6 && value != 0) {
                    words_string += "Hundred ";
                }
            }
            words_string = words_string.split("  ").join(" ");
        }
        return words_string;
    }

    function randomNumbers$3(count, max , min){
        var stop = count;
        var numbers = [];
        for (let i = 0; i < stop; i++) {
        var n =  Math.floor(Math.random() * (max - min)) + min;
        var check = numbers.includes(n);
            
            if(check === false) {
                numbers.push(n);
            } else {
                while(check === true){
                n =  Math.floor(Math.random() * (max - min)) + min;
                check = numbers.includes(n);
                    if(check === false){
                    numbers.push(n);
                    }
                }
            }
            }
        return numbers;
      }


      function randomArrayNumbers(count, max , min,arrayV){
        var stop = count;
        var numbers = [];
        for (let i = 0; i < stop; i++) {
        var n =  Math.floor(Math.random() * (max - min)) + min;
        var check = numbers.includes(n);
            
            if(check === false) {
                numbers.push(arrayV[n]);
            } else {
                while(check === true){
                n =  Math.floor(Math.random() * (max - min)) + min;
                check = numbers.includes(n);
                    if(check === false){
                    numbers.push(arrayV[n]);
                    }
                }
            }
            }
        return numbers;
      }

    let task01$1H = {
        question : "How do you write this number using words?",
        displayValue : "",    
        answer : 0,
        randomAnswer : 0,
        options: [0,1,2,3]
    };

    let task02 = {
        question : "How do you write this number using digits?",
        displayValue : "",    
        answer : 0,
        randomAnswer : 0,
        options: [0,1,2,3]
    };


    function taskOne$1H(){  
        task01$1H.displayValue =  Math.floor( Math.random() * 10000);
        task01$1H.randomAnswer = Math.floor(Math.random() * (task01$1H.options.length));
        let max = task01$1H.displayValue + 5;
        let min = task01$1H.displayValue - 5;  
        task01$1H.options = randomNumbers$3(task01$1H.options.length,max,min);
        task01$1H.displayValue = task01$1H.options[task01$1H.randomAnswer];
        for (let index = 0; index < task01$1H.options.length; index++) {        
            task01$1H.options[index] =  convertNumberToWords(task01$1H.options[index]);
        } 
        task01$1H.answer = task01$1H.randomAnswer;
        return task01$1H;
    }

    function taskTwo(){  
        task02.displayValue =  Math.floor( Math.random() * 10000);
        task02.randomAnswer = Math.floor(Math.random() * (task02.options.length));
        let max = task02.displayValue + 5;
        let min = task02.displayValue - 5;  
        task02.options = randomNumbers$3(task02.options.length,max,min);
        task02.displayValue = convertNumberToWords(task02.options[task02.randomAnswer]);
        
        task02.answer = task02.randomAnswer;
        return task02;
    }

    /* src/components/taskComponents/GV_MA_A4.svelte generated by Svelte v3.37.0 */
    const file$2b = "src/components/taskComponents/GV_MA_A4.svelte";

    function get_each_context_1$y(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	child_ctx[12] = i;
    	return child_ctx;
    }

    function get_each_context$1K(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	child_ctx[12] = i;
    	return child_ctx;
    }

    // (89:4) {:else}
    function create_else_block$1j(ctx) {
    	let div1;
    	let h2;
    	let t0_value = /*task02*/ ctx[4].question + "";
    	let t0;
    	let t1;
    	let h4;
    	let t2_value = /*task02*/ ctx[4].displayValue + "";
    	let t2;
    	let t3;
    	let div0;
    	let each_value_1 = /*task02*/ ctx[4].options;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$y(get_each_context_1$y(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(h2, file$2b, 90, 12, 2188);
    			add_location(h4, file$2b, 91, 12, 2227);
    			attr_dev(div0, "class", " p-2");
    			add_location(div0, file$2b, 92, 12, 2271);
    			add_location(div1, file$2b, 89, 8, 2169);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, h2);
    			append_dev(h2, t0);
    			append_dev(div1, t1);
    			append_dev(div1, h4);
    			append_dev(h4, t2);
    			append_dev(div1, t3);
    			append_dev(div1, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div0, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task02*/ 16 && t0_value !== (t0_value = /*task02*/ ctx[4].question + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task02*/ 16 && t2_value !== (t2_value = /*task02*/ ctx[4].displayValue + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*handleClick, task02*/ 144) {
    				each_value_1 = /*task02*/ ctx[4].options;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$y(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$y(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1j.name,
    		type: "else",
    		source: "(89:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (77:7) {#if randomQst == 0}
    function create_if_block$1p(ctx) {
    	let div1;
    	let h2;
    	let t0_value = /*task01*/ ctx[3].question + "";
    	let t0;
    	let t1;
    	let h4;
    	let t2_value = /*task01*/ ctx[3].displayValue + "";
    	let t2;
    	let t3;
    	let div0;
    	let each_value = /*task01*/ ctx[3].options;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1K(get_each_context$1K(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(h2, file$2b, 78, 8, 1796);
    			add_location(h4, file$2b, 79, 8, 1831);
    			attr_dev(div0, "class", " p-2");
    			add_location(div0, file$2b, 80, 8, 1870);
    			add_location(div1, file$2b, 77, 7, 1781);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, h2);
    			append_dev(h2, t0);
    			append_dev(div1, t1);
    			append_dev(div1, h4);
    			append_dev(h4, t2);
    			append_dev(div1, t3);
    			append_dev(div1, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div0, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 8 && t0_value !== (t0_value = /*task01*/ ctx[3].question + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 8 && t2_value !== (t2_value = /*task01*/ ctx[3].displayValue + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*handleClick, task01*/ 136) {
    				each_value = /*task01*/ ctx[3].options;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1K(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1K(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1p.name,
    		type: "if",
    		source: "(77:7) {#if randomQst == 0}",
    		ctx
    	});

    	return block;
    }

    // (94:16) {#each task02.options as  option,i}
    function create_each_block_1$y(ctx) {
    	let button;
    	let t_value = /*option*/ ctx[10] + "";
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "class", "btn btn-outline-success d-block mt-2 w-50");
    			add_location(button, file$2b, 94, 16, 2360);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleClick*/ ctx[7](/*i*/ ctx[12]), false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*task02*/ 16 && t_value !== (t_value = /*option*/ ctx[10] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$y.name,
    		type: "each",
    		source: "(94:16) {#each task02.options as  option,i}",
    		ctx
    	});

    	return block;
    }

    // (82:12) {#each task01.options as  option,i}
    function create_each_block$1K(ctx) {
    	let button;
    	let t_value = /*option*/ ctx[10] + "";
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "class", "btn btn-outline-success d-block mt-2 w-50");
    			add_location(button, file$2b, 82, 12, 1958);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleClick*/ ctx[7](/*i*/ ctx[12]), false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*task01*/ 8 && t_value !== (t_value = /*option*/ ctx[10] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1K.name,
    		type: "each",
    		source: "(82:12) {#each task01.options as  option,i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2c(ctx) {
    	let div5;
    	let div4;
    	let div0;
    	let h2;
    	let t1;
    	let div3;
    	let t2;
    	let div1;
    	let h5;
    	let t3;
    	let t4;
    	let div2;
    	let button0;
    	let t6;
    	let button1;
    	let mounted;
    	let dispose;

    	function select_block_type(ctx, dirty) {
    		if (/*randomQst*/ ctx[1] == 0) return create_if_block$1p;
    		return create_else_block$1j;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			div4 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			h2.textContent = "Heading";
    			t1 = space();
    			div3 = element("div");
    			if_block.c();
    			t2 = space();
    			div1 = element("div");
    			h5 = element("h5");
    			t3 = text(/*showPopUp*/ ctx[2]);
    			t4 = space();
    			div2 = element("div");
    			button0 = element("button");
    			button0.textContent = "Rerun";
    			t6 = space();
    			button1 = element("button");
    			button1.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$2b, 70, 10, 1604);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$2b, 69, 6, 1554);
    			set_style(h5, "display", /*showNext*/ ctx[0]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$2b, 104, 8, 2605);
    			add_location(div1, file$2b, 103, 7, 2591);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$2b, 108, 12, 2732);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$2b, 109, 12, 2828);
    			attr_dev(div2, "class", "mt-3");
    			add_location(div2, file$2b, 107, 8, 2701);
    			attr_dev(div3, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div3, file$2b, 74, 6, 1681);
    			attr_dev(div4, "class", "shadow-sm  bg-white rounded");
    			add_location(div4, file$2b, 68, 5, 1506);
    			attr_dev(div5, "class", "container mt-5");
    			add_location(div5, file$2b, 67, 1, 1472);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div4);
    			append_dev(div4, div0);
    			append_dev(div0, h2);
    			append_dev(div4, t1);
    			append_dev(div4, div3);
    			if_block.m(div3, null);
    			append_dev(div3, t2);
    			append_dev(div3, div1);
    			append_dev(div1, h5);
    			append_dev(h5, t3);
    			append_dev(div3, t4);
    			append_dev(div3, div2);
    			append_dev(div2, button0);
    			append_dev(div2, t6);
    			append_dev(div2, button1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*NextQuestion*/ ctx[6], false, false, false),
    					listen_dev(button1, "click", /*CheckAnswer*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div3, t2);
    				}
    			}

    			if (dirty & /*showPopUp*/ 4) set_data_dev(t3, /*showPopUp*/ ctx[2]);

    			if (dirty & /*showNext*/ 1) {
    				set_style(h5, "display", /*showNext*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2c($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GV_MA_A4", slots, []);
    	let answer;
    	let showNext = "none";
    	let randomQst = 0;
    	let showPopUp;
    	let task01 = taskOne$1H();
    	let task02 = taskTwo();

    	let getRandomQuestion = function () {
    		$$invalidate(1, randomQst = Math.floor(Math.random() * 2));
    	};

    	getRandomQuestion();

    	let CheckAnswer = function () {
    		if (randomQst == 0) {
    			if (answer === task01.answer) {
    				$$invalidate(2, showPopUp = randomCorrect());
    				$$invalidate(0, showNext = "inline-block");
    				return;
    			} else {
    				$$invalidate(2, showPopUp = randomWrong());
    				$$invalidate(0, showNext = "inline-block");
    			}
    		} else {
    			if (answer === task02.answer) {
    				$$invalidate(2, showPopUp = randomCorrect());
    				$$invalidate(0, showNext = "inline-block");
    				return;
    			} else {
    				$$invalidate(2, showPopUp = randomWrong());
    				$$invalidate(0, showNext = "inline-block");
    			}
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(3, task01 = taskOne$1H());
    		$$invalidate(4, task02 = taskTwo());
    		$$invalidate(0, showNext = "none");
    	};

    	const handleClick = parameter => () => {
    		answer = parameter;
    		CheckAnswer();
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GV_MA_A4> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		randomCorrect,
    		randomWrong,
    		taskOne: taskOne$1H,
    		taskTwo,
    		answer,
    		showNext,
    		randomQst,
    		showPopUp,
    		task01,
    		task02,
    		getRandomQuestion,
    		CheckAnswer,
    		NextQuestion,
    		handleClick
    	});

    	$$self.$inject_state = $$props => {
    		if ("answer" in $$props) answer = $$props.answer;
    		if ("showNext" in $$props) $$invalidate(0, showNext = $$props.showNext);
    		if ("randomQst" in $$props) $$invalidate(1, randomQst = $$props.randomQst);
    		if ("showPopUp" in $$props) $$invalidate(2, showPopUp = $$props.showPopUp);
    		if ("task01" in $$props) $$invalidate(3, task01 = $$props.task01);
    		if ("task02" in $$props) $$invalidate(4, task02 = $$props.task02);
    		if ("getRandomQuestion" in $$props) getRandomQuestion = $$props.getRandomQuestion;
    		if ("CheckAnswer" in $$props) $$invalidate(5, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(6, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		showNext,
    		randomQst,
    		showPopUp,
    		task01,
    		task02,
    		CheckAnswer,
    		NextQuestion,
    		handleClick
    	];
    }

    class GV_MA_A4 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2c, create_fragment$2c, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GV_MA_A4",
    			options,
    			id: create_fragment$2c.name
    		});
    	}
    }

    function roundUp(num, precision) {
        num = parseFloat(num);
        if (!precision) return num;
        return Math.round(num / precision) * precision;
      }

    let task01$1G = {
      question: "",
      displayValue: 0,
      answer: 0,
      randomAnswer: 0,
      options: [1, 10, 100],
    };

    const tenthousands = 10000;

    const hundreds = 100;
    const tens = 10;

    function taskOne$1G() {
      task01$1G.randomAnswer = Math.floor(Math.random() * task01$1G.options.length);

      if (task01$1G.randomAnswer == 0) {
        task01$1G.displayValue = (Math.random() * tens).toFixed(2);
      } else {
        task01$1G.displayValue =
          Math.floor(Math.random() * (tenthousands - hundreds)) + hundreds;
      }
      task01$1G.question =
        "What is " +
        task01$1G.displayValue +
        " rounded to the nearest " +
        task01$1G.options[task01$1G.randomAnswer] +
        " ?";
      task01$1G.answer = roundUp(
        task01$1G.displayValue,
        task01$1G.options[task01$1G.randomAnswer]
      );
      return task01$1G;
    }

    /* src/components/taskComponents/GV_MA_A5.svelte generated by Svelte v3.37.0 */
    const file$2a = "src/components/taskComponents/GV_MA_A5.svelte";

    function create_fragment$2b(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h20;
    	let t1;
    	let div5;
    	let div2;
    	let h21;
    	let t3;
    	let div1;
    	let h4;
    	let t4_value = /*task01*/ ctx[3].question + "";
    	let t4;
    	let t5;
    	let input;
    	let t6;
    	let div3;
    	let h5;
    	let t7;
    	let t8;
    	let div4;
    	let button0;
    	let t10;
    	let button1;
    	let t12;
    	let button2;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h20 = element("h2");
    			h20.textContent = "Rounding";
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h21 = element("h2");
    			h21.textContent = "Question";
    			t3 = space();
    			div1 = element("div");
    			h4 = element("h4");
    			t4 = text(t4_value);
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t7 = text(/*showPopUp*/ ctx[2]);
    			t8 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t10 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t12 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h20, "class", "text-center display-4 mb-0");
    			add_location(h20, file$2a, 50, 10, 923);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$2a, 49, 6, 873);
    			add_location(h21, file$2a, 57, 12, 1093);
    			add_location(h4, file$2a, 59, 16, 1174);
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			add_location(input, file$2a, 60, 16, 1219);
    			attr_dev(div1, "class", "d-inline-flex p-2");
    			add_location(div1, file$2a, 58, 12, 1123);
    			add_location(div2, file$2a, 56, 8, 1074);
    			set_style(h5, "display", /*showNext*/ ctx[1]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$2a, 69, 12, 1401);
    			add_location(div3, file$2a, 68, 8, 1383);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$2a, 72, 14, 1534);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$2a, 73, 14, 1632);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$2a, 74, 14, 1730);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$2a, 71, 10, 1501);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$2a, 54, 6, 1001);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$2a, 48, 5, 825);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$2a, 47, 1, 791);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h20);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h21);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, h4);
    			append_dev(h4, t4);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[0]);
    			append_dev(div5, t6);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t7);
    			append_dev(div5, t8);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t10);
    			append_dev(div4, button1);
    			append_dev(div4, t12);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 8 && t4_value !== (t4_value = /*task01*/ ctx[3].question + "")) set_data_dev(t4, t4_value);

    			if (dirty & /*answer*/ 1 && input.value !== /*answer*/ ctx[0]) {
    				set_input_value(input, /*answer*/ ctx[0]);
    			}

    			if (dirty & /*showPopUp*/ 4) set_data_dev(t7, /*showPopUp*/ ctx[2]);

    			if (dirty & /*showNext*/ 2) {
    				set_style(h5, "display", /*showNext*/ ctx[1]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2b($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GV_MA_A5", slots, []);
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let task01 = taskOne$1G();

    	let CheckAnswer = function () {
    		if (answer == task01.answer) {
    			$$invalidate(2, showPopUp = randomCorrect());
    			$$invalidate(1, showNext = "inline-block");
    			return;
    		} else {
    			$$invalidate(2, showPopUp = randomWrong());
    			$$invalidate(1, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(0, answer = null);
    		$$invalidate(3, task01 = taskOne$1G());
    		$$invalidate(1, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GV_MA_A5> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(0, answer);
    	}

    	$$self.$capture_state = () => ({
    		randomCorrect,
    		randomWrong,
    		taskOne: taskOne$1G,
    		answer,
    		showNext,
    		showPopUp,
    		task01,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("answer" in $$props) $$invalidate(0, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(1, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(2, showPopUp = $$props.showPopUp);
    		if ("task01" in $$props) $$invalidate(3, task01 = $$props.task01);
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		answer,
    		showNext,
    		showPopUp,
    		task01,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class GV_MA_A5 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2b, create_fragment$2b, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GV_MA_A5",
    			options,
    			id: create_fragment$2b.name
    		});
    	}
    }

    let task01$1F = {
        question: "",
        displayValueOne: 0,
        displayValueTwo: 0,
        answer: 0,
        randomAnswer: 0,
        operators: ["-", "+"],
      };
      
      const thousands = 1000;

      function taskOne$1F() {
          task01$1F.randomAnswer = Math.floor(Math.random() * (task01$1F.operators.length));
          task01$1F.displayValueOne = Math.floor(Math.random() * thousands);
          task01$1F.displayValueTwo = Math.floor(Math.random() * thousands);     
          task01$1F.question = "Is "+ task01$1F.displayValueOne +" "+ task01$1F.operators[task01$1F.randomAnswer] + " " + task01$1F.displayValueTwo + " even or odd?";
          task01$1F.answer = (task01$1F.displayValueOne + task01$1F.displayValueTwo) %2;
          return task01$1F;
      }

    /* src/components/taskComponents/GV_MA_A6.svelte generated by Svelte v3.37.0 */
    const file$29 = "src/components/taskComponents/GV_MA_A6.svelte";

    function create_fragment$2a(ctx) {
    	let div8;
    	let div7;
    	let div0;
    	let h20;
    	let t1;
    	let div6;
    	let div3;
    	let h21;
    	let t3;
    	let div1;
    	let h4;
    	let t4_value = /*task01*/ ctx[2].question + "";
    	let t4;
    	let t5;
    	let div2;
    	let button0;
    	let t7;
    	let button1;
    	let t9;
    	let div4;
    	let h5;
    	let t10;
    	let t11;
    	let div5;
    	let button2;
    	let t13;
    	let button3;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div8 = element("div");
    			div7 = element("div");
    			div0 = element("div");
    			h20 = element("h2");
    			h20.textContent = "Even or odd: arithmetic rules";
    			t1 = space();
    			div6 = element("div");
    			div3 = element("div");
    			h21 = element("h2");
    			h21.textContent = "Question";
    			t3 = space();
    			div1 = element("div");
    			h4 = element("h4");
    			t4 = text(t4_value);
    			t5 = space();
    			div2 = element("div");
    			button0 = element("button");
    			button0.textContent = "Even";
    			t7 = space();
    			button1 = element("button");
    			button1.textContent = "Odd";
    			t9 = space();
    			div4 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[1]);
    			t11 = space();
    			div5 = element("div");
    			button2 = element("button");
    			button2.textContent = "Rerun";
    			t13 = space();
    			button3 = element("button");
    			button3.textContent = "Exit This Skill";
    			attr_dev(h20, "class", "text-center display-4 mb-0");
    			add_location(h20, file$29, 53, 10, 1023);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$29, 52, 6, 973);
    			add_location(h21, file$29, 60, 12, 1214);
    			add_location(h4, file$29, 62, 16, 1295);
    			attr_dev(div1, "class", "d-inline-flex p-2");
    			add_location(div1, file$29, 61, 12, 1244);
    			attr_dev(button0, "class", "btn btn-outline-success d-block mt-2 w-50");
    			add_location(button0, file$29, 66, 16, 1440);
    			attr_dev(button1, "class", "btn btn-outline-success d-block mt-2 w-50");
    			add_location(button1, file$29, 67, 16, 1554);
    			add_location(div2, file$29, 65, 12, 1395);
    			add_location(div3, file$29, 59, 8, 1195);
    			set_style(h5, "display", /*showNext*/ ctx[0]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$29, 73, 16, 1733);
    			add_location(div4, file$29, 72, 12, 1711);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$29, 79, 12, 1883);
    			attr_dev(button3, "type", "button");
    			attr_dev(button3, "class", "btn toggle-btn");
    			add_location(button3, file$29, 80, 12, 1979);
    			attr_dev(div5, "class", "mt-3");
    			add_location(div5, file$29, 78, 10, 1852);
    			attr_dev(div6, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div6, file$29, 57, 6, 1122);
    			attr_dev(div7, "class", "shadow-sm  bg-white rounded");
    			add_location(div7, file$29, 51, 5, 925);
    			attr_dev(div8, "class", "container mt-5");
    			add_location(div8, file$29, 50, 1, 891);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div8, anchor);
    			append_dev(div8, div7);
    			append_dev(div7, div0);
    			append_dev(div0, h20);
    			append_dev(div7, t1);
    			append_dev(div7, div6);
    			append_dev(div6, div3);
    			append_dev(div3, h21);
    			append_dev(div3, t3);
    			append_dev(div3, div1);
    			append_dev(div1, h4);
    			append_dev(h4, t4);
    			append_dev(div3, t5);
    			append_dev(div3, div2);
    			append_dev(div2, button0);
    			append_dev(div2, t7);
    			append_dev(div2, button1);
    			append_dev(div6, t9);
    			append_dev(div6, div4);
    			append_dev(div4, h5);
    			append_dev(h5, t10);
    			append_dev(div6, t11);
    			append_dev(div6, div5);
    			append_dev(div5, button2);
    			append_dev(div5, t13);
    			append_dev(div5, button3);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*handleClick*/ ctx[4](0), false, false, false),
    					listen_dev(button1, "click", /*handleClick*/ ctx[4](1), false, false, false),
    					listen_dev(button2, "click", /*NextQuestion*/ ctx[3], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 4 && t4_value !== (t4_value = /*task01*/ ctx[2].question + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*showPopUp*/ 2) set_data_dev(t10, /*showPopUp*/ ctx[1]);

    			if (dirty & /*showNext*/ 1) {
    				set_style(h5, "display", /*showNext*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div8);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2a($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GV_MA_A6", slots, []);
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let task01 = taskOne$1F();

    	let CheckAnswer = function () {
    		if (answer == task01.answer) {
    			$$invalidate(1, showPopUp = randomCorrect());
    			$$invalidate(0, showNext = "inline-block");
    			return;
    		} else {
    			$$invalidate(1, showPopUp = randomWrong());
    			$$invalidate(0, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		answer = null;
    		$$invalidate(2, task01 = taskOne$1F());
    		$$invalidate(0, showNext = "none");
    	};

    	const handleClick = parameter => () => {
    		answer = parameter;
    		CheckAnswer();
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GV_MA_A6> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		randomCorrect,
    		randomWrong,
    		taskOne: taskOne$1F,
    		answer,
    		showNext,
    		showPopUp,
    		task01,
    		CheckAnswer,
    		NextQuestion,
    		handleClick
    	});

    	$$self.$inject_state = $$props => {
    		if ("answer" in $$props) answer = $$props.answer;
    		if ("showNext" in $$props) $$invalidate(0, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(1, showPopUp = $$props.showPopUp);
    		if ("task01" in $$props) $$invalidate(2, task01 = $$props.task01);
    		if ("CheckAnswer" in $$props) CheckAnswer = $$props.CheckAnswer;
    		if ("NextQuestion" in $$props) $$invalidate(3, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [showNext, showPopUp, task01, NextQuestion, handleClick];
    }

    class GV_MA_A6 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2a, create_fragment$2a, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GV_MA_A6",
    			options,
    			id: create_fragment$2a.name
    		});
    	}
    }

    let task01$1E = {
      questions: ["Subtract", "Add"],
      question: "",
      displayValueOne: 0,
      displayValueTwo: 0,
      answer: 0,
      randomAnswer: 0,
      operators: ["-", "+"],
      operator: "",
    };

    const maxValue$1f = 100000;
    const minValue$1f = 10000;

    function taskOne$1E() {
      task01$1E.randomAnswer = Math.floor(Math.random() * task01$1E.operators.length);
      task01$1E.displayValueOne =
        Math.floor(Math.random() * (maxValue$1f - minValue$1f)) + minValue$1f;

      task01$1E.operator = task01$1E.operators[task01$1E.randomAnswer];
      task01$1E.question = task01$1E.questions[task01$1E.randomAnswer];
      if (task01$1E.operator == "-") {
        task01$1E.displayValueTwo =
          Math.floor(Math.random() * (task01$1E.displayValueOne - minValue$1f)) +
          minValue$1f;

        task01$1E.answer = task01$1E.displayValueOne - task01$1E.displayValueTwo;
      } else {
        task01$1E.displayValueTwo =
          Math.floor(Math.random() * (maxValue$1f - minValue$1f)) + minValue$1f;
        task01$1E.answer = task01$1E.displayValueOne + task01$1E.displayValueTwo;
      }
      return task01$1E;
    }

    /* src/components/taskComponents/GV_MA_B1.svelte generated by Svelte v3.37.0 */
    const file$28 = "src/components/taskComponents/GV_MA_B1.svelte";

    function create_fragment$29(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h20;
    	let t1;
    	let div5;
    	let div2;
    	let h21;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let t4;
    	let div1;
    	let h40;
    	let t5_value = /*task01*/ ctx[0].displayValueOne + "";
    	let t5;
    	let t6;
    	let h41;
    	let t7_value = /*task01*/ ctx[0].operator + "";
    	let t7;
    	let t8;
    	let t9_value = /*task01*/ ctx[0].displayValueTwo + "";
    	let t9;
    	let t10;
    	let input;
    	let t11;
    	let h6;
    	let t12;
    	let t13_value = /*task01*/ ctx[0].answer + "";
    	let t13;
    	let t14;
    	let div3;
    	let h5;
    	let t15;
    	let t16;
    	let div4;
    	let button0;
    	let t18;
    	let button1;
    	let t20;
    	let button2;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h20 = element("h2");
    			h20.textContent = "Add and subtract whole numbers";
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h21 = element("h2");
    			t2 = text(t2_value);
    			t3 = text(".");
    			t4 = space();
    			div1 = element("div");
    			h40 = element("h4");
    			t5 = text(t5_value);
    			t6 = space();
    			h41 = element("h4");
    			t7 = text(t7_value);
    			t8 = space();
    			t9 = text(t9_value);
    			t10 = space();
    			input = element("input");
    			t11 = space();
    			h6 = element("h6");
    			t12 = text("answer ");
    			t13 = text(t13_value);
    			t14 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t15 = text(/*showPopUp*/ ctx[3]);
    			t16 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t18 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t20 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h20, "class", "text-center display-4 mb-0");
    			add_location(h20, file$28, 51, 10, 928);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$28, 50, 6, 878);
    			add_location(h21, file$28, 56, 12, 1118);
    			set_style(h40, "padding-left", "16px");
    			add_location(h40, file$28, 58, 16, 1184);
    			add_location(h41, file$28, 59, 16, 1263);
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$28, 60, 16, 1333);
    			add_location(h6, file$28, 61, 16, 1436);
    			add_location(div1, file$28, 57, 12, 1158);
    			add_location(div2, file$28, 55, 8, 1099);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$28, 66, 12, 1537);
    			add_location(div3, file$28, 65, 8, 1519);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$28, 70, 12, 1667);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$28, 71, 12, 1763);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$28, 72, 12, 1859);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$28, 69, 8, 1636);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$28, 54, 6, 1027);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$28, 49, 5, 830);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$28, 48, 1, 796);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h20);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h21);
    			append_dev(h21, t2);
    			append_dev(h21, t3);
    			append_dev(div2, t4);
    			append_dev(div2, div1);
    			append_dev(div1, h40);
    			append_dev(h40, t5);
    			append_dev(div1, t6);
    			append_dev(div1, h41);
    			append_dev(h41, t7);
    			append_dev(h41, t8);
    			append_dev(h41, t9);
    			append_dev(div1, t10);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t11);
    			append_dev(div1, h6);
    			append_dev(h6, t12);
    			append_dev(h6, t13);
    			append_dev(div5, t14);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t15);
    			append_dev(div5, t16);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t18);
    			append_dev(div4, button1);
    			append_dev(div4, t20);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*task01*/ 1 && t5_value !== (t5_value = /*task01*/ ctx[0].displayValueOne + "")) set_data_dev(t5, t5_value);
    			if (dirty & /*task01*/ 1 && t7_value !== (t7_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t7, t7_value);
    			if (dirty & /*task01*/ 1 && t9_value !== (t9_value = /*task01*/ ctx[0].displayValueTwo + "")) set_data_dev(t9, t9_value);

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t13_value !== (t13_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t13, t13_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t15, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$29.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$29($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GV_MA_B1", slots, []);
    	let task01 = taskOne$1E();
    	let answer;
    	let showNext = "none";
    	let showPopUp;

    	let CheckAnswer = function () {
    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			$$invalidate(2, showNext = "inline-block");
    			return;
    		} else {
    			$$invalidate(3, showPopUp = randomWrong());
    			$$invalidate(2, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$1E());
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GV_MA_B1> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1E,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class GV_MA_B1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$29, create_fragment$29, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GV_MA_B1",
    			options,
    			id: create_fragment$29.name
    		});
    	}
    }

    let task01$1D = {
      question: "",
      displayValueOne: 0,
      displayValueTwo: 0,
      answer: 0,
      randomAnswer: 0,
      operators: ["-", "+"],
      operator: "",
    };

    const maxValue$1e = 100000;
    const minValue$1e = 10000;

    function taskOne$1D() {
      task01$1D.randomAnswer = Math.floor(Math.random() * task01$1D.operators.length);
      task01$1D.displayValueOne =
        Math.floor(Math.random() * (maxValue$1e - minValue$1e)) + minValue$1e;

      task01$1D.operator = task01$1D.operators[task01$1D.randomAnswer];

      if (task01$1D.operator == "-") {
        task01$1D.displayValueTwo =
          Math.floor(Math.random() * (task01$1D.displayValueOne - minValue$1e)) +
          minValue$1e;

        task01$1D.answer = task01$1D.displayValueOne - task01$1D.displayValueTwo;
        task01$1D.question =
        "A video game company sold a total of " +
        task01$1D.displayValueOne +
        " white and black game consoles. They sold " +
        task01$1D.displayValueTwo +
        " black consoles. How many white consoles did they sell?";
      } else {
        task01$1D.displayValueTwo =
          Math.floor(Math.random() * (maxValue$1e - minValue$1e)) + minValue$1e;
        task01$1D.answer = task01$1D.displayValueOne + task01$1D.displayValueTwo;
        task01$1D.question =
        "After a natural disaster, a clothing company wanted to help. The company donated " +
        task01$1D.displayValueOne +
        " shirts and " +
        task01$1D.displayValueTwo +
        " pairs of trousers. How many pieces of clothing did the company donate?";
      }
      
      return task01$1D;
    }

    /* src/components/taskComponents/GV_MA_B2.svelte generated by Svelte v3.37.0 */
    const file$27 = "src/components/taskComponents/GV_MA_B2.svelte";

    function create_fragment$28(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let input;
    	let t4;
    	let h60;
    	let t5;
    	let t6_value = /*task01*/ ctx[0].answer + "";
    	let t6;
    	let t7;
    	let h61;
    	let t8;
    	let t9_value = /*task01*/ ctx[0].operator + "";
    	let t9;
    	let t10;
    	let div3;
    	let h5;
    	let t11;
    	let t12;
    	let div4;
    	let button0;
    	let t14;
    	let button1;
    	let t16;
    	let button2;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			h2.textContent = "Add and subtract whole numbers: word problems";
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			input = element("input");
    			t4 = space();
    			h60 = element("h6");
    			t5 = text("answer ");
    			t6 = text(t6_value);
    			t7 = space();
    			h61 = element("h6");
    			t8 = text("option : ");
    			t9 = text(t9_value);
    			t10 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t11 = text(/*showPopUp*/ ctx[3]);
    			t12 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t14 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t16 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$27, 51, 10, 931);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$27, 50, 6, 881);
    			add_location(h4, file$27, 56, 12, 1136);
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$27, 58, 16, 1199);
    			add_location(h60, file$27, 59, 16, 1302);
    			add_location(h61, file$27, 60, 16, 1350);
    			add_location(div1, file$27, 57, 12, 1175);
    			add_location(div2, file$27, 55, 8, 1117);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$27, 65, 12, 1455);
    			add_location(div3, file$27, 64, 8, 1437);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$27, 69, 12, 1585);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$27, 70, 12, 1681);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$27, 71, 12, 1777);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$27, 68, 8, 1554);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$27, 54, 6, 1045);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$27, 49, 5, 833);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$27, 48, 1, 799);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t4);
    			append_dev(div1, h60);
    			append_dev(h60, t5);
    			append_dev(h60, t6);
    			append_dev(div1, t7);
    			append_dev(div1, h61);
    			append_dev(h61, t8);
    			append_dev(h61, t9);
    			append_dev(div5, t10);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t11);
    			append_dev(div5, t12);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t14);
    			append_dev(div4, button1);
    			append_dev(div4, t16);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t6_value !== (t6_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*task01*/ 1 && t9_value !== (t9_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t9, t9_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t11, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$28.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$28($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GV_MA_B2", slots, []);
    	let task01 = taskOne$1D();
    	let answer;
    	let showNext = "none";
    	let showPopUp;

    	let CheckAnswer = function () {
    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			$$invalidate(2, showNext = "inline-block");
    			return;
    		} else {
    			$$invalidate(3, showPopUp = randomWrong());
    			$$invalidate(2, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$1D());
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GV_MA_B2> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1D,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class GV_MA_B2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$28, create_fragment$28, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GV_MA_B2",
    			options,
    			id: create_fragment$28.name
    		});
    	}
    }

    let task01$1C = {
      heading : "",
      question: "",
      valueArray: [], 
      answer: 0, 
      operator: "+",
      columns: 0
    };

    let columns$j = 3;
    let maxValue$1d = 0;
    let minValue$1d = 0;
    let heading$5 = "";
    let question$5 = "";


    function MaxandMin$5(max, min,col,headingtext,qst) {
      minValue$1d = min;
      maxValue$1d = max;
      columns$j = col;
      heading$5 = headingtext;
      question$5 = qst;
    }

    function taskOne$1C() {
      task01$1C.heading = heading$5;
      task01$1C.question = question$5;
      task01$1C.answer = 0;
      task01$1C.columns = columns$j;
      task01$1C.valueArray = [];
      for (let i = 0; i < columns$j; i++) {
        task01$1C.valueArray[i] = Math.floor(Math.random() * (maxValue$1d - minValue$1d + 1) ) + minValue$1d; 
        task01$1C.answer += task01$1C.valueArray[i];   
      }
      return task01$1C;
    }

    /* src/components/taskComponents/ReusableComponent/AdditionSolution.svelte generated by Svelte v3.37.0 */

    const file$26 = "src/components/taskComponents/ReusableComponent/AdditionSolution.svelte";

    function get_each_context$1J(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	child_ctx[22] = i;
    	return child_ctx;
    }

    function get_each_context_1$x(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	child_ctx[24] = i;
    	return child_ctx;
    }

    function get_each_context_2$e(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	child_ctx[24] = i;
    	return child_ctx;
    }

    function get_each_context_3$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	child_ctx[24] = i;
    	return child_ctx;
    }

    function get_each_context_4$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	child_ctx[28] = i;
    	return child_ctx;
    }

    function get_each_context_5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	child_ctx[24] = i;
    	return child_ctx;
    }

    function get_each_context_6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	child_ctx[24] = i;
    	return child_ctx;
    }

    function get_each_context_7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	child_ctx[24] = i;
    	return child_ctx;
    }

    function get_each_context_8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	child_ctx[33] = i;
    	return child_ctx;
    }

    function get_each_context_9(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	child_ctx[24] = i;
    	return child_ctx;
    }

    function get_each_context_10(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	child_ctx[24] = i;
    	return child_ctx;
    }

    function get_each_context_11(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	child_ctx[33] = i;
    	return child_ctx;
    }

    // (130:12) {#if ans_submit}
    function create_if_block$1o(ctx) {
    	let show_if;
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (show_if == null || dirty[0] & /*usr_resp, correct_answer*/ 1025) show_if = !!(parseInt(/*usr_resp*/ ctx[0], 10) == /*correct_answer*/ ctx[10]);
    		if (show_if) return create_if_block_1$l;
    		return create_else_block$1i;
    	}

    	let current_block_type = select_block_type(ctx, [-1]);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1o.name,
    		type: "if",
    		source: "(130:12) {#if ans_submit}",
    		ctx
    	});

    	return block;
    }

    // (134:12) {:else}
    function create_else_block$1i(ctx) {
    	let h20;
    	let t1;
    	let p0;
    	let t3;
    	let table0;
    	let tr0;
    	let th0;
    	let t5;
    	let th1;
    	let t7;
    	let t8;
    	let tr1;
    	let td0;
    	let t10;
    	let td1;
    	let t12;
    	let h21;
    	let t14;
    	let p1;
    	let t15;
    	let t16;
    	let t17;
    	let t18;
    	let h22;
    	let t20;
    	let table1;
    	let tr2;
    	let td2;
    	let t22;
    	let t23;
    	let t24;
    	let tr3;
    	let td3;
    	let t25;
    	let t26;
    	let t27;
    	let t28;
    	let t29;
    	let h23;
    	let t31;
    	let table2;
    	let each_value_11 = Array(/*num_qnty*/ ctx[3]);
    	validate_each_argument(each_value_11);
    	let each_blocks_4 = [];

    	for (let i = 0; i < each_value_11.length; i += 1) {
    		each_blocks_4[i] = create_each_block_11(get_each_context_11(ctx, each_value_11, i));
    	}

    	function select_block_type_3(ctx, dirty) {
    		if (/*answerchange*/ ctx[4] != null && /*answerchange*/ ctx[4] != "") return create_if_block_6$1;
    		return create_else_block_5;
    	}

    	let current_block_type = select_block_type_3(ctx);
    	let if_block = current_block_type(ctx);
    	let each_value_10 = Array(/*ansNumLength*/ ctx[9]);
    	validate_each_argument(each_value_10);
    	let each_blocks_3 = [];

    	for (let i = 0; i < each_value_10.length; i += 1) {
    		each_blocks_3[i] = create_each_block_10(get_each_context_10(ctx, each_value_10, i));
    	}

    	let each_value_8 = Array(/*num_qnty*/ ctx[3]);
    	validate_each_argument(each_value_8);
    	let each_blocks_2 = [];

    	for (let i = 0; i < each_value_8.length; i += 1) {
    		each_blocks_2[i] = create_each_block_8(get_each_context_8(ctx, each_value_8, i));
    	}

    	let each_value_7 = Array(/*ansNumLength*/ ctx[9]);
    	validate_each_argument(each_value_7);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_7.length; i += 1) {
    		each_blocks_1[i] = create_each_block_7(get_each_context_7(ctx, each_value_7, i));
    	}

    	let each_value = Array(/*ansNumLength*/ ctx[9]);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1J(get_each_context$1J(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			h20 = element("h2");
    			h20.textContent = "Response:";
    			t1 = space();
    			p0 = element("p");
    			p0.textContent = "Addition Problem:";
    			t3 = space();
    			table0 = element("table");
    			tr0 = element("tr");
    			th0 = element("th");
    			th0.textContent = "Operation";
    			t5 = space();
    			th1 = element("th");
    			th1.textContent = "Number";
    			t7 = space();

    			for (let i = 0; i < each_blocks_4.length; i += 1) {
    				each_blocks_4[i].c();
    			}

    			t8 = space();
    			tr1 = element("tr");
    			td0 = element("td");
    			td0.textContent = "=";
    			t10 = space();
    			td1 = element("td");
    			td1.textContent = "??";
    			t12 = space();
    			h21 = element("h2");
    			h21.textContent = "Hint:";
    			t14 = space();
    			p1 = element("p");
    			t15 = text("Correct answer is ");
    			if_block.c();
    			t16 = text(", but answer submitted is ");
    			t17 = text(/*usr_resp*/ ctx[0]);
    			t18 = space();
    			h22 = element("h2");
    			h22.textContent = "Answer:";
    			t20 = space();
    			table1 = element("table");
    			tr2 = element("tr");
    			td2 = element("td");
    			td2.textContent = "Carry Over:";
    			t22 = space();

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].c();
    			}

    			t23 = space();

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].c();
    			}

    			t24 = space();
    			tr3 = element("tr");
    			td3 = element("td");
    			t25 = text("Total for ");
    			t26 = text(/*num_qnty*/ ctx[3]);
    			t27 = text(" numbers =");
    			t28 = space();

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t29 = space();
    			h23 = element("h2");
    			h23.textContent = "Detailed Explanation:";
    			t31 = space();
    			table2 = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			set_style(h20, "color", "blue");
    			add_location(h20, file$26, 135, 12, 3865);
    			add_location(p0, file$26, 138, 12, 3933);
    			attr_dev(th0, "class", "svelte-1g62vdb");
    			add_location(th0, file$26, 141, 20, 4029);
    			attr_dev(th1, "class", "svelte-1g62vdb");
    			add_location(th1, file$26, 144, 20, 4114);
    			attr_dev(tr0, "class", "svelte-1g62vdb");
    			add_location(tr0, file$26, 140, 16, 4004);
    			add_location(td0, file$26, 167, 16, 4809);
    			add_location(td1, file$26, 168, 16, 4836);
    			attr_dev(tr1, "class", "svelte-1g62vdb");
    			add_location(tr1, file$26, 166, 12, 4788);
    			attr_dev(table0, "id", "t01");
    			attr_dev(table0, "class", "svelte-1g62vdb");
    			add_location(table0, file$26, 139, 12, 3971);
    			set_style(h21, "color", "blue");
    			add_location(h21, file$26, 172, 12, 4900);
    			add_location(p1, file$26, 173, 12, 4946);
    			set_style(h22, "color", "blue");
    			add_location(h22, file$26, 182, 12, 5288);
    			add_location(td2, file$26, 185, 20, 5386);
    			add_location(tr2, file$26, 184, 16, 5361);
    			add_location(td3, file$26, 200, 20, 6024);
    			add_location(tr3, file$26, 199, 16, 5999);
    			add_location(table1, file$26, 183, 12, 5337);
    			set_style(h23, "color", "blue");
    			add_location(h23, file$26, 207, 16, 6286);
    			add_location(table2, file$26, 208, 16, 6353);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h20, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p0, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, table0, anchor);
    			append_dev(table0, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t5);
    			append_dev(tr0, th1);
    			append_dev(table0, t7);

    			for (let i = 0; i < each_blocks_4.length; i += 1) {
    				each_blocks_4[i].m(table0, null);
    			}

    			append_dev(table0, t8);
    			append_dev(table0, tr1);
    			append_dev(tr1, td0);
    			append_dev(tr1, t10);
    			append_dev(tr1, td1);
    			insert_dev(target, t12, anchor);
    			insert_dev(target, h21, anchor);
    			insert_dev(target, t14, anchor);
    			insert_dev(target, p1, anchor);
    			append_dev(p1, t15);
    			if_block.m(p1, null);
    			append_dev(p1, t16);
    			append_dev(p1, t17);
    			insert_dev(target, t18, anchor);
    			insert_dev(target, h22, anchor);
    			insert_dev(target, t20, anchor);
    			insert_dev(target, table1, anchor);
    			append_dev(table1, tr2);
    			append_dev(tr2, td2);
    			append_dev(tr2, t22);

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].m(tr2, null);
    			}

    			append_dev(table1, t23);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].m(table1, null);
    			}

    			append_dev(table1, t24);
    			append_dev(table1, tr3);
    			append_dev(tr3, td3);
    			append_dev(td3, t25);
    			append_dev(td3, t26);
    			append_dev(td3, t27);
    			append_dev(tr3, t28);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(tr3, null);
    			}

    			insert_dev(target, t29, anchor);
    			insert_dev(target, h23, anchor);
    			insert_dev(target, t31, anchor);
    			insert_dev(target, table2, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table2, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*num, num_qnty*/ 12) {
    				each_value_11 = Array(/*num_qnty*/ ctx[3]);
    				validate_each_argument(each_value_11);
    				let i;

    				for (i = 0; i < each_value_11.length; i += 1) {
    					const child_ctx = get_each_context_11(ctx, each_value_11, i);

    					if (each_blocks_4[i]) {
    						each_blocks_4[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_4[i] = create_each_block_11(child_ctx);
    						each_blocks_4[i].c();
    						each_blocks_4[i].m(table0, t8);
    					}
    				}

    				for (; i < each_blocks_4.length; i += 1) {
    					each_blocks_4[i].d(1);
    				}

    				each_blocks_4.length = each_value_11.length;
    			}

    			if (current_block_type === (current_block_type = select_block_type_3(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(p1, t16);
    				}
    			}

    			if (dirty[0] & /*usr_resp*/ 1) set_data_dev(t17, /*usr_resp*/ ctx[0]);

    			if (dirty[0] & /*carry_array, ansNumLength*/ 768) {
    				each_value_10 = Array(/*ansNumLength*/ ctx[9]);
    				validate_each_argument(each_value_10);
    				let i;

    				for (i = 0; i < each_value_10.length; i += 1) {
    					const child_ctx = get_each_context_10(ctx, each_value_10, i);

    					if (each_blocks_3[i]) {
    						each_blocks_3[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_3[i] = create_each_block_10(child_ctx);
    						each_blocks_3[i].c();
    						each_blocks_3[i].m(tr2, null);
    					}
    				}

    				for (; i < each_blocks_3.length; i += 1) {
    					each_blocks_3[i].d(1);
    				}

    				each_blocks_3.length = each_value_10.length;
    			}

    			if (dirty[0] & /*ansNumLength, numArray, num_pos, num_qnty*/ 4648) {
    				each_value_8 = Array(/*num_qnty*/ ctx[3]);
    				validate_each_argument(each_value_8);
    				let i;

    				for (i = 0; i < each_value_8.length; i += 1) {
    					const child_ctx = get_each_context_8(ctx, each_value_8, i);

    					if (each_blocks_2[i]) {
    						each_blocks_2[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_2[i] = create_each_block_8(child_ctx);
    						each_blocks_2[i].c();
    						each_blocks_2[i].m(table1, t24);
    					}
    				}

    				for (; i < each_blocks_2.length; i += 1) {
    					each_blocks_2[i].d(1);
    				}

    				each_blocks_2.length = each_value_8.length;
    			}

    			if (dirty[0] & /*num_qnty*/ 8) set_data_dev(t26, /*num_qnty*/ ctx[3]);

    			if (dirty[0] & /*output_array, ansNumLength*/ 576) {
    				each_value_7 = Array(/*ansNumLength*/ ctx[9]);
    				validate_each_argument(each_value_7);
    				let i;

    				for (i = 0; i < each_value_7.length; i += 1) {
    					const child_ctx = get_each_context_7(ctx, each_value_7, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_7(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(tr3, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_7.length;
    			}

    			if (dirty[0] & /*ansNumLength, output_array, carry_array, result_array, add_units, num_qnty, numArray, num_pos*/ 7144) {
    				each_value = Array(/*ansNumLength*/ ctx[9]);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1J(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1J(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table2, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h20);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(table0);
    			destroy_each(each_blocks_4, detaching);
    			if (detaching) detach_dev(t12);
    			if (detaching) detach_dev(h21);
    			if (detaching) detach_dev(t14);
    			if (detaching) detach_dev(p1);
    			if_block.d();
    			if (detaching) detach_dev(t18);
    			if (detaching) detach_dev(h22);
    			if (detaching) detach_dev(t20);
    			if (detaching) detach_dev(table1);
    			destroy_each(each_blocks_3, detaching);
    			destroy_each(each_blocks_2, detaching);
    			destroy_each(each_blocks_1, detaching);
    			if (detaching) detach_dev(t29);
    			if (detaching) detach_dev(h23);
    			if (detaching) detach_dev(t31);
    			if (detaching) detach_dev(table2);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1i.name,
    		type: "else",
    		source: "(134:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (131:12) {#if (parseInt(usr_resp, 10) == correct_answer)}
    function create_if_block_1$l(ctx) {
    	let h2;

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			h2.textContent = "Response:";
    			set_style(h2, "color", "blue");
    			add_location(h2, file$26, 131, 12, 3781);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$l.name,
    		type: "if",
    		source: "(131:12) {#if (parseInt(usr_resp, 10) == correct_answer)}",
    		ctx
    	});

    	return block;
    }

    // (154:24) {:else}
    function create_else_block_7(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "+";
    			add_location(p, file$26, 154, 28, 4424);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_7.name,
    		type: "else",
    		source: "(154:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (152:24) {#if (i==0)}
    function create_if_block_8(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			add_location(p, file$26, 152, 28, 4353);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8.name,
    		type: "if",
    		source: "(152:24) {#if (i==0)}",
    		ctx
    	});

    	return block;
    }

    // (161:24) {:else}
    function create_else_block_6(ctx) {
    	let p;
    	let t_value = /*num*/ ctx[2][/*i*/ ctx[33]] + "";
    	let t;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t = text(t_value);
    			add_location(p, file$26, 161, 28, 4660);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*num*/ 4 && t_value !== (t_value = /*num*/ ctx[2][/*i*/ ctx[33]] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_6.name,
    		type: "else",
    		source: "(161:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (159:24) {#if (i==0)}
    function create_if_block_7(ctx) {
    	let p;
    	let t_value = /*num*/ ctx[2][0] + "";
    	let t;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t = text(t_value);
    			add_location(p, file$26, 159, 28, 4581);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*num*/ 4 && t_value !== (t_value = /*num*/ ctx[2][0] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7.name,
    		type: "if",
    		source: "(159:24) {#if (i==0)}",
    		ctx
    	});

    	return block;
    }

    // (149:12) {#each Array(num_qnty) as _, i}
    function create_each_block_11(ctx) {
    	let tr;
    	let td0;
    	let t;
    	let td1;

    	function select_block_type_1(ctx, dirty) {
    		if (/*i*/ ctx[33] == 0) return create_if_block_8;
    		return create_else_block_7;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block0 = current_block_type(ctx);

    	function select_block_type_2(ctx, dirty) {
    		if (/*i*/ ctx[33] == 0) return create_if_block_7;
    		return create_else_block_6;
    	}

    	let current_block_type_1 = select_block_type_2(ctx);
    	let if_block1 = current_block_type_1(ctx);

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			if_block0.c();
    			t = space();
    			td1 = element("td");
    			if_block1.c();
    			add_location(td0, file$26, 150, 20, 4283);
    			add_location(td1, file$26, 157, 20, 4511);
    			attr_dev(tr, "class", "svelte-1g62vdb");
    			add_location(tr, file$26, 149, 16, 4258);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			if_block0.m(td0, null);
    			append_dev(tr, t);
    			append_dev(tr, td1);
    			if_block1.m(td1, null);
    		},
    		p: function update(ctx, dirty) {
    			if_block1.p(ctx, dirty);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			if_block0.d();
    			if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_11.name,
    		type: "each",
    		source: "(149:12) {#each Array(num_qnty) as _, i}",
    		ctx
    	});

    	return block;
    }

    // (176:16) {:else}
    function create_else_block_5(ctx) {
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text(/*correct_answer*/ ctx[10]);
    			t1 = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*correct_answer*/ 1024) set_data_dev(t0, /*correct_answer*/ ctx[10]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_5.name,
    		type: "else",
    		source: "(176:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (174:33) {#if  answerchange != null && answerchange != ''}
    function create_if_block_6$1(ctx) {
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text(/*answerchange*/ ctx[4]);
    			t1 = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*answerchange*/ 16) set_data_dev(t0, /*answerchange*/ ctx[4]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$1.name,
    		type: "if",
    		source: "(174:33) {#if  answerchange != null && answerchange != ''}",
    		ctx
    	});

    	return block;
    }

    // (187:20) {#each Array(ansNumLength) as _, j}
    function create_each_block_10(ctx) {
    	let td;
    	let t_value = /*carry_array*/ ctx[8][/*j*/ ctx[24] + 1] + "";
    	let t;

    	const block = {
    		c: function create() {
    			td = element("td");
    			t = text(t_value);
    			add_location(td, file$26, 188, 24, 5575);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*carry_array*/ 256 && t_value !== (t_value = /*carry_array*/ ctx[8][/*j*/ ctx[24] + 1] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_10.name,
    		type: "each",
    		source: "(187:20) {#each Array(ansNumLength) as _, j}",
    		ctx
    	});

    	return block;
    }

    // (195:24) {#each Array(ansNumLength) as _, j}
    function create_each_block_9(ctx) {
    	let td;
    	let t_value = /*numArray*/ ctx[5][/*i*/ ctx[33]][/*j*/ ctx[24]] + "";
    	let t;

    	const block = {
    		c: function create() {
    			td = element("td");
    			t = text(t_value);
    			add_location(td, file$26, 195, 28, 5873);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*numArray*/ 32 && t_value !== (t_value = /*numArray*/ ctx[5][/*i*/ ctx[33]][/*j*/ ctx[24]] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_9.name,
    		type: "each",
    		source: "(195:24) {#each Array(ansNumLength) as _, j}",
    		ctx
    	});

    	return block;
    }

    // (192:16) {#each Array(num_qnty) as _, i}
    function create_each_block_8(ctx) {
    	let tr;
    	let td;
    	let t0;
    	let t1_value = /*num_pos*/ ctx[12][/*i*/ ctx[33]] + "";
    	let t1;
    	let t2;
    	let t3;
    	let each_value_9 = Array(/*ansNumLength*/ ctx[9]);
    	validate_each_argument(each_value_9);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_9.length; i += 1) {
    		each_blocks[i] = create_each_block_9(get_each_context_9(ctx, each_value_9, i));
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text("+ ");
    			t1 = text(t1_value);
    			t2 = text(" number:");
    			t3 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(td, file$26, 193, 24, 5752);
    			add_location(tr, file$26, 192, 20, 5723);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(td, t1);
    			append_dev(td, t2);
    			append_dev(tr, t3);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*numArray, ansNumLength*/ 544) {
    				each_value_9 = Array(/*ansNumLength*/ ctx[9]);
    				validate_each_argument(each_value_9);
    				let i;

    				for (i = 0; i < each_value_9.length; i += 1) {
    					const child_ctx = get_each_context_9(ctx, each_value_9, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_9(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_9.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_8.name,
    		type: "each",
    		source: "(192:16) {#each Array(num_qnty) as _, i}",
    		ctx
    	});

    	return block;
    }

    // (202:24) {#each Array(ansNumLength) as _, j}
    function create_each_block_7(ctx) {
    	let td;
    	let t0_value = /*output_array*/ ctx[6][/*j*/ ctx[24]] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			add_location(td, file$26, 202, 28, 6153);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, t0);
    			append_dev(td, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*output_array*/ 64 && t0_value !== (t0_value = /*output_array*/ ctx[6][/*j*/ ctx[24]] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_7.name,
    		type: "each",
    		source: "(202:24) {#each Array(ansNumLength) as _, j}",
    		ctx
    	});

    	return block;
    }

    // (221:28) {:else}
    function create_else_block_4(ctx) {
    	let td;

    	const block = {
    		c: function create() {
    			td = element("td");
    			add_location(td, file$26, 221, 32, 7076);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_4.name,
    		type: "else",
    		source: "(221:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (218:28) {#if (j== (ansNumLength -1 - k))}
    function create_if_block_5$2(ctx) {
    	let td;
    	let t_value = /*carry_array*/ ctx[8][/*j*/ ctx[24] + 1] + "";
    	let t;

    	const block = {
    		c: function create() {
    			td = element("td");
    			t = text(t_value);
    			add_location(td, file$26, 219, 32, 6978);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*carry_array*/ 256 && t_value !== (t_value = /*carry_array*/ ctx[8][/*j*/ ctx[24] + 1] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$2.name,
    		type: "if",
    		source: "(218:28) {#if (j== (ansNumLength -1 - k))}",
    		ctx
    	});

    	return block;
    }

    // (217:28) {#each Array(ansNumLength) as _, j}
    function create_each_block_6(ctx) {
    	let if_block_anchor;

    	function select_block_type_4(ctx, dirty) {
    		if (/*j*/ ctx[24] == /*ansNumLength*/ ctx[9] - 1 - /*k*/ ctx[22]) return create_if_block_5$2;
    		return create_else_block_4;
    	}

    	let current_block_type = select_block_type_4(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_4(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_6.name,
    		type: "each",
    		source: "(217:28) {#each Array(ansNumLength) as _, j}",
    		ctx
    	});

    	return block;
    }

    // (230:28) {#each Array(ansNumLength) as _, j}
    function create_each_block_5(ctx) {
    	let td;
    	let t_value = /*numArray*/ ctx[5][/*n*/ ctx[28]][/*j*/ ctx[24]] + "";
    	let t;

    	const block = {
    		c: function create() {
    			td = element("td");
    			t = text(t_value);
    			add_location(td, file$26, 230, 32, 7506);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*numArray*/ 32 && t_value !== (t_value = /*numArray*/ ctx[5][/*n*/ ctx[28]][/*j*/ ctx[24]] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_5.name,
    		type: "each",
    		source: "(230:28) {#each Array(ansNumLength) as _, j}",
    		ctx
    	});

    	return block;
    }

    // (227:24) {#each Array(num_qnty) as _, n}
    function create_each_block_4$1(ctx) {
    	let tr;
    	let td;
    	let t0;
    	let t1_value = /*num_pos*/ ctx[12][/*n*/ ctx[28]] + "";
    	let t1;
    	let t2;
    	let t3;
    	let each_value_5 = Array(/*ansNumLength*/ ctx[9]);
    	validate_each_argument(each_value_5);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_5.length; i += 1) {
    		each_blocks[i] = create_each_block_5(get_each_context_5(ctx, each_value_5, i));
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text("+ ");
    			t1 = text(t1_value);
    			t2 = text(" Number:");
    			t3 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(td, file$26, 228, 28, 7376);
    			add_location(tr, file$26, 227, 24, 7343);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(td, t1);
    			append_dev(td, t2);
    			append_dev(tr, t3);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*numArray, ansNumLength*/ 544) {
    				each_value_5 = Array(/*ansNumLength*/ ctx[9]);
    				validate_each_argument(each_value_5);
    				let i;

    				for (i = 0; i < each_value_5.length; i += 1) {
    					const child_ctx = get_each_context_5(ctx, each_value_5, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_5(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_5.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_4$1.name,
    		type: "each",
    		source: "(227:24) {#each Array(num_qnty) as _, n}",
    		ctx
    	});

    	return block;
    }

    // (240:32) {:else}
    function create_else_block_3$1(ctx) {
    	let td;

    	const block = {
    		c: function create() {
    			td = element("td");
    			add_location(td, file$26, 240, 36, 7995);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3$1.name,
    		type: "else",
    		source: "(240:32) {:else}",
    		ctx
    	});

    	return block;
    }

    // (238:32) {#if (j== (ansNumLength -1 - k))}
    function create_if_block_4$3(ctx) {
    	let td;
    	let t0_value = /*result_array*/ ctx[7][/*j*/ ctx[24]] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			add_location(td, file$26, 238, 36, 7890);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, t0);
    			append_dev(td, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*result_array*/ 128 && t0_value !== (t0_value = /*result_array*/ ctx[7][/*j*/ ctx[24]] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$3.name,
    		type: "if",
    		source: "(238:32) {#if (j== (ansNumLength -1 - k))}",
    		ctx
    	});

    	return block;
    }

    // (237:28) {#each Array(ansNumLength) as _, j}
    function create_each_block_3$1(ctx) {
    	let if_block_anchor;

    	function select_block_type_5(ctx, dirty) {
    		if (/*j*/ ctx[24] == /*ansNumLength*/ ctx[9] - 1 - /*k*/ ctx[22]) return create_if_block_4$3;
    		return create_else_block_3$1;
    	}

    	let current_block_type = select_block_type_5(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_5(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3$1.name,
    		type: "each",
    		source: "(237:28) {#each Array(ansNumLength) as _, j}",
    		ctx
    	});

    	return block;
    }

    // (250:32) {:else}
    function create_else_block_2$b(ctx) {
    	let td;

    	const block = {
    		c: function create() {
    			td = element("td");
    			add_location(td, file$26, 250, 36, 8464);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$b.name,
    		type: "else",
    		source: "(250:32) {:else}",
    		ctx
    	});

    	return block;
    }

    // (248:32) {#if (j== (ansNumLength -1 - k))}
    function create_if_block_3$3(ctx) {
    	let td;
    	let t0_value = /*carry_array*/ ctx[8][/*j*/ ctx[24]] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			add_location(td, file$26, 248, 36, 8360);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, t0);
    			append_dev(td, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*carry_array*/ 256 && t0_value !== (t0_value = /*carry_array*/ ctx[8][/*j*/ ctx[24]] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$3.name,
    		type: "if",
    		source: "(248:32) {#if (j== (ansNumLength -1 - k))}",
    		ctx
    	});

    	return block;
    }

    // (247:28) {#each Array(ansNumLength) as _, j}
    function create_each_block_2$e(ctx) {
    	let if_block_anchor;

    	function select_block_type_6(ctx, dirty) {
    		if (/*j*/ ctx[24] == /*ansNumLength*/ ctx[9] - 1 - /*k*/ ctx[22]) return create_if_block_3$3;
    		return create_else_block_2$b;
    	}

    	let current_block_type = select_block_type_6(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_6(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$e.name,
    		type: "each",
    		source: "(247:28) {#each Array(ansNumLength) as _, j}",
    		ctx
    	});

    	return block;
    }

    // (260:32) {:else}
    function create_else_block_1$b(ctx) {
    	let td;

    	const block = {
    		c: function create() {
    			td = element("td");
    			add_location(td, file$26, 260, 36, 8932);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$b.name,
    		type: "else",
    		source: "(260:32) {:else}",
    		ctx
    	});

    	return block;
    }

    // (258:32) {#if (j>= (ansNumLength -1 - k))}
    function create_if_block_2$l(ctx) {
    	let td;
    	let t0_value = /*output_array*/ ctx[6][/*j*/ ctx[24]] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			add_location(td, file$26, 258, 36, 8827);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, t0);
    			append_dev(td, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*output_array*/ 64 && t0_value !== (t0_value = /*output_array*/ ctx[6][/*j*/ ctx[24]] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$l.name,
    		type: "if",
    		source: "(258:32) {#if (j>= (ansNumLength -1 - k))}",
    		ctx
    	});

    	return block;
    }

    // (257:28) {#each Array(ansNumLength) as _, j}
    function create_each_block_1$x(ctx) {
    	let if_block_anchor;

    	function select_block_type_7(ctx, dirty) {
    		if (/*j*/ ctx[24] >= /*ansNumLength*/ ctx[9] - 1 - /*k*/ ctx[22]) return create_if_block_2$l;
    		return create_else_block_1$b;
    	}

    	let current_block_type = select_block_type_7(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_7(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$x.name,
    		type: "each",
    		source: "(257:28) {#each Array(ansNumLength) as _, j}",
    		ctx
    	});

    	return block;
    }

    // (210:24) {#each Array(ansNumLength) as _, k}
    function create_each_block$1J(ctx) {
    	let tr0;
    	let td0;
    	let t0;
    	let t1_value = /*k*/ ctx[22] + 1 + "";
    	let t1;
    	let t2;
    	let t3_value = /*add_units*/ ctx[11][/*k*/ ctx[22]] + "";
    	let t3;
    	let t4;
    	let t5;
    	let tr1;
    	let td1;
    	let t7;
    	let t8;
    	let t9;
    	let tr2;
    	let td2;
    	let t10;
    	let t11_value = /*add_units*/ ctx[11][/*k*/ ctx[22]] + "";
    	let t11;
    	let t12;
    	let t13;
    	let t14;
    	let tr3;
    	let td3;
    	let t16;
    	let t17;
    	let tr4;
    	let td4;
    	let t19;
    	let t20;
    	let tr5;
    	let td5;
    	let t21;
    	let tr6;
    	let td6;
    	let t23;
    	let tr7;
    	let td7;
    	let t24;
    	let each_value_6 = Array(/*ansNumLength*/ ctx[9]);
    	validate_each_argument(each_value_6);
    	let each_blocks_4 = [];

    	for (let i = 0; i < each_value_6.length; i += 1) {
    		each_blocks_4[i] = create_each_block_6(get_each_context_6(ctx, each_value_6, i));
    	}

    	let each_value_4 = Array(/*num_qnty*/ ctx[3]);
    	validate_each_argument(each_value_4);
    	let each_blocks_3 = [];

    	for (let i = 0; i < each_value_4.length; i += 1) {
    		each_blocks_3[i] = create_each_block_4$1(get_each_context_4$1(ctx, each_value_4, i));
    	}

    	let each_value_3 = Array(/*ansNumLength*/ ctx[9]);
    	validate_each_argument(each_value_3);
    	let each_blocks_2 = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks_2[i] = create_each_block_3$1(get_each_context_3$1(ctx, each_value_3, i));
    	}

    	let each_value_2 = Array(/*ansNumLength*/ ctx[9]);
    	validate_each_argument(each_value_2);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks_1[i] = create_each_block_2$e(get_each_context_2$e(ctx, each_value_2, i));
    	}

    	let each_value_1 = Array(/*ansNumLength*/ ctx[9]);
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$x(get_each_context_1$x(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			tr0 = element("tr");
    			td0 = element("td");
    			t0 = text("Step ");
    			t1 = text(t1_value);
    			t2 = text(": work with ");
    			t3 = text(t3_value);
    			t4 = text(".");
    			t5 = space();
    			tr1 = element("tr");
    			td1 = element("td");
    			td1.textContent = "Previous Carry:";
    			t7 = space();

    			for (let i = 0; i < each_blocks_4.length; i += 1) {
    				each_blocks_4[i].c();
    			}

    			t8 = space();

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].c();
    			}

    			t9 = space();
    			tr2 = element("tr");
    			td2 = element("td");
    			t10 = text("Adding of ");
    			t11 = text(t11_value);
    			t12 = text(" =");
    			t13 = space();

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].c();
    			}

    			t14 = space();
    			tr3 = element("tr");
    			td3 = element("td");
    			td3.textContent = "New Carry Over =";
    			t16 = space();

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t17 = space();
    			tr4 = element("tr");
    			td4 = element("td");
    			td4.textContent = "Total so far =";
    			t19 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t20 = space();
    			tr5 = element("tr");
    			td5 = element("td");
    			t21 = space();
    			tr6 = element("tr");
    			td6 = element("td");
    			td6.textContent = "-- -- -- -- -- --";
    			t23 = space();
    			tr7 = element("tr");
    			td7 = element("td");
    			t24 = space();
    			add_location(td0, file$26, 211, 28, 6479);
    			add_location(tr0, file$26, 210, 24, 6445);
    			add_location(td1, file$26, 215, 28, 6699);
    			add_location(tr1, file$26, 213, 24, 6582);
    			add_location(td2, file$26, 235, 28, 7687);
    			add_location(tr2, file$26, 234, 24, 7654);
    			add_location(td3, file$26, 245, 28, 8167);
    			add_location(tr3, file$26, 244, 24, 8134);
    			add_location(td4, file$26, 255, 28, 8636);
    			add_location(tr4, file$26, 254, 24, 8603);
    			add_location(td5, file$26, 265, 28, 9105);
    			add_location(tr5, file$26, 264, 24, 9071);
    			add_location(td6, file$26, 268, 28, 9205);
    			add_location(tr6, file$26, 267, 24, 9171);
    			add_location(td7, file$26, 271, 28, 9322);
    			add_location(tr7, file$26, 270, 24, 9288);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr0, anchor);
    			append_dev(tr0, td0);
    			append_dev(td0, t0);
    			append_dev(td0, t1);
    			append_dev(td0, t2);
    			append_dev(td0, t3);
    			append_dev(td0, t4);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, tr1, anchor);
    			append_dev(tr1, td1);
    			append_dev(tr1, t7);

    			for (let i = 0; i < each_blocks_4.length; i += 1) {
    				each_blocks_4[i].m(tr1, null);
    			}

    			insert_dev(target, t8, anchor);

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].m(target, anchor);
    			}

    			insert_dev(target, t9, anchor);
    			insert_dev(target, tr2, anchor);
    			append_dev(tr2, td2);
    			append_dev(td2, t10);
    			append_dev(td2, t11);
    			append_dev(td2, t12);
    			append_dev(tr2, t13);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].m(tr2, null);
    			}

    			insert_dev(target, t14, anchor);
    			insert_dev(target, tr3, anchor);
    			append_dev(tr3, td3);
    			append_dev(tr3, t16);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(tr3, null);
    			}

    			insert_dev(target, t17, anchor);
    			insert_dev(target, tr4, anchor);
    			append_dev(tr4, td4);
    			append_dev(tr4, t19);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr4, null);
    			}

    			insert_dev(target, t20, anchor);
    			insert_dev(target, tr5, anchor);
    			append_dev(tr5, td5);
    			insert_dev(target, t21, anchor);
    			insert_dev(target, tr6, anchor);
    			append_dev(tr6, td6);
    			insert_dev(target, t23, anchor);
    			insert_dev(target, tr7, anchor);
    			append_dev(tr7, td7);
    			append_dev(tr7, t24);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*carry_array, ansNumLength*/ 768) {
    				each_value_6 = Array(/*ansNumLength*/ ctx[9]);
    				validate_each_argument(each_value_6);
    				let i;

    				for (i = 0; i < each_value_6.length; i += 1) {
    					const child_ctx = get_each_context_6(ctx, each_value_6, i);

    					if (each_blocks_4[i]) {
    						each_blocks_4[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_4[i] = create_each_block_6(child_ctx);
    						each_blocks_4[i].c();
    						each_blocks_4[i].m(tr1, null);
    					}
    				}

    				for (; i < each_blocks_4.length; i += 1) {
    					each_blocks_4[i].d(1);
    				}

    				each_blocks_4.length = each_value_6.length;
    			}

    			if (dirty[0] & /*ansNumLength, numArray, num_pos, num_qnty*/ 4648) {
    				each_value_4 = Array(/*num_qnty*/ ctx[3]);
    				validate_each_argument(each_value_4);
    				let i;

    				for (i = 0; i < each_value_4.length; i += 1) {
    					const child_ctx = get_each_context_4$1(ctx, each_value_4, i);

    					if (each_blocks_3[i]) {
    						each_blocks_3[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_3[i] = create_each_block_4$1(child_ctx);
    						each_blocks_3[i].c();
    						each_blocks_3[i].m(t9.parentNode, t9);
    					}
    				}

    				for (; i < each_blocks_3.length; i += 1) {
    					each_blocks_3[i].d(1);
    				}

    				each_blocks_3.length = each_value_4.length;
    			}

    			if (dirty[0] & /*result_array, ansNumLength*/ 640) {
    				each_value_3 = Array(/*ansNumLength*/ ctx[9]);
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3$1(ctx, each_value_3, i);

    					if (each_blocks_2[i]) {
    						each_blocks_2[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_2[i] = create_each_block_3$1(child_ctx);
    						each_blocks_2[i].c();
    						each_blocks_2[i].m(tr2, null);
    					}
    				}

    				for (; i < each_blocks_2.length; i += 1) {
    					each_blocks_2[i].d(1);
    				}

    				each_blocks_2.length = each_value_3.length;
    			}

    			if (dirty[0] & /*carry_array, ansNumLength*/ 768) {
    				each_value_2 = Array(/*ansNumLength*/ ctx[9]);
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$e(ctx, each_value_2, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_2$e(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(tr3, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_2.length;
    			}

    			if (dirty[0] & /*output_array, ansNumLength*/ 576) {
    				each_value_1 = Array(/*ansNumLength*/ ctx[9]);
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$x(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$x(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr4, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr0);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(tr1);
    			destroy_each(each_blocks_4, detaching);
    			if (detaching) detach_dev(t8);
    			destroy_each(each_blocks_3, detaching);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(tr2);
    			destroy_each(each_blocks_2, detaching);
    			if (detaching) detach_dev(t14);
    			if (detaching) detach_dev(tr3);
    			destroy_each(each_blocks_1, detaching);
    			if (detaching) detach_dev(t17);
    			if (detaching) detach_dev(tr4);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t20);
    			if (detaching) detach_dev(tr5);
    			if (detaching) detach_dev(t21);
    			if (detaching) detach_dev(tr6);
    			if (detaching) detach_dev(t23);
    			if (detaching) detach_dev(tr7);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1J.name,
    		type: "each",
    		source: "(210:24) {#each Array(ansNumLength) as _, k}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$27(ctx) {
    	let div1;
    	let div0;
    	let if_block = /*ans_submit*/ ctx[1] && create_if_block$1o(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			if (if_block) if_block.c();
    			add_location(div0, file$26, 125, 4, 3657);
    			attr_dev(div1, "class", "stack-large");
    			add_location(div1, file$26, 123, 0, 3623);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			if (if_block) if_block.m(div0, null);
    		},
    		p: function update(ctx, dirty) {
    			if (/*ans_submit*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$1o(ctx);
    					if_block.c();
    					if_block.m(div0, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$27.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function skill_exit$1() {
    	
    }

    function instance$27($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AdditionSolution", slots, []);
    	let { usr_resp = -1 } = $$props; // User input value
    	let { num = [] } = $$props;
    	let { num_qnty = 3 } = $$props; // column
    	let { ans_submit = false } = $$props; // column
    	let { answerchange = "" } = $$props;
    	let numArray = [];
    	let output_array = [];
    	let result_array = [];
    	let carry_array = [];
    	let maxNumLength = 0;
    	let ansNumLength = 0;
    	let correct_answer = 0;

    	const add_units = [
    		"Ones",
    		"Tens",
    		"Hundreds",
    		"Thousands",
    		"Ten Thousands",
    		"Hundred Thousands",
    		"Millions"
    	];

    	const num_pos = [
    		"First",
    		"Second",
    		"Third",
    		"Fourth",
    		"Fifth",
    		"Sixth",
    		"Seventh",
    		"Eighth",
    		"Ninth",
    		"Tenth"
    	];

    	function setup_numObj() {
    		maxNumLength = 0;

    		for (let i = 0; i < num_qnty; i++) {
    			$$invalidate(5, numArray[i] = num[i].toString().split("").reverse(), numArray);

    			if (maxNumLength < numArray[i].length) {
    				maxNumLength = numArray[i].length;
    			}

    			
    			$$invalidate(10, correct_answer += num[i]);
    		}

    		

    		// sometimes the answer is longer than the number of digits 
    		// in each of the operands
    		$$invalidate(9, ansNumLength = correct_answer.toString().split("").length);

    		//pad the extra digits for the numbers with useless 0s
    		for (let i = 0; i < num_qnty; i++) {
    			for (let j = 0; j < ansNumLength; j++) {
    				if (j >= numArray[i].length) {
    					$$invalidate(5, numArray[i][j] = "", numArray);
    				}
    			}

    			
    		}

    		

    		// intialize carryovers and the final output answer
    		$$invalidate(7, result_array = []);

    		$$invalidate(8, carry_array = []);
    		$$invalidate(6, output_array = []);
    	}

    	

    	function setup_randomAnswer() {
    		$$invalidate(0, usr_resp = -1);
    		$$invalidate(1, ans_submit = false); // show solution
    	}

    	

    	function init_addNumb() {
    		setup_numObj();
    		setup_randomAnswer();

    		//prepareNum_for_addition(num1, num2);
    		addStrings();

    		prepareNum_for_display();
    	}

    	
    	init_addNumb();

    	function submitted() {
    		$$invalidate(1, ans_submit = true);
    	}

    	
    	

    	function prepareNum_for_display() {
    		let temp;

    		for (let i = 0; i < num_qnty; i++) {
    			temp = numArray[i].reverse();
    			$$invalidate(5, numArray[i] = [...temp], numArray);
    		}

    		
    		temp = result_array.reverse();
    		$$invalidate(7, result_array = [...temp]);
    		temp = carry_array.reverse();
    		$$invalidate(8, carry_array = [...temp]);
    		temp = output_array.reverse();
    		$$invalidate(6, output_array = [...temp]);
    	}

    	

    	function addStrings() {
    		let result = 0;
    		$$invalidate(8, carry_array[0] = 0, carry_array); // there is no carryover for "ones" place

    		// index on j to get to each digit of any given number
    		for (let j = 0; j < ansNumLength; j++) {
    			result = 0;
    			$$invalidate(6, output_array[j] = 0, output_array);
    			$$invalidate(7, result_array[j] = 0, result_array);
    			$$invalidate(8, carry_array[0] = 0, carry_array);
    			result += Number(carry_array[j]);

    			// index on i to get to each operand number
    			for (let i = 0; i < num_qnty; i++) {
    				result += Number(numArray[i][j]);
    				$$invalidate(7, result_array[j] = result, result_array);

    				//               console.log('i: ' + i + ' j: '+j + ' num= '+ numArray[i][j]+ ' result '+result);
    				// removing the last digit in result for identifing  
    				// next digit carryover
    				$$invalidate(8, carry_array[j + 1] = Math.floor(result / 10), carry_array);

    				// using the mod operator to identify 'ones' digit to keep
    				$$invalidate(6, output_array[j] = result % 10, output_array);
    			}
    		} //            console.log('j: '+j+ ' result: '+result_array[j]+' carry over: '+carry_array[j+1] + ' output ' + output_array[j]);

    		
    	}

    	
    	const writable_props = ["usr_resp", "num", "num_qnty", "ans_submit", "answerchange"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AdditionSolution> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("usr_resp" in $$props) $$invalidate(0, usr_resp = $$props.usr_resp);
    		if ("num" in $$props) $$invalidate(2, num = $$props.num);
    		if ("num_qnty" in $$props) $$invalidate(3, num_qnty = $$props.num_qnty);
    		if ("ans_submit" in $$props) $$invalidate(1, ans_submit = $$props.ans_submit);
    		if ("answerchange" in $$props) $$invalidate(4, answerchange = $$props.answerchange);
    	};

    	$$self.$capture_state = () => ({
    		usr_resp,
    		num,
    		num_qnty,
    		ans_submit,
    		answerchange,
    		numArray,
    		output_array,
    		result_array,
    		carry_array,
    		maxNumLength,
    		ansNumLength,
    		correct_answer,
    		add_units,
    		num_pos,
    		setup_numObj,
    		setup_randomAnswer,
    		init_addNumb,
    		submitted,
    		skill_exit: skill_exit$1,
    		prepareNum_for_display,
    		addStrings
    	});

    	$$self.$inject_state = $$props => {
    		if ("usr_resp" in $$props) $$invalidate(0, usr_resp = $$props.usr_resp);
    		if ("num" in $$props) $$invalidate(2, num = $$props.num);
    		if ("num_qnty" in $$props) $$invalidate(3, num_qnty = $$props.num_qnty);
    		if ("ans_submit" in $$props) $$invalidate(1, ans_submit = $$props.ans_submit);
    		if ("answerchange" in $$props) $$invalidate(4, answerchange = $$props.answerchange);
    		if ("numArray" in $$props) $$invalidate(5, numArray = $$props.numArray);
    		if ("output_array" in $$props) $$invalidate(6, output_array = $$props.output_array);
    		if ("result_array" in $$props) $$invalidate(7, result_array = $$props.result_array);
    		if ("carry_array" in $$props) $$invalidate(8, carry_array = $$props.carry_array);
    		if ("maxNumLength" in $$props) maxNumLength = $$props.maxNumLength;
    		if ("ansNumLength" in $$props) $$invalidate(9, ansNumLength = $$props.ansNumLength);
    		if ("correct_answer" in $$props) $$invalidate(10, correct_answer = $$props.correct_answer);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		usr_resp,
    		ans_submit,
    		num,
    		num_qnty,
    		answerchange,
    		numArray,
    		output_array,
    		result_array,
    		carry_array,
    		ansNumLength,
    		correct_answer,
    		add_units,
    		num_pos
    	];
    }

    class AdditionSolution extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$27,
    			create_fragment$27,
    			safe_not_equal,
    			{
    				usr_resp: 0,
    				num: 2,
    				num_qnty: 3,
    				ans_submit: 1,
    				answerchange: 4
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AdditionSolution",
    			options,
    			id: create_fragment$27.name
    		});
    	}

    	get usr_resp() {
    		throw new Error("<AdditionSolution>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set usr_resp(value) {
    		throw new Error("<AdditionSolution>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get num() {
    		throw new Error("<AdditionSolution>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set num(value) {
    		throw new Error("<AdditionSolution>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get num_qnty() {
    		throw new Error("<AdditionSolution>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set num_qnty(value) {
    		throw new Error("<AdditionSolution>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ans_submit() {
    		throw new Error("<AdditionSolution>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ans_submit(value) {
    		throw new Error("<AdditionSolution>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get answerchange() {
    		throw new Error("<AdditionSolution>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set answerchange(value) {
    		throw new Error("<AdditionSolution>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/taskComponents/GIV_MA_B1.svelte generated by Svelte v3.37.0 */
    const file$25 = "src/components/taskComponents/GIV_MA_B1.svelte";

    function get_each_context$1I(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	child_ctx[13] = i;
    	return child_ctx;
    }

    // (72:28) {:else}
    function create_else_block$1h(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[11] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$25, 73, 32, 2050);
    			add_location(tr, file$25, 72, 28, 2013);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[11] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1h.name,
    		type: "else",
    		source: "(72:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (68:28) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$1n(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[11] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$25, 69, 50, 1846);
    			attr_dev(td, "align", "right");
    			add_location(td, file$25, 69, 32, 1828);
    			add_location(tr, file$25, 68, 28, 1791);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[11] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1n.name,
    		type: "if",
    		source: "(68:28) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (67:24) {#each task01.valueArray as col, i }
    function create_each_block$1I(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[13] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$1n;
    		return create_else_block$1h;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1I.name,
    		type: "each",
    		source: "(67:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$26(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let solution;
    	let t12;
    	let div4;
    	let button0;
    	let t14;
    	let button1;
    	let t16;
    	let button2;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1I(get_each_context$1I(ctx, each_value, i));
    	}

    	solution = new AdditionSolution({
    			props: {
    				num_qnty: /*task01*/ ctx[0].columns,
    				usr_resp: /*answer*/ ctx[1],
    				num: /*task01*/ ctx[0].valueArray,
    				ans_submit: /*showSolution*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			create_component(solution.$$.fragment);
    			t12 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t14 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t16 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$25, 53, 10, 1316);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$25, 52, 6, 1266);
    			add_location(h4, file$25, 60, 12, 1494);
    			attr_dev(table, "width", "100");
    			add_location(table, file$25, 64, 16, 1566);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$25, 78, 20, 2243);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$25, 79, 20, 2338);
    			add_location(h6, file$25, 80, 20, 2460);
    			add_location(div1, file$25, 62, 12, 1539);
    			add_location(div2, file$25, 57, 8, 1473);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$25, 85, 12, 2568);
    			add_location(div3, file$25, 84, 8, 2550);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$25, 89, 12, 2812);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$25, 90, 12, 2908);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$25, 91, 12, 3004);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$25, 88, 8, 2781);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$25, 56, 6, 1401);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$25, 51, 5, 1218);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$25, 50, 1, 1184);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			mount_component(solution, div5, null);
    			append_dev(div5, t12);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t14);
    			append_dev(div4, button1);
    			append_dev(div4, t16);
    			append_dev(div4, button2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[7]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*task01*/ 1) && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*task01*/ 1) && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1I(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1I(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if ((!current || dirty & /*task01*/ 1) && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (!current || dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (!current || dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}

    			const solution_changes = {};
    			if (dirty & /*task01*/ 1) solution_changes.num_qnty = /*task01*/ ctx[0].columns;
    			if (dirty & /*answer*/ 2) solution_changes.usr_resp = /*answer*/ ctx[1];
    			if (dirty & /*task01*/ 1) solution_changes.num = /*task01*/ ctx[0].valueArray;
    			if (dirty & /*showSolution*/ 16) solution_changes.ans_submit = /*showSolution*/ ctx[4];
    			solution.$set(solution_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			destroy_component(solution);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$26.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const max$y = 9999;
    const min$y = 1000;
    const numberofColumn$w = 2;

    function instance$26($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GIV_MA_B1", slots, []);
    	let heading = "Add numbers up to five digits";
    	let question = "Add :";
    	let maxandmin = MaxandMin$5(max$y, min$y, numberofColumn$w, heading, question);
    	let task01 = taskOne$1C();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			$$invalidate(4, showSolution = true);
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$1C());
    		$$invalidate(4, showSolution = false);
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GIV_MA_B1> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1C,
    		randomCorrect,
    		randomWrong,
    		MaxandMin: MaxandMin$5,
    		Solution: AdditionSolution,
    		heading,
    		question,
    		max: max$y,
    		min: min$y,
    		numberofColumn: numberofColumn$w,
    		maxandmin,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("heading" in $$props) heading = $$props.heading;
    		if ("question" in $$props) question = $$props.question;
    		if ("maxandmin" in $$props) maxandmin = $$props.maxandmin;
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) $$invalidate(4, showSolution = $$props.showSolution);
    		if ("CheckAnswer" in $$props) $$invalidate(5, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(6, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class GIV_MA_B1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$26, create_fragment$26, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GIV_MA_B1",
    			options,
    			id: create_fragment$26.name
    		});
    	}
    }

    /* src/components/taskComponents/GIII_MA_C1.svelte generated by Svelte v3.37.0 */
    const file$24 = "src/components/taskComponents/GIII_MA_C1.svelte";

    function get_each_context$1H(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	child_ctx[13] = i;
    	return child_ctx;
    }

    // (72:28) {:else}
    function create_else_block$1g(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[11] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$24, 73, 32, 2053);
    			add_location(tr, file$24, 72, 28, 2016);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[11] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1g.name,
    		type: "else",
    		source: "(72:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (68:28) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$1m(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[11] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$24, 69, 50, 1849);
    			attr_dev(td, "align", "right");
    			add_location(td, file$24, 69, 32, 1831);
    			add_location(tr, file$24, 68, 28, 1794);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[11] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1m.name,
    		type: "if",
    		source: "(68:28) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (67:24) {#each task01.valueArray as col, i }
    function create_each_block$1H(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[13] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$1m;
    		return create_else_block$1g;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1H.name,
    		type: "each",
    		source: "(67:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$25(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let solution;
    	let t12;
    	let div4;
    	let button0;
    	let t14;
    	let button1;
    	let t16;
    	let button2;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1H(get_each_context$1H(ctx, each_value, i));
    	}

    	solution = new AdditionSolution({
    			props: {
    				num_qnty: /*task01*/ ctx[0].columns,
    				usr_resp: /*answer*/ ctx[1],
    				num: /*task01*/ ctx[0].valueArray,
    				ans_submit: /*showSolution*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			create_component(solution.$$.fragment);
    			t12 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t14 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t16 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$24, 53, 10, 1319);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$24, 52, 6, 1269);
    			add_location(h4, file$24, 60, 12, 1497);
    			attr_dev(table, "width", "100");
    			add_location(table, file$24, 64, 16, 1569);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$24, 78, 20, 2246);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$24, 79, 20, 2341);
    			add_location(h6, file$24, 80, 20, 2463);
    			add_location(div1, file$24, 62, 12, 1542);
    			add_location(div2, file$24, 57, 8, 1476);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$24, 85, 12, 2571);
    			add_location(div3, file$24, 84, 8, 2553);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$24, 89, 12, 2815);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$24, 90, 12, 2911);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$24, 91, 12, 3007);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$24, 88, 8, 2784);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$24, 56, 6, 1404);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$24, 51, 5, 1221);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$24, 50, 1, 1187);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			mount_component(solution, div5, null);
    			append_dev(div5, t12);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t14);
    			append_dev(div4, button1);
    			append_dev(div4, t16);
    			append_dev(div4, button2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[7]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*task01*/ 1) && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*task01*/ 1) && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1H(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1H(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if ((!current || dirty & /*task01*/ 1) && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (!current || dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (!current || dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}

    			const solution_changes = {};
    			if (dirty & /*task01*/ 1) solution_changes.num_qnty = /*task01*/ ctx[0].columns;
    			if (dirty & /*answer*/ 2) solution_changes.usr_resp = /*answer*/ ctx[1];
    			if (dirty & /*task01*/ 1) solution_changes.num = /*task01*/ ctx[0].valueArray;
    			if (dirty & /*showSolution*/ 16) solution_changes.ans_submit = /*showSolution*/ ctx[4];
    			solution.$set(solution_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			destroy_component(solution);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$25.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const max$x = 999;
    const min$x = 100;
    const numberofColumn$v = 2;

    function instance$25($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GIII_MA_C1", slots, []);
    	let heading = "Add two numbers up to three digits";
    	let question = "Add :";
    	let maxandmin = MaxandMin$5(max$x, min$x, numberofColumn$v, heading, question);
    	let task01 = taskOne$1C();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			$$invalidate(4, showSolution = true);
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$1C());
    		$$invalidate(4, showSolution = false);
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GIII_MA_C1> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1C,
    		randomCorrect,
    		randomWrong,
    		MaxandMin: MaxandMin$5,
    		Solution: AdditionSolution,
    		heading,
    		question,
    		max: max$x,
    		min: min$x,
    		numberofColumn: numberofColumn$v,
    		maxandmin,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("heading" in $$props) heading = $$props.heading;
    		if ("question" in $$props) question = $$props.question;
    		if ("maxandmin" in $$props) maxandmin = $$props.maxandmin;
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) $$invalidate(4, showSolution = $$props.showSolution);
    		if ("CheckAnswer" in $$props) $$invalidate(5, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(6, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class GIII_MA_C1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$25, create_fragment$25, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GIII_MA_C1",
    			options,
    			id: create_fragment$25.name
    		});
    	}
    }

    /* src/components/taskComponents/GII_MA_E5.svelte generated by Svelte v3.37.0 */
    const file$23 = "src/components/taskComponents/GII_MA_E5.svelte";

    function get_each_context$1G(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	child_ctx[13] = i;
    	return child_ctx;
    }

    // (72:28) {:else}
    function create_else_block$1f(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[11] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$23, 73, 32, 2037);
    			add_location(tr, file$23, 72, 28, 2000);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[11] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1f.name,
    		type: "else",
    		source: "(72:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (68:28) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$1l(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[11] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$23, 69, 50, 1833);
    			attr_dev(td, "align", "right");
    			add_location(td, file$23, 69, 32, 1815);
    			add_location(tr, file$23, 68, 28, 1778);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[11] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1l.name,
    		type: "if",
    		source: "(68:28) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (67:24) {#each task01.valueArray as col, i }
    function create_each_block$1G(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[13] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$1l;
    		return create_else_block$1f;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1G.name,
    		type: "each",
    		source: "(67:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$24(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let solution;
    	let t12;
    	let div4;
    	let button0;
    	let t14;
    	let button1;
    	let t16;
    	let button2;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1G(get_each_context$1G(ctx, each_value, i));
    	}

    	solution = new AdditionSolution({
    			props: {
    				num_qnty: /*task01*/ ctx[0].columns,
    				usr_resp: /*answer*/ ctx[1],
    				num: /*task01*/ ctx[0].valueArray,
    				ans_submit: /*showSolution*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			create_component(solution.$$.fragment);
    			t12 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t14 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t16 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$23, 53, 10, 1303);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$23, 52, 6, 1253);
    			add_location(h4, file$23, 60, 12, 1481);
    			attr_dev(table, "width", "100");
    			add_location(table, file$23, 64, 16, 1553);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$23, 78, 20, 2230);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$23, 79, 20, 2325);
    			add_location(h6, file$23, 80, 20, 2447);
    			add_location(div1, file$23, 62, 12, 1526);
    			add_location(div2, file$23, 57, 8, 1460);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$23, 85, 12, 2555);
    			add_location(div3, file$23, 84, 8, 2537);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$23, 89, 12, 2799);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$23, 90, 12, 2895);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$23, 91, 12, 2991);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$23, 88, 8, 2768);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$23, 56, 6, 1388);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$23, 51, 5, 1205);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$23, 50, 1, 1171);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			mount_component(solution, div5, null);
    			append_dev(div5, t12);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t14);
    			append_dev(div4, button1);
    			append_dev(div4, t16);
    			append_dev(div4, button2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[7]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*task01*/ 1) && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*task01*/ 1) && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1G(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1G(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if ((!current || dirty & /*task01*/ 1) && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (!current || dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (!current || dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}

    			const solution_changes = {};
    			if (dirty & /*task01*/ 1) solution_changes.num_qnty = /*task01*/ ctx[0].columns;
    			if (dirty & /*answer*/ 2) solution_changes.usr_resp = /*answer*/ ctx[1];
    			if (dirty & /*task01*/ 1) solution_changes.num = /*task01*/ ctx[0].valueArray;
    			if (dirty & /*showSolution*/ 16) solution_changes.ans_submit = /*showSolution*/ ctx[4];
    			solution.$set(solution_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			destroy_component(solution);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$24.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const max$w = 10;
    const min$w = 0;
    const numberofColumn$u = 2;

    function instance$24($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GII_MA_E5", slots, []);
    	let heading = "Add one-digit numbers";
    	let question = "Add :";
    	let maxandmin = MaxandMin$5(max$w, min$w, numberofColumn$u, heading, question);
    	let task01 = taskOne$1C();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			$$invalidate(4, showSolution = true);
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$1C());
    		$$invalidate(4, showSolution = false);
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GII_MA_E5> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1C,
    		randomCorrect,
    		randomWrong,
    		MaxandMin: MaxandMin$5,
    		Solution: AdditionSolution,
    		heading,
    		question,
    		max: max$w,
    		min: min$w,
    		numberofColumn: numberofColumn$u,
    		maxandmin,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("heading" in $$props) heading = $$props.heading;
    		if ("question" in $$props) question = $$props.question;
    		if ("maxandmin" in $$props) maxandmin = $$props.maxandmin;
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) $$invalidate(4, showSolution = $$props.showSolution);
    		if ("CheckAnswer" in $$props) $$invalidate(5, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(6, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class GII_MA_E5 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$24, create_fragment$24, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GII_MA_E5",
    			options,
    			id: create_fragment$24.name
    		});
    	}
    }

    let task01$1B = {
      heading : "",
      question: "",
      valueArray: [], 
      answer: 0, 
      operator: "+",
      columns: 0
    };

    let columns$i = 2;
    let maxValue$1c = 9999;
    let minValue$1c = 1000;


    function taskOne$1B() {
      task01$1B.heading = "Add numbers up to five digits: word problems";
      task01$1B.answer = 0;
      task01$1B.columns = columns$i;
      task01$1B.valueArray = [];
          for (let i = 0; i < columns$i; i++) {
            task01$1B.valueArray[i] = Math.floor(Math.random() * (maxValue$1c - minValue$1c + 1) ) + minValue$1c; 
            task01$1B.answer += task01$1B.valueArray[i];        
          }
            while(task01$1B.answer > maxValue$1c){
                task01$1B.answer = 0;
            for (let i = 0; i < columns$i; i++) {
                task01$1B.valueArray[i] = Math.floor(Math.random() * (maxValue$1c - minValue$1c + 1) ) + minValue$1c; 
                task01$1B.answer += task01$1B.valueArray[i];        
            }
            }
      task01$1B.question = "A car company produced  "+task01$1B.valueArray[0]+" cars in North America and "+task01$1B.valueArray[1]+" cars in Europe. How many cars is that in all?";
      return task01$1B;
    }

    /* src/components/taskComponents/GIV_MA_B2.svelte generated by Svelte v3.37.0 */
    const file$22 = "src/components/taskComponents/GIV_MA_B2.svelte";

    function create_fragment$23(ctx) {
    	let div6;
    	let div5;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div4;
    	let div1;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let input;
    	let t4;
    	let div2;
    	let h5;
    	let t5;
    	let t6;
    	let solution;
    	let t7;
    	let div3;
    	let button0;
    	let t9;
    	let button1;
    	let t11;
    	let button2;
    	let current;
    	let mounted;
    	let dispose;

    	solution = new AdditionSolution({
    			props: {
    				num_qnty: /*task01*/ ctx[0].columns,
    				usr_resp: /*answer*/ ctx[1],
    				num: /*task01*/ ctx[0].valueArray,
    				ans_submit: /*showSolution*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div6 = element("div");
    			div5 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div4 = element("div");
    			div1 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			input = element("input");
    			t4 = space();
    			div2 = element("div");
    			h5 = element("h5");
    			t5 = text(/*showPopUp*/ ctx[3]);
    			t6 = space();
    			create_component(solution.$$.fragment);
    			t7 = space();
    			div3 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t9 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t11 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$22, 51, 9, 1074);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$22, 50, 5, 1025);
    			add_location(h4, file$22, 57, 11, 1246);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$22, 58, 11, 1284);
    			add_location(div1, file$22, 55, 7, 1227);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$22, 62, 11, 1426);
    			add_location(div2, file$22, 61, 7, 1409);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$22, 66, 11, 1666);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$22, 67, 11, 1761);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$22, 68, 11, 1856);
    			attr_dev(div3, "class", "mt-3");
    			add_location(div3, file$22, 65, 7, 1636);
    			attr_dev(div4, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div4, file$22, 54, 5, 1156);
    			attr_dev(div5, "class", "shadow-sm  bg-white rounded");
    			add_location(div5, file$22, 49, 4, 978);
    			attr_dev(div6, "class", "container mt-5");
    			add_location(div6, file$22, 48, 1, 945);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div5);
    			append_dev(div5, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div5, t1);
    			append_dev(div5, div4);
    			append_dev(div4, div1);
    			append_dev(div1, h4);
    			append_dev(h4, t2);
    			append_dev(div1, t3);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div4, t4);
    			append_dev(div4, div2);
    			append_dev(div2, h5);
    			append_dev(h5, t5);
    			append_dev(div4, t6);
    			mount_component(solution, div4, null);
    			append_dev(div4, t7);
    			append_dev(div4, div3);
    			append_dev(div3, button0);
    			append_dev(div3, t9);
    			append_dev(div3, button1);
    			append_dev(div3, t11);
    			append_dev(div3, button2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[7]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*task01*/ 1) && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*task01*/ 1) && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (!current || dirty & /*showPopUp*/ 8) set_data_dev(t5, /*showPopUp*/ ctx[3]);

    			if (!current || dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}

    			const solution_changes = {};
    			if (dirty & /*task01*/ 1) solution_changes.num_qnty = /*task01*/ ctx[0].columns;
    			if (dirty & /*answer*/ 2) solution_changes.usr_resp = /*answer*/ ctx[1];
    			if (dirty & /*task01*/ 1) solution_changes.num = /*task01*/ ctx[0].valueArray;
    			if (dirty & /*showSolution*/ 16) solution_changes.ans_submit = /*showSolution*/ ctx[4];
    			solution.$set(solution_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div6);
    			destroy_component(solution);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$23.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$23($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GIV_MA_B2", slots, []);
    	let task01 = taskOne$1B();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			$$invalidate(2, showNext = "inline-block");
    			return;
    		} else {
    			$$invalidate(4, showSolution = true);
    			$$invalidate(3, showPopUp = randomWrong());
    			$$invalidate(2, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(4, showSolution = false);
    		$$invalidate(0, task01 = taskOne$1B());
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GIV_MA_B2> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1B,
    		randomCorrect,
    		randomWrong,
    		Solution: AdditionSolution,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) $$invalidate(4, showSolution = $$props.showSolution);
    		if ("CheckAnswer" in $$props) $$invalidate(5, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(6, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class GIV_MA_B2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$23, create_fragment$23, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GIV_MA_B2",
    			options,
    			id: create_fragment$23.name
    		});
    	}
    }

    const shapeArray = [
        {s_Id:"s_0",  sides:4, s_type:"closed" , s_name:"Square",    img_src:"images/shapes/box_with_red_square.png"},
        {s_Id:"s_1",  sides:4, s_type:"closed" , s_name:"Square",    img_src:"images/shapes/box_with_blue_square.png"},
        {s_Id:"s_2",  sides:4, s_type:"closed" , s_name:"Square",    img_src:"images/shapes/box_with_green_square.png"},
        {s_Id:"s_3",  sides:4, s_type:"closed" , s_name:"Square",    img_src:"images/shapes/box_with_yellow_square.png"},
        {s_Id:"s_4",  sides:4, s_type:"closed" , s_name:"Square",    img_src:"images/shapes/box_with_pink_square.png"},
        {s_Id:"s_5",  sides:4, s_type:"closed" , s_name:"Square",    img_src:"images/shapes/box_with_white_square.png"},
        {s_Id:"s_6",  sides:4, s_type:"closed" , s_name:"Square",    img_src:"images/shapes/box_with_black_square.png"},
        {s_Id:"s_7",  sides:3, s_type:"closed" , s_name:"Triangle",  img_src:"images/shapes/box_with_red_triangle.png"},
        {s_Id:"s_8",  sides:3, s_type:"closed" , s_name:"Triangle",  img_src:"images/shapes/box_with_blue_triangle.png"},
        {s_Id:"s_9",  sides:3, s_type:"closed" , s_name:"Triangle",  img_src:"images/shapes/box_with_green_triangle.png"},
        {s_Id:"s_10", sides:3, s_type:"closed" , s_name:"Triangle",  img_src:"images/shapes/box_with_yellow_triangle.png"},
        {s_Id:"s_11", sides:3, s_type:"closed" , s_name:"Triangle",  img_src:"images/shapes/box_with_pink_triangle.png"},
        {s_Id:"s_12", sides:3, s_type:"closed" , s_name:"Triangle",  img_src:"images/shapes/box_with_white_triangle.png"},
        {s_Id:"s_13", sides:3, s_type:"closed" , s_name:"Triangle",  img_src:"images/shapes/box_with_black_triangle.png"},
        {s_Id:"s_14", sides:4, s_type:"open"   , s_name:"Rectangle", img_src:"images/shapes/box_with_red_rectangle.png"},
        {s_Id:"s_15", sides:4, s_type:"open"   , s_name:"Rectangle", img_src:"images/shapes/box_with_blue_rectangle.png"},
        {s_Id:"s_16", sides:4, s_type:"open"   , s_name:"Rectangle", img_src:"images/shapes/box_with_green_rectangle.png"},
        {s_Id:"s_17", sides:4, s_type:"open"   , s_name:"Rectangle", img_src:"images/shapes/box_with_yellow_rectangle.png"},
        {s_Id:"s_18", sides:4, s_type:"open"   , s_name:"Rectangle", img_src:"images/shapes/box_with_pink_rectangle.png"},
        {s_Id:"s_19", sides:4, s_type:"open"   , s_name:"Rectangle", img_src:"images/shapes/box_with_white_rectangle.png"},
        {s_Id:"s_20", sides:4, s_type:"open"   , s_name:"Rectangle", img_src:"images/shapes/box_with_black_rectangle.png"},
        {s_Id:"s_21", sides:9, s_type:"open"   , s_name:"Circle",    img_src:"images/shapes/box_with_red_circle.png"},
        {s_Id:"s_22", sides:9, s_type:"open"   , s_name:"Circle",    img_src:"images/shapes/box_with_blue_circle.png"},
        {s_Id:"s_23", sides:9, s_type:"open"   , s_name:"Circle",    img_src:"images/shapes/box_with_green_circle.png"},
        {s_Id:"s_24", sides:9, s_type:"open"   , s_name:"Circle",    img_src:"images/shapes/box_with_yellow_circle.png"},
        {s_Id:"s_25", sides:9, s_type:"open"   , s_name:"Circle",    img_src:"images/shapes/box_with_pink_circle.png"},
        {s_Id:"s_26", sides:9, s_type:"open"   , s_name:"Circle",    img_src:"images/shapes/box_with_white_circle.png"},
        {s_Id:"s_27", sides:9, s_type:"open"   , s_name:"Circle",    img_src:"images/shapes/box_with_black_circle.png"}
    ];

    const shapeArray_for_M7 = [
        {sImg_name:"clothes_handbag",symmetric: true,img_src:"images/img/lic_ok/clothes_handbag.jpg"},
        {sImg_name:"furn_table",symmetric: true,img_src:"images/img/lic_ok/furn_table.jpg"},
        {sImg_name:"star",symmetric: true,img_src:"images/img/star.jpg"},
        {sImg_name:"butterfly",symmetric: true,img_src:"images/img/butterfly.png"},
        {sImg_name:"bird1",symmetric: false ,img_src:"images/img/lic_ok/bird1.PNG"},
        {sImg_name:"camel",symmetric: false ,img_src:"images/img/lic_ok/camel.PNG"},
        {sImg_name:"turtle",symmetric: false ,img_src:"images/img/lic_ok/turtle.PNG"},
        {sImg_name:"tiger",symmetric: false ,img_src:"images/img/lic_ok/tiger.PNG"},

    ];

    /* src/components/taskComponents/G1_MD_M1.svelte generated by Svelte v3.37.0 */

    const { console: console_1$8 } = globals;
    const file$21 = "src/components/taskComponents/G1_MD_M1.svelte";

    function get_each_context$1F(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[14] = list[i];
    	child_ctx[16] = i;
    	return child_ctx;
    }

    // (100:6) {#each selectionArray as item,i}
    function create_each_block$1F(ctx) {
    	let input;
    	let input_value_value;
    	let t;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[8](/*item*/ ctx[14]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			t = text("");
    			attr_dev(input, "type", "button");
    			input.value = input_value_value = /*item*/ ctx[14].s_opt;
    			add_location(input, file$21, 100, 10, 2913);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			insert_dev(target, t, anchor);

    			if (!mounted) {
    				dispose = listen_dev(input, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*selectionArray*/ 16 && input_value_value !== (input_value_value = /*item*/ ctx[14].s_opt)) {
    				prop_dev(input, "value", input_value_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			if (detaching) detach_dev(t);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1F.name,
    		type: "each",
    		source: "(100:6) {#each selectionArray as item,i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$22(ctx) {
    	let div3;
    	let h4;
    	let t1;
    	let h50;
    	let t3;
    	let div0;
    	let label;
    	let img;
    	let img_src_value;
    	let t4;
    	let div1;
    	let t5;
    	let br;
    	let t6;
    	let h51;
    	let t7;
    	let t8;
    	let div2;
    	let button0;
    	let t10;
    	let button1;
    	let t12;
    	let p;
    	let t13;
    	let t14;
    	let mounted;
    	let dispose;
    	let each_value = /*selectionArray*/ ctx[4];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1F(get_each_context$1F(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			h4 = element("h4");
    			h4.textContent = "Two-Dimensional Shapes";
    			t1 = space();
    			h50 = element("h5");
    			h50.textContent = "Name the two-dimensional shape";
    			t3 = space();
    			div0 = element("div");
    			label = element("label");
    			img = element("img");
    			t4 = space();
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t5 = space();
    			br = element("br");
    			t6 = space();
    			h51 = element("h5");
    			t7 = text(/*showPopUp*/ ctx[2]);
    			t8 = space();
    			div2 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t10 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t12 = space();
    			p = element("p");
    			t13 = text("the correct answer is ");
    			t14 = text(/*c_Ans*/ ctx[3]);
    			add_location(h4, file$21, 90, 2, 2663);
    			add_location(h50, file$21, 91, 2, 2697);
    			if (img.src !== (img_src_value = /*ques_Img*/ ctx[0])) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			attr_dev(img, "width", "30%");
    			attr_dev(img, "class", "svelte-1o0wq9r");
    			add_location(img, file$21, 94, 6, 2787);
    			attr_dev(label, "for", "myck");
    			add_location(label, file$21, 93, 4, 2762);
    			attr_dev(div0, "class", "myck");
    			add_location(div0, file$21, 92, 2, 2739);
    			add_location(div1, file$21, 97, 2, 2853);
    			add_location(br, file$21, 105, 2, 3048);
    			set_style(h51, "display", /*showNext*/ ctx[1]);
    			attr_dev(h51, "class", "mt-5");
    			add_location(h51, file$21, 106, 2, 3055);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn rerun");
    			add_location(button0, file$21, 109, 4, 3134);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn rerun");
    			add_location(button1, file$21, 112, 4, 3234);
    			add_location(div2, file$21, 108, 2, 3124);
    			add_location(p, file$21, 116, 2, 3340);
    			add_location(div3, file$21, 89, 0, 2655);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, h4);
    			append_dev(div3, t1);
    			append_dev(div3, h50);
    			append_dev(div3, t3);
    			append_dev(div3, div0);
    			append_dev(div0, label);
    			append_dev(label, img);
    			append_dev(div3, t4);
    			append_dev(div3, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			append_dev(div3, t5);
    			append_dev(div3, br);
    			append_dev(div3, t6);
    			append_dev(div3, h51);
    			append_dev(h51, t7);
    			append_dev(div3, t8);
    			append_dev(div3, div2);
    			append_dev(div2, button0);
    			append_dev(div2, t10);
    			append_dev(div2, button1);
    			append_dev(div3, t12);
    			append_dev(div3, p);
    			append_dev(p, t13);
    			append_dev(p, t14);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler_1*/ ctx[9], false, false, false),
    					listen_dev(button1, "click", /*click_handler_2*/ ctx[10], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*ques_Img*/ 1 && img.src !== (img_src_value = /*ques_Img*/ ctx[0])) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*selectionArray, assign_resp*/ 80) {
    				each_value = /*selectionArray*/ ctx[4];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1F(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1F(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*showPopUp*/ 4) set_data_dev(t7, /*showPopUp*/ ctx[2]);

    			if (dirty & /*showNext*/ 2) {
    				set_style(h51, "display", /*showNext*/ ctx[1]);
    			}

    			if (dirty & /*c_Ans*/ 8) set_data_dev(t14, /*c_Ans*/ ctx[3]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$22.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$22($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MD_M1", slots, []);
    	let ques_Img = "";
    	let rn_for_US = [];
    	let user_resp = "";
    	let showNext = "none";
    	let showPopUp;
    	let c_Ans = "";
    	let selectionArray = [{ s_opt: "" }, { s_opt: "" }, { s_opt: "" }];
    	let sArray = shapeArray;

    	function initImgs() {
    		$$invalidate(3, c_Ans = null);

    		//question image is generated by generating a random value and assigning a correct value to check the result
    		let ques_rIn = Math.floor(Math.random() * sArray.length);

    		$$invalidate(0, ques_Img = sArray[ques_rIn].img_src);
    		$$invalidate(3, c_Ans = sArray[ques_rIn].s_name);
    		console.log("inside init", { ques_Img });
    		console.log("inside init", { c_Ans });

    		//generation of user choices
    		for (let i = 0; i < selectionArray.length; i++) {
    			if (rn_for_US[i + 2] == rn_for_US[i]) {
    				rn_for_US[i] = Math.floor(Math.random() * sArray.length);
    				$$invalidate(4, selectionArray[i].s_opt = sArray[rn_for_US[i]].s_name, selectionArray);
    				console.log("generated options are", rn_for_US[i]);
    			} else if (rn_for_US[i] == rn_for_US[i + 1]) {
    				rn_for_US[i] = Math.floor(Math.random() * sArray.length); //console.log('generated options are',selectionArray[i].s_opt)
    				$$invalidate(4, selectionArray[i].s_opt = sArray[rn_for_US[i]].s_name, selectionArray);
    				console.log("generated options are", selectionArray[i].s_opt);
    			}
    		}

    		//checking if the correct choice is present in the user selection
    		let crt_choice_present = 0;

    		for (let i = 0; i < selectionArray.length; i++) {
    			if (selectionArray[i].s_opt == c_Ans) {
    				crt_choice_present++;
    			}
    		}

    		//if the correct choice is not present in the user choices then it is displayed
    		if (crt_choice_present == 0) {
    			console.log("crt opt not displayed");
    			let rn1 = Math.floor(Math.random() * selectionArray.length);
    			$$invalidate(4, selectionArray[rn1].s_opt = c_Ans, selectionArray);
    		}

    		//incase of recurrance in user choices
    		for (let i = 0; i < selectionArray.length; i++) {
    			if (rn_for_US[i] == rn_for_US[i + 1]) {
    				rn_for_US[i + 1] = Math.floor(Math.random() * sArray.length);
    			}
    		}

    		$$invalidate(2, showPopUp = null);
    		$$invalidate(1, showNext = "none");
    	} //console.log("hi");

    	initImgs();

    	function assign_resp(p_Ans) {
    		user_resp = p_Ans;
    	}

    	function checkAns() {
    		console.log("inside result");
    		console.log("inside result", { user_resp });
    		console.log("inside result", { c_Ans });
    		$$invalidate(1, showNext = "inline-block");

    		if (user_resp == c_Ans) {
    			$$invalidate(2, showPopUp = randomCorrect());
    			return;
    		} else {
    			$$invalidate(2, showPopUp = randomWrong());
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$8.warn(`<G1_MD_M1> was created with unknown prop '${key}'`);
    	});

    	const click_handler = item => assign_resp(item.s_opt);
    	const click_handler_1 = () => checkAns();
    	const click_handler_2 = () => initImgs();

    	$$self.$capture_state = () => ({
    		shapeArray,
    		randomCorrect,
    		randomWrong,
    		ques_Img,
    		rn_for_US,
    		user_resp,
    		showNext,
    		showPopUp,
    		c_Ans,
    		selectionArray,
    		sArray,
    		initImgs,
    		assign_resp,
    		checkAns
    	});

    	$$self.$inject_state = $$props => {
    		if ("ques_Img" in $$props) $$invalidate(0, ques_Img = $$props.ques_Img);
    		if ("rn_for_US" in $$props) rn_for_US = $$props.rn_for_US;
    		if ("user_resp" in $$props) user_resp = $$props.user_resp;
    		if ("showNext" in $$props) $$invalidate(1, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(2, showPopUp = $$props.showPopUp);
    		if ("c_Ans" in $$props) $$invalidate(3, c_Ans = $$props.c_Ans);
    		if ("selectionArray" in $$props) $$invalidate(4, selectionArray = $$props.selectionArray);
    		if ("sArray" in $$props) sArray = $$props.sArray;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		ques_Img,
    		showNext,
    		showPopUp,
    		c_Ans,
    		selectionArray,
    		initImgs,
    		assign_resp,
    		checkAns,
    		click_handler,
    		click_handler_1,
    		click_handler_2
    	];
    }

    class G1_MD_M1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$22, create_fragment$22, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MD_M1",
    			options,
    			id: create_fragment$22.name
    		});
    	}
    }

    /* src/components/taskComponents/G1_MD_M2.svelte generated by Svelte v3.37.0 */

    const { console: console_1$7 } = globals;
    const file$20 = "src/components/taskComponents/G1_MD_M2.svelte";

    function get_each_context$1E(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[12] = list[i];
    	child_ctx[14] = i;
    	return child_ctx;
    }

    function get_each_context_1$w(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[12] = list[i];
    	child_ctx[15] = list;
    	child_ctx[14] = i;
    	return child_ctx;
    }

    // (111:6) {#each  selectionArray as item,i }
    function create_each_block_1$w(ctx) {
    	let li;
    	let input;
    	let t0;
    	let label;
    	let img;
    	let img_src_value;
    	let img_alt_value;
    	let t1;
    	let p;
    	let t2_value = /*item*/ ctx[12].s_opt + "";
    	let t2;
    	let mounted;
    	let dispose;

    	function input_change_handler() {
    		/*input_change_handler*/ ctx[8].call(input, /*each_value_1*/ ctx[15], /*i*/ ctx[14]);
    	}

    	const block = {
    		c: function create() {
    			li = element("li");
    			input = element("input");
    			t0 = space();
    			label = element("label");
    			img = element("img");
    			t1 = space();
    			p = element("p");
    			t2 = text(t2_value);
    			attr_dev(input, "type", "checkbox");
    			attr_dev(input, "id", "check" + /*i*/ ctx[14]);
    			attr_dev(input, "class", "svelte-1rfg64");
    			add_location(input, file$20, 112, 10, 4097);
    			if (img.src !== (img_src_value = /*item*/ ctx[12].s_img)) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", img_alt_value = /*item*/ ctx[12].s_opt);
    			attr_dev(img, "class", "svelte-1rfg64");
    			add_location(img, file$20, 114, 12, 4216);
    			add_location(p, file$20, 115, 12, 4270);
    			attr_dev(label, "for", "check" + /*i*/ ctx[14]);
    			attr_dev(label, "class", "svelte-1rfg64");
    			add_location(label, file$20, 113, 10, 4178);
    			attr_dev(li, "class", "svelte-1rfg64");
    			add_location(li, file$20, 111, 8, 4082);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, input);
    			input.checked = /*item*/ ctx[12].s_Status;
    			append_dev(li, t0);
    			append_dev(li, label);
    			append_dev(label, img);
    			append_dev(label, t1);
    			append_dev(label, p);
    			append_dev(p, t2);

    			if (!mounted) {
    				dispose = listen_dev(input, "change", input_change_handler);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*selectionArray*/ 8) {
    				input.checked = /*item*/ ctx[12].s_Status;
    			}

    			if (dirty & /*selectionArray*/ 8 && img.src !== (img_src_value = /*item*/ ctx[12].s_img)) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*selectionArray*/ 8 && img_alt_value !== (img_alt_value = /*item*/ ctx[12].s_opt)) {
    				attr_dev(img, "alt", img_alt_value);
    			}

    			if (dirty & /*selectionArray*/ 8 && t2_value !== (t2_value = /*item*/ ctx[12].s_opt + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$w.name,
    		type: "each",
    		source: "(111:6) {#each  selectionArray as item,i }",
    		ctx
    	});

    	return block;
    }

    // (123:8) {:else}
    function create_else_block$1e(ctx) {
    	let p;
    	let t_value = /*selectionArray*/ ctx[3][/*i*/ ctx[14]].s_Status + "";
    	let t;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t = text(t_value);
    			add_location(p, file$20, 123, 10, 4477);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*selectionArray*/ 8 && t_value !== (t_value = /*selectionArray*/ ctx[3][/*i*/ ctx[14]].s_Status + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1e.name,
    		type: "else",
    		source: "(123:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (121:8) {#if item.s_Status}
    function create_if_block$1k(ctx) {
    	let p;
    	let t_value = /*selectionArray*/ ctx[3][/*i*/ ctx[14]].s_Status + "";
    	let t;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t = text(t_value);
    			add_location(p, file$20, 121, 10, 4415);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*selectionArray*/ 8 && t_value !== (t_value = /*selectionArray*/ ctx[3][/*i*/ ctx[14]].s_Status + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1k.name,
    		type: "if",
    		source: "(121:8) {#if item.s_Status}",
    		ctx
    	});

    	return block;
    }

    // (120:6) {#each selectionArray as item,i }
    function create_each_block$1E(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*item*/ ctx[12].s_Status) return create_if_block$1k;
    		return create_else_block$1e;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1E.name,
    		type: "each",
    		source: "(120:6) {#each selectionArray as item,i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$21(ctx) {
    	let div2;
    	let h4;
    	let t1;
    	let h50;
    	let t2;
    	let t3_value = /*ques_Shape*/ ctx[5][/*qrn_In*/ ctx[2]] + "s" + "";
    	let t3;
    	let t4;
    	let div0;
    	let ul;
    	let t5;
    	let t6;
    	let br;
    	let t7;
    	let h51;
    	let t8;
    	let t9;
    	let div1;
    	let button0;
    	let t11;
    	let button1;
    	let t13;
    	let p;
    	let t14;
    	let t15;
    	let mounted;
    	let dispose;
    	let each_value_1 = /*selectionArray*/ ctx[3];
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1$w(get_each_context_1$w(ctx, each_value_1, i));
    	}

    	let each_value = /*selectionArray*/ ctx[3];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1E(get_each_context$1E(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			h4 = element("h4");
    			h4.textContent = "Two-Dimensional Shapes";
    			t1 = space();
    			h50 = element("h5");
    			t2 = text("Which shape has ");
    			t3 = text(t3_value);
    			t4 = space();
    			div0 = element("div");
    			ul = element("ul");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t5 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t6 = space();
    			br = element("br");
    			t7 = space();
    			h51 = element("h5");
    			t8 = text(/*showPopUp*/ ctx[1]);
    			t9 = space();
    			div1 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t11 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t13 = space();
    			p = element("p");
    			t14 = text("the user resp is ");
    			t15 = text(/*cAns_cnt*/ ctx[4]);
    			add_location(h4, file$20, 106, 2, 3930);
    			add_location(h50, file$20, 107, 2, 3964);
    			attr_dev(ul, "class", "svelte-1rfg64");
    			add_location(ul, file$20, 109, 4, 4028);
    			attr_dev(div0, "class", "svelte-1rfg64");
    			add_location(div0, file$20, 108, 2, 4018);
    			add_location(br, file$20, 129, 2, 4569);
    			set_style(h51, "display", /*showNext*/ ctx[0]);
    			attr_dev(h51, "class", "mt-5");
    			add_location(h51, file$20, 130, 2, 4578);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn rerun");
    			add_location(button0, file$20, 132, 4, 4654);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn rerun");
    			add_location(button1, file$20, 135, 4, 4744);
    			add_location(p, file$20, 138, 4, 4835);
    			add_location(div1, file$20, 131, 2, 4644);
    			attr_dev(div2, "class", "svelte-1rfg64");
    			add_location(div2, file$20, 105, 0, 3922);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, h4);
    			append_dev(div2, t1);
    			append_dev(div2, h50);
    			append_dev(h50, t2);
    			append_dev(h50, t3);
    			append_dev(div2, t4);
    			append_dev(div2, div0);
    			append_dev(div0, ul);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(ul, null);
    			}

    			append_dev(ul, t5);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			append_dev(div2, t6);
    			append_dev(div2, br);
    			append_dev(div2, t7);
    			append_dev(div2, h51);
    			append_dev(h51, t8);
    			append_dev(div2, t9);
    			append_dev(div2, div1);
    			append_dev(div1, button0);
    			append_dev(div1, t11);
    			append_dev(div1, button1);
    			append_dev(div1, t13);
    			append_dev(div1, p);
    			append_dev(p, t14);
    			append_dev(p, t15);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*result*/ ctx[7], false, false, false),
    					listen_dev(button1, "click", /*initImgs*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*qrn_In*/ 4 && t3_value !== (t3_value = /*ques_Shape*/ ctx[5][/*qrn_In*/ ctx[2]] + "s" + "")) set_data_dev(t3, t3_value);

    			if (dirty & /*selectionArray*/ 8) {
    				each_value_1 = /*selectionArray*/ ctx[3];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$w(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_1$w(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(ul, t5);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_1.length;
    			}

    			if (dirty & /*selectionArray*/ 8) {
    				each_value = /*selectionArray*/ ctx[3];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1E(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1E(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*showPopUp*/ 2) set_data_dev(t8, /*showPopUp*/ ctx[1]);

    			if (dirty & /*showNext*/ 1) {
    				set_style(h51, "display", /*showNext*/ ctx[0]);
    			}

    			if (dirty & /*cAns_cnt*/ 16) set_data_dev(t15, /*cAns_cnt*/ ctx[4]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$21.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$21($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MD_M2", slots, []);
    	let showNext = "none";
    	let showPopUp;
    	let ques_Shape = ["Square", "Triangle", "Rectangle", "Circle"];
    	let qrn_In = 0;
    	let rn_for_US = [];

    	let selectionArray = [
    		{
    			s_opt: "",
    			s_img: "",
    			opt_eval: null,
    			s_Status: false
    		},
    		{
    			s_opt: "",
    			s_img: "",
    			opt_eval: null,
    			s_Status: false
    		},
    		{
    			s_opt: "",
    			s_img: "",
    			opt_eval: null,
    			s_Status: false
    		},
    		{
    			s_opt: "",
    			s_img: "",
    			opt_eval: null,
    			s_Status: false
    		}
    	];

    	let sArray = shapeArray;
    	let cAns_cnt = 0;
    	let user_resp_cnt = 0;

    	function initImgs() {
    		user_resp_cnt = 0;
    		$$invalidate(4, cAns_cnt = 0);

    		// random shape identified
    		$$invalidate(2, qrn_In = Math.floor(Math.random() * ques_Shape.length));

    		//making the the false null for every reinitialization
    		//randomly fill 4 choices for user to select
    		for (let i = 0; i < selectionArray.length; i++) {
    			rn_for_US[i] = Math.floor(Math.random() * sArray.length);
    			$$invalidate(3, selectionArray[i].s_img = sArray[rn_for_US[i]].img_src, selectionArray);
    			$$invalidate(3, selectionArray[i].s_opt = sArray[rn_for_US[i]].s_name, selectionArray);
    		}

    		

    		//check to see if the question shape is present in user selection
    		// if not, it must be added
    		let shp_present_cnt = 0;

    		for (let i = 0; i < selectionArray.length; i++) {
    			if (selectionArray[i].s_name == ques_Shape[qrn_In]) {
    				shp_present_cnt++;
    			}

    			
    		}

    		

    		// answer not found in selection   
    		if (shp_present_cnt == 0) {
    			//console.log("in shp_count",{shp_present_cnt});
    			let rn1 = Math.floor(Math.random() * selectionArray.length); //random item to be changed in selection items

    			// random item to be used as an answer from the source of shapes
    			let rn2 = Math.floor(Math.random() * sArray.filter(sItem => {
    				return sItem.s_name.includes(ques_Shape[qrn_In]);
    			}).length);

    			//console.log("length of filtered array", sArray.filter(sItem => {return sItems_name.includes(ques_Shape[qrn_In])}).length);
    			//console.log('shape present geerated random numbers',{rn},{rn2})
    			//replace one of the selections with the required answer so that user may find answer in selection
    			$$invalidate(
    				3,
    				selectionArray[rn1].s_img = sArray.filter(sItem => {
    					return sItem.s_name.includes(ques_Shape[qrn_In]);
    				})[rn2].img_src,
    				selectionArray
    			);

    			$$invalidate(
    				3,
    				selectionArray[rn1].s_opt = sArray.filter(sItem => {
    					return sItem.s_name.includes(ques_Shape[qrn_In]);
    				})[rn2].s_name,
    				selectionArray
    			);
    		}

    		$$invalidate(1, showPopUp = null);
    		$$invalidate(0, showNext = "none");
    	}

    	initImgs();

    	function result() {
    		user_resp_cnt = 0;
    		$$invalidate(4, cAns_cnt = 0);
    		console.log("inside result");

    		for (let i = 0; i < selectionArray.length; i++) {
    			//count of crt answers displayed
    			if (selectionArray[i].s_opt == ques_Shape[qrn_In]) {
    				$$invalidate(4, cAns_cnt++, cAns_cnt);
    			} //console.log("dis cnt value",cAns_cnt)

    			if (selectionArray[i].s_opt == ques_Shape[qrn_In]) {
    				if (selectionArray[i].s_Status == true) {
    					user_resp_cnt++;
    				}
    			}
    		} //  if(selectionArray[i].s_Status == true){
    		//    console.log('if checked')

    		//    if(selectionArray[i].s_opt == ques_Shape[qrn_In]){
    		//      answer = true;
    		//      console.log('if matched answer = ',{answer})
    		//    }
    		//    else{
    		//      answer = false;
    		//      console.log('wrong answer if ans =',{answer})
    		//    }
    		//  }
    		//  else if(selectionArray[i].s_Status == false){
    		//    if(selectionArray[i].s_opt == ques_Shape[qrn_In]){
    		//      answer = false;
    		//      console.log('wrong answer if ans =',{answer})
    		//    }
    		//  }
    		console.log("dis cnt value", cAns_cnt);

    		console.log("user cnt value", user_resp_cnt);
    		$$invalidate(0, showNext = "inline-block");

    		if (user_resp_cnt == cAns_cnt) {
    			$$invalidate(1, showPopUp = randomCorrect());
    			return;
    		} else {
    			$$invalidate(1, showPopUp = randomWrong());
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$7.warn(`<G1_MD_M2> was created with unknown prop '${key}'`);
    	});

    	function input_change_handler(each_value_1, i) {
    		each_value_1[i].s_Status = this.checked;
    		$$invalidate(3, selectionArray);
    	}

    	$$self.$capture_state = () => ({
    		shapeArray,
    		randomCorrect,
    		randomWrong,
    		showNext,
    		showPopUp,
    		ques_Shape,
    		qrn_In,
    		rn_for_US,
    		selectionArray,
    		sArray,
    		cAns_cnt,
    		user_resp_cnt,
    		initImgs,
    		result
    	});

    	$$self.$inject_state = $$props => {
    		if ("showNext" in $$props) $$invalidate(0, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(1, showPopUp = $$props.showPopUp);
    		if ("ques_Shape" in $$props) $$invalidate(5, ques_Shape = $$props.ques_Shape);
    		if ("qrn_In" in $$props) $$invalidate(2, qrn_In = $$props.qrn_In);
    		if ("rn_for_US" in $$props) rn_for_US = $$props.rn_for_US;
    		if ("selectionArray" in $$props) $$invalidate(3, selectionArray = $$props.selectionArray);
    		if ("sArray" in $$props) sArray = $$props.sArray;
    		if ("cAns_cnt" in $$props) $$invalidate(4, cAns_cnt = $$props.cAns_cnt);
    		if ("user_resp_cnt" in $$props) user_resp_cnt = $$props.user_resp_cnt;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		showNext,
    		showPopUp,
    		qrn_In,
    		selectionArray,
    		cAns_cnt,
    		ques_Shape,
    		initImgs,
    		result,
    		input_change_handler
    	];
    }

    class G1_MD_M2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$21, create_fragment$21, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MD_M2",
    			options,
    			id: create_fragment$21.name
    		});
    	}
    }

    /* src/components/taskComponents/G1_MD_M3.svelte generated by Svelte v3.37.0 */

    const { console: console_1$6 } = globals;
    const file$1$ = "src/components/taskComponents/G1_MD_M3.svelte";

    function create_fragment$20(ctx) {
    	let div3;
    	let h4;
    	let t1;
    	let h50;
    	let t3;
    	let div0;
    	let img;
    	let img_src_value;
    	let t4;
    	let div1;
    	let input;
    	let t5;
    	let br;
    	let t6;
    	let h51;
    	let t7;
    	let t8;
    	let div2;
    	let button0;
    	let t10;
    	let button1;
    	let t12;
    	let p;
    	let t13;
    	let t14;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			h4 = element("h4");
    			h4.textContent = "Two-Dimensional Shapes";
    			t1 = space();
    			h50 = element("h5");
    			h50.textContent = "How many sides does this Shape have ?";
    			t3 = space();
    			div0 = element("div");
    			img = element("img");
    			t4 = space();
    			div1 = element("div");
    			input = element("input");
    			t5 = space();
    			br = element("br");
    			t6 = space();
    			h51 = element("h5");
    			t7 = text(/*showPopUp*/ ctx[2]);
    			t8 = space();
    			div2 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t10 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t12 = space();
    			p = element("p");
    			t13 = text("the correct answer is ");
    			t14 = text(/*c_Ans*/ ctx[4]);
    			add_location(h4, file$1$, 52, 4, 1337);
    			add_location(h50, file$1$, 53, 4, 1373);
    			if (img.src !== (img_src_value = /*ques_Img*/ ctx[0])) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "shapes");
    			attr_dev(img, "width", "30%");
    			add_location(img, file$1$, 55, 6, 1436);
    			add_location(div0, file$1$, 54, 4, 1424);
    			attr_dev(input, "type", "number");
    			attr_dev(input, "class", "btn rnAns");
    			add_location(input, file$1$, 58, 6, 1511);
    			add_location(div1, file$1$, 57, 4, 1499);
    			add_location(br, file$1$, 60, 4, 1596);
    			set_style(h51, "display", /*showNext*/ ctx[3]);
    			attr_dev(h51, "class", "mt-5");
    			add_location(h51, file$1$, 61, 4, 1605);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1$, 74, 6, 1875);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn rerun");
    			add_location(button1, file$1$, 75, 6, 1970);
    			add_location(div2, file$1$, 73, 4, 1863);
    			add_location(p, file$1$, 77, 4, 2066);
    			add_location(div3, file$1$, 51, 2, 1327);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, h4);
    			append_dev(div3, t1);
    			append_dev(div3, h50);
    			append_dev(div3, t3);
    			append_dev(div3, div0);
    			append_dev(div0, img);
    			append_dev(div3, t4);
    			append_dev(div3, div1);
    			append_dev(div1, input);
    			set_input_value(input, /*user_resp*/ ctx[1]);
    			append_dev(div3, t5);
    			append_dev(div3, br);
    			append_dev(div3, t6);
    			append_dev(div3, h51);
    			append_dev(h51, t7);
    			append_dev(div3, t8);
    			append_dev(div3, div2);
    			append_dev(div2, button0);
    			append_dev(div2, t10);
    			append_dev(div2, button1);
    			append_dev(div3, t12);
    			append_dev(div3, p);
    			append_dev(p, t13);
    			append_dev(p, t14);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[7]),
    					listen_dev(button0, "click", /*click_handler*/ ctx[8], false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[9], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*ques_Img*/ 1 && img.src !== (img_src_value = /*ques_Img*/ ctx[0])) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*user_resp*/ 2 && to_number(input.value) !== /*user_resp*/ ctx[1]) {
    				set_input_value(input, /*user_resp*/ ctx[1]);
    			}

    			if (dirty & /*showPopUp*/ 4) set_data_dev(t7, /*showPopUp*/ ctx[2]);

    			if (dirty & /*showNext*/ 8) {
    				set_style(h51, "display", /*showNext*/ ctx[3]);
    			}

    			if (dirty & /*c_Ans*/ 16) set_data_dev(t14, /*c_Ans*/ ctx[4]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$20.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$20($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MD_M3", slots, []);
    	let ques_Img = "";
    	let rnIn = 0;
    	let user_resp = null;
    	let showPopUp;
    	let showNext = "none";
    	let c_Ans = 0;

    	let sArray = [
    		{
    			sides: 4,
    			img_src: "images/shapes/blackSquare.png"
    		},
    		{
    			sides: 4,
    			img_src: "images/shapes/blackRectangle.png"
    		},
    		{
    			sides: 3,
    			img_src: "images/shapes/blackTriangle.png"
    		},
    		{
    			sides: 6,
    			img_src: "images/shapes/blackHexagon.png"
    		},
    		{
    			sides: 8,
    			img_src: "images/shapes/blackOctagon.png"
    		},
    		{
    			sides: 5,
    			img_src: "images/shapes/blackPentagon.png"
    		}
    	];

    	function initImgs() {
    		$$invalidate(1, user_resp = null);
    		rnIn = Math.floor(Math.random() * sArray.length);
    		$$invalidate(0, ques_Img = sArray[rnIn].img_src);
    		$$invalidate(4, c_Ans = sArray[rnIn].sides);
    		$$invalidate(3, showNext = "none");

    		//def_ans = false;
    		//showPopUp = null;
    		console.log("hi");
    	}

    	initImgs();

    	function checkAns() {
    		//answer = p_Ans.value ;
    		$$invalidate(3, showNext = "inline-block");

    		if (user_resp == c_Ans) {
    			def_ans = true;
    			$$invalidate(2, showPopUp = randomCorrect());
    			return;
    		} else {
    			def_ans = true;
    			$$invalidate(2, showPopUp = randomWrong());
    		}

    		console.log(user_resp);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$6.warn(`<G1_MD_M3> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		user_resp = to_number(this.value);
    		$$invalidate(1, user_resp);
    	}

    	const click_handler = () => checkAns();
    	const click_handler_1 = () => initImgs();

    	$$self.$capture_state = () => ({
    		randomCorrect,
    		randomWrong,
    		ques_Img,
    		rnIn,
    		user_resp,
    		showPopUp,
    		showNext,
    		c_Ans,
    		sArray,
    		initImgs,
    		checkAns
    	});

    	$$self.$inject_state = $$props => {
    		if ("ques_Img" in $$props) $$invalidate(0, ques_Img = $$props.ques_Img);
    		if ("rnIn" in $$props) rnIn = $$props.rnIn;
    		if ("user_resp" in $$props) $$invalidate(1, user_resp = $$props.user_resp);
    		if ("showPopUp" in $$props) $$invalidate(2, showPopUp = $$props.showPopUp);
    		if ("showNext" in $$props) $$invalidate(3, showNext = $$props.showNext);
    		if ("c_Ans" in $$props) $$invalidate(4, c_Ans = $$props.c_Ans);
    		if ("sArray" in $$props) sArray = $$props.sArray;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		ques_Img,
    		user_resp,
    		showPopUp,
    		showNext,
    		c_Ans,
    		initImgs,
    		checkAns,
    		input_input_handler,
    		click_handler,
    		click_handler_1
    	];
    }

    class G1_MD_M3 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$20, create_fragment$20, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MD_M3",
    			options,
    			id: create_fragment$20.name
    		});
    	}
    }

    /* src/components/taskComponents/G1_MD_M4.svelte generated by Svelte v3.37.0 */
    const file$1_ = "src/components/taskComponents/G1_MD_M4.svelte";

    function get_each_context$1D(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[12] = list[i];
    	child_ctx[14] = i;
    	return child_ctx;
    }

    // (76:6) {#each  selectionArray as item, i }
    function create_each_block$1D(ctx) {
    	let li;
    	let button;
    	let label;
    	let img;
    	let img_src_value;
    	let img_alt_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			li = element("li");
    			button = element("button");
    			label = element("label");
    			img = element("img");
    			if (img.src !== (img_src_value = /*item*/ ctx[12].s_img)) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", img_alt_value = /*item*/ ctx[12].s_optVal);
    			attr_dev(img, "class", "svelte-1i87lk4");
    			add_location(img, file$1_, 79, 12, 2255);
    			attr_dev(label, "for", "check" + /*i*/ ctx[14]);
    			attr_dev(label, "class", "svelte-1i87lk4");
    			add_location(label, file$1_, 78, 10, 2217);
    			attr_dev(button, "id", "check" + /*i*/ ctx[14]);
    			attr_dev(button, "class", "svelte-1i87lk4");
    			add_location(button, file$1_, 77, 10, 2130);
    			attr_dev(li, "class", "svelte-1i87lk4");
    			add_location(li, file$1_, 76, 8, 2115);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, button);
    			append_dev(button, label);
    			append_dev(label, img);

    			if (!mounted) {
    				dispose = listen_dev(
    					button,
    					"click",
    					function () {
    						if (is_function(/*assign_resp*/ ctx[8](/*selectionArray*/ ctx[3][/*i*/ ctx[14]].s_optVal))) /*assign_resp*/ ctx[8](/*selectionArray*/ ctx[3][/*i*/ ctx[14]].s_optVal).apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*selectionArray*/ 8 && img.src !== (img_src_value = /*item*/ ctx[12].s_img)) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*selectionArray*/ 8 && img_alt_value !== (img_alt_value = /*item*/ ctx[12].s_optVal)) {
    				attr_dev(img, "alt", img_alt_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1D.name,
    		type: "each",
    		source: "(76:6) {#each  selectionArray as item, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1$(ctx) {
    	let div2;
    	let h4;
    	let t1;
    	let h50;
    	let t2;
    	let t3_value = /*ques_Array*/ ctx[6][/*qrn_In*/ ctx[2]] + "";
    	let t3;
    	let t4;
    	let t5;
    	let div0;
    	let ul;
    	let t6;
    	let p0;
    	let t7;
    	let t8;
    	let br;
    	let t9;
    	let h51;
    	let t10;
    	let t11;
    	let div1;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let p1;
    	let t16;
    	let t17;
    	let t18;
    	let p2;
    	let t19;
    	let t20;
    	let mounted;
    	let dispose;
    	let each_value = /*selectionArray*/ ctx[3];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1D(get_each_context$1D(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			h4 = element("h4");
    			h4.textContent = "Two-Dimensional Shapes";
    			t1 = space();
    			h50 = element("h5");
    			t2 = text("Which shape has ");
    			t3 = text(t3_value);
    			t4 = text(" sides");
    			t5 = space();
    			div0 = element("div");
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t6 = space();
    			p0 = element("p");
    			t7 = text(/*user_resp*/ ctx[5]);
    			t8 = space();
    			br = element("br");
    			t9 = space();
    			h51 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[1]);
    			t11 = space();
    			div1 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			p1 = element("p");
    			t16 = text("the user resp is ");
    			t17 = text(/*user_resp*/ ctx[5]);
    			t18 = space();
    			p2 = element("p");
    			t19 = text("the correct answer is ");
    			t20 = text(/*c_Ans*/ ctx[4]);
    			add_location(h4, file$1_, 71, 2, 1962);
    			add_location(h50, file$1_, 72, 2, 1996);
    			add_location(p0, file$1_, 85, 6, 2414);
    			attr_dev(ul, "class", "svelte-1i87lk4");
    			add_location(ul, file$1_, 74, 4, 2060);
    			attr_dev(div0, "class", "svelte-1i87lk4");
    			add_location(div0, file$1_, 73, 2, 2050);
    			add_location(br, file$1_, 88, 2, 2454);
    			set_style(h51, "display", /*showNext*/ ctx[0]);
    			attr_dev(h51, "class", "mt-5");
    			add_location(h51, file$1_, 89, 2, 2463);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn rerun");
    			add_location(button0, file$1_, 91, 4, 2539);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn rerun");
    			add_location(button1, file$1_, 94, 4, 2629);
    			add_location(p1, file$1_, 97, 4, 2720);
    			add_location(p2, file$1_, 98, 4, 2760);
    			add_location(div1, file$1_, 90, 2, 2529);
    			attr_dev(div2, "class", "svelte-1i87lk4");
    			add_location(div2, file$1_, 70, 0, 1954);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, h4);
    			append_dev(div2, t1);
    			append_dev(div2, h50);
    			append_dev(h50, t2);
    			append_dev(h50, t3);
    			append_dev(h50, t4);
    			append_dev(div2, t5);
    			append_dev(div2, div0);
    			append_dev(div0, ul);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			append_dev(ul, t6);
    			append_dev(ul, p0);
    			append_dev(p0, t7);
    			append_dev(div2, t8);
    			append_dev(div2, br);
    			append_dev(div2, t9);
    			append_dev(div2, h51);
    			append_dev(h51, t10);
    			append_dev(div2, t11);
    			append_dev(div2, div1);
    			append_dev(div1, button0);
    			append_dev(div1, t13);
    			append_dev(div1, button1);
    			append_dev(div1, t15);
    			append_dev(div1, p1);
    			append_dev(p1, t16);
    			append_dev(p1, t17);
    			append_dev(div1, t18);
    			append_dev(div1, p2);
    			append_dev(p2, t19);
    			append_dev(p2, t20);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*result*/ ctx[9], false, false, false),
    					listen_dev(button1, "click", /*initImgs*/ ctx[7], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*qrn_In*/ 4 && t3_value !== (t3_value = /*ques_Array*/ ctx[6][/*qrn_In*/ ctx[2]] + "")) set_data_dev(t3, t3_value);

    			if (dirty & /*assign_resp, selectionArray*/ 264) {
    				each_value = /*selectionArray*/ ctx[3];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1D(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1D(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, t6);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*user_resp*/ 32) set_data_dev(t7, /*user_resp*/ ctx[5]);
    			if (dirty & /*showPopUp*/ 2) set_data_dev(t10, /*showPopUp*/ ctx[1]);

    			if (dirty & /*showNext*/ 1) {
    				set_style(h51, "display", /*showNext*/ ctx[0]);
    			}

    			if (dirty & /*user_resp*/ 32) set_data_dev(t17, /*user_resp*/ ctx[5]);
    			if (dirty & /*c_Ans*/ 16) set_data_dev(t20, /*c_Ans*/ ctx[4]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1$.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1$($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MD_M4", slots, []);
    	let showNext = "none";
    	let showPopUp;
    	let ques_Array = ["more", "fewer"];
    	let qrn_In = 0;
    	let rn_for_US = [];
    	let selectionArray = [{ s_optVal: 0, s_img: "" }, { s_optVal: 0, s_img: "" }];
    	let c_Ans = 0;
    	let user_resp = 0;
    	let sArray = shapeArray;

    	function initImgs() {
    		// random shape identified
    		$$invalidate(4, c_Ans = 0);

    		$$invalidate(5, user_resp = 0);
    		$$invalidate(2, qrn_In = Math.floor(Math.random() * ques_Array.length));

    		//making the the false null for every reinitialization
    		//randomly fill 4 choices for user to select
    		for (let i = 0; i < selectionArray.length; i++) {
    			rn_for_US[i] = Math.floor(Math.random() * sArray.length);
    			$$invalidate(3, selectionArray[i].s_img = sArray[rn_for_US[i]].img_src, selectionArray);
    			$$invalidate(3, selectionArray[i].s_optVal = sArray[rn_for_US[i]].sides, selectionArray);
    		}

    		

    		//for assigning the correct answer
    		for (let i = 0; i < selectionArray.length; i++) {
    			if (ques_Array[qrn_In] == ques_Array[0]) {
    				if (selectionArray[0].s_optVal > selectionArray[1].s_optVal) {
    					$$invalidate(4, c_Ans = selectionArray[0].s_optVal);
    				} else {
    					$$invalidate(4, c_Ans = selectionArray[1].s_optVal);
    				}
    			} else {
    				if (selectionArray[0].s_optVal < selectionArray[1].s_optVal) {
    					$$invalidate(4, c_Ans = selectionArray[0].s_optVal);
    				} else {
    					$$invalidate(4, c_Ans = selectionArray[1].s_optVal);
    				}
    			}
    		}

    		$$invalidate(1, showPopUp = null);
    		$$invalidate(0, showNext = "none");
    	}

    	initImgs();

    	function assign_resp(resp) {
    		$$invalidate(5, user_resp = resp);
    	}

    	function result(resp) {
    		//console.log('inside result')
    		//console.log('user resp is',{user_resp})
    		//console.log('crt answer is',c_Ans)
    		$$invalidate(0, showNext = "inline-block");

    		if (user_resp == c_Ans) {
    			$$invalidate(1, showPopUp = randomCorrect());
    			return;
    		} else {
    			$$invalidate(1, showPopUp = randomWrong());
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MD_M4> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		shapeArray,
    		randomCorrect,
    		randomWrong,
    		showNext,
    		showPopUp,
    		ques_Array,
    		qrn_In,
    		rn_for_US,
    		selectionArray,
    		c_Ans,
    		user_resp,
    		sArray,
    		initImgs,
    		assign_resp,
    		result
    	});

    	$$self.$inject_state = $$props => {
    		if ("showNext" in $$props) $$invalidate(0, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(1, showPopUp = $$props.showPopUp);
    		if ("ques_Array" in $$props) $$invalidate(6, ques_Array = $$props.ques_Array);
    		if ("qrn_In" in $$props) $$invalidate(2, qrn_In = $$props.qrn_In);
    		if ("rn_for_US" in $$props) rn_for_US = $$props.rn_for_US;
    		if ("selectionArray" in $$props) $$invalidate(3, selectionArray = $$props.selectionArray);
    		if ("c_Ans" in $$props) $$invalidate(4, c_Ans = $$props.c_Ans);
    		if ("user_resp" in $$props) $$invalidate(5, user_resp = $$props.user_resp);
    		if ("sArray" in $$props) sArray = $$props.sArray;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		showNext,
    		showPopUp,
    		qrn_In,
    		selectionArray,
    		c_Ans,
    		user_resp,
    		ques_Array,
    		initImgs,
    		assign_resp,
    		result
    	];
    }

    class G1_MD_M4 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1$, create_fragment$1$, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MD_M4",
    			options,
    			id: create_fragment$1$.name
    		});
    	}
    }

    /* src/components/taskComponents/G1_MD_M5.svelte generated by Svelte v3.37.0 */

    const { console: console_1$5 } = globals;
    const file$1Z = "src/components/taskComponents/G1_MD_M5.svelte";

    function get_each_context$1C(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	return child_ctx;
    }

    // (53:8) {#each selectionArray as item}
    function create_each_block$1C(ctx) {
    	let li;
    	let input;
    	let t;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[8](/*item*/ ctx[13]);
    	}

    	const block = {
    		c: function create() {
    			li = element("li");
    			input = element("input");
    			t = space();
    			attr_dev(input, "type", "button");
    			input.value = /*item*/ ctx[13];
    			add_location(input, file$1Z, 54, 12, 1363);
    			add_location(li, file$1Z, 53, 10, 1346);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, input);
    			append_dev(li, t);

    			if (!mounted) {
    				dispose = listen_dev(input, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1C.name,
    		type: "each",
    		source: "(53:8) {#each selectionArray as item}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1_(ctx) {
    	let div3;
    	let h4;
    	let t1;
    	let h50;
    	let t2;
    	let strong0;
    	let t4;
    	let strong1;
    	let t6;
    	let div0;
    	let label;
    	let img;
    	let img_src_value;
    	let t7;
    	let div1;
    	let ul;
    	let t8;
    	let br;
    	let t9;
    	let h51;
    	let t10;
    	let t11;
    	let div2;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let p;
    	let t16;
    	let t17;
    	let mounted;
    	let dispose;
    	let each_value = /*selectionArray*/ ctx[4];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1C(get_each_context$1C(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			h4 = element("h4");
    			h4.textContent = "Two-Dimensional Shapes";
    			t1 = space();
    			h50 = element("h5");
    			t2 = text("Is the shape ");
    			strong0 = element("strong");
    			strong0.textContent = "OPEN";
    			t4 = text(" or ");
    			strong1 = element("strong");
    			strong1.textContent = "Closed";
    			t6 = space();
    			div0 = element("div");
    			label = element("label");
    			img = element("img");
    			t7 = space();
    			div1 = element("div");
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t8 = space();
    			br = element("br");
    			t9 = space();
    			h51 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[2]);
    			t11 = space();
    			div2 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			p = element("p");
    			t16 = text("the correct answer is ");
    			t17 = text(/*c_Ans*/ ctx[3]);
    			add_location(h4, file$1Z, 43, 4, 1045);
    			add_location(strong0, file$1Z, 44, 21, 1098);
    			add_location(strong1, file$1Z, 44, 46, 1123);
    			add_location(h50, file$1Z, 44, 4, 1081);
    			if (img.src !== (img_src_value = /*ques_Img*/ ctx[0])) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			attr_dev(img, "width", "30%");
    			attr_dev(img, "class", "svelte-cecf3z");
    			add_location(img, file$1Z, 47, 8, 1208);
    			attr_dev(label, "for", "myck");
    			add_location(label, file$1Z, 46, 6, 1181);
    			attr_dev(div0, "class", "myck");
    			add_location(div0, file$1Z, 45, 4, 1156);
    			add_location(ul, file$1Z, 51, 6, 1292);
    			add_location(div1, file$1Z, 50, 4, 1280);
    			add_location(br, file$1Z, 60, 4, 1500);
    			set_style(h51, "display", /*showNext*/ ctx[1]);
    			attr_dev(h51, "class", "mt-5");
    			add_location(h51, file$1Z, 61, 4, 1509);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn rerun");
    			add_location(button0, file$1Z, 64, 6, 1594);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn rerun");
    			add_location(button1, file$1Z, 67, 6, 1700);
    			add_location(div2, file$1Z, 63, 4, 1582);
    			add_location(p, file$1Z, 71, 4, 1814);
    			add_location(div3, file$1Z, 42, 2, 1035);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, h4);
    			append_dev(div3, t1);
    			append_dev(div3, h50);
    			append_dev(h50, t2);
    			append_dev(h50, strong0);
    			append_dev(h50, t4);
    			append_dev(h50, strong1);
    			append_dev(div3, t6);
    			append_dev(div3, div0);
    			append_dev(div0, label);
    			append_dev(label, img);
    			append_dev(div3, t7);
    			append_dev(div3, div1);
    			append_dev(div1, ul);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			append_dev(div3, t8);
    			append_dev(div3, br);
    			append_dev(div3, t9);
    			append_dev(div3, h51);
    			append_dev(h51, t10);
    			append_dev(div3, t11);
    			append_dev(div3, div2);
    			append_dev(div2, button0);
    			append_dev(div2, t13);
    			append_dev(div2, button1);
    			append_dev(div3, t15);
    			append_dev(div3, p);
    			append_dev(p, t16);
    			append_dev(p, t17);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler_1*/ ctx[9], false, false, false),
    					listen_dev(button1, "click", /*click_handler_2*/ ctx[10], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*ques_Img*/ 1 && img.src !== (img_src_value = /*ques_Img*/ ctx[0])) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*selectionArray, assign_resp*/ 80) {
    				each_value = /*selectionArray*/ ctx[4];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1C(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1C(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*showPopUp*/ 4) set_data_dev(t10, /*showPopUp*/ ctx[2]);

    			if (dirty & /*showNext*/ 2) {
    				set_style(h51, "display", /*showNext*/ ctx[1]);
    			}

    			if (dirty & /*c_Ans*/ 8) set_data_dev(t17, /*c_Ans*/ ctx[3]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1_.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1_($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MD_M5", slots, []);
    	let ques_Img = "";
    	let selectionArray = ["open", "closed"];
    	let user_resp = "";
    	let showNext = "none";
    	let showPopUp;
    	let c_Ans = "";
    	let sArray = shapeArray;

    	function initImgs() {
    		$$invalidate(3, c_Ans = null);
    		let ques_rIn = Math.floor(Math.random() * sArray.length);
    		$$invalidate(0, ques_Img = sArray[ques_rIn].img_src);
    		$$invalidate(3, c_Ans = sArray[ques_rIn].s_type);
    		console.log("inside init", { ques_Img });
    		console.log("inside init", { c_Ans });
    		$$invalidate(2, showPopUp = null);
    		$$invalidate(1, showNext = "none");
    	}

    	initImgs();

    	function assign_resp(p_Ans) {
    		user_resp = p_Ans;
    	}

    	function checkAns() {
    		$$invalidate(1, showNext = "inline-block");

    		if (user_resp == c_Ans) {
    			$$invalidate(2, showPopUp = randomCorrect());
    			return;
    		} else {
    			$$invalidate(2, showPopUp = randomWrong());
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$5.warn(`<G1_MD_M5> was created with unknown prop '${key}'`);
    	});

    	const click_handler = item => assign_resp(item);
    	const click_handler_1 = () => checkAns();
    	const click_handler_2 = () => initImgs();

    	$$self.$capture_state = () => ({
    		shapeArray,
    		randomCorrect,
    		randomWrong,
    		ques_Img,
    		selectionArray,
    		user_resp,
    		showNext,
    		showPopUp,
    		c_Ans,
    		sArray,
    		initImgs,
    		assign_resp,
    		checkAns
    	});

    	$$self.$inject_state = $$props => {
    		if ("ques_Img" in $$props) $$invalidate(0, ques_Img = $$props.ques_Img);
    		if ("selectionArray" in $$props) $$invalidate(4, selectionArray = $$props.selectionArray);
    		if ("user_resp" in $$props) user_resp = $$props.user_resp;
    		if ("showNext" in $$props) $$invalidate(1, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(2, showPopUp = $$props.showPopUp);
    		if ("c_Ans" in $$props) $$invalidate(3, c_Ans = $$props.c_Ans);
    		if ("sArray" in $$props) sArray = $$props.sArray;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		ques_Img,
    		showNext,
    		showPopUp,
    		c_Ans,
    		selectionArray,
    		initImgs,
    		assign_resp,
    		checkAns,
    		click_handler,
    		click_handler_1,
    		click_handler_2
    	];
    }

    class G1_MD_M5 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1_, create_fragment$1_, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MD_M5",
    			options,
    			id: create_fragment$1_.name
    		});
    	}
    }

    /* src/components/taskComponents/G1_MD_M7.svelte generated by Svelte v3.37.0 */

    const { console: console_1$4 } = globals;
    const file$1Y = "src/components/taskComponents/G1_MD_M7.svelte";

    function get_each_context$1B(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	return child_ctx;
    }

    // (56:8) {#each selectionArray as item}
    function create_each_block$1B(ctx) {
    	let li;
    	let input;
    	let t;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[8](/*item*/ ctx[13]);
    	}

    	const block = {
    		c: function create() {
    			li = element("li");
    			input = element("input");
    			t = space();
    			attr_dev(input, "type", "button");
    			input.value = /*item*/ ctx[13].s_opt;
    			add_location(input, file$1Y, 57, 12, 1446);
    			add_location(li, file$1Y, 56, 10, 1429);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, input);
    			append_dev(li, t);

    			if (!mounted) {
    				dispose = listen_dev(input, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1B.name,
    		type: "each",
    		source: "(56:8) {#each selectionArray as item}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1Z(ctx) {
    	let div3;
    	let h4;
    	let t1;
    	let h50;
    	let t2;
    	let strong0;
    	let t4;
    	let strong1;
    	let t6;
    	let div0;
    	let label;
    	let img;
    	let img_src_value;
    	let t7;
    	let div1;
    	let ul;
    	let t8;
    	let br;
    	let t9;
    	let h51;
    	let t10;
    	let t11;
    	let div2;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let p;
    	let t16;
    	let t17;
    	let mounted;
    	let dispose;
    	let each_value = /*selectionArray*/ ctx[4];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1B(get_each_context$1B(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			h4 = element("h4");
    			h4.textContent = "Two-Dimensional Shapes";
    			t1 = space();
    			h50 = element("h5");
    			t2 = text("Does the picture have ");
    			strong0 = element("strong");
    			strong0.textContent = "Symmetry";
    			t4 = text(" or ");
    			strong1 = element("strong");
    			strong1.textContent = "not";
    			t6 = space();
    			div0 = element("div");
    			label = element("label");
    			img = element("img");
    			t7 = space();
    			div1 = element("div");
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t8 = space();
    			br = element("br");
    			t9 = space();
    			h51 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[2]);
    			t11 = space();
    			div2 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			p = element("p");
    			t16 = text("the correct answer is ");
    			t17 = text(/*c_Ans*/ ctx[3]);
    			add_location(h4, file$1Y, 46, 4, 1118);
    			add_location(strong0, file$1Y, 47, 30, 1180);
    			add_location(strong1, file$1Y, 47, 59, 1209);
    			add_location(h50, file$1Y, 47, 4, 1154);
    			if (img.src !== (img_src_value = /*ques_Img*/ ctx[0])) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			attr_dev(img, "width", "30%");
    			attr_dev(img, "class", "svelte-7i9zl7");
    			add_location(img, file$1Y, 50, 8, 1291);
    			attr_dev(label, "for", "myck");
    			add_location(label, file$1Y, 49, 6, 1264);
    			attr_dev(div0, "class", "myck");
    			add_location(div0, file$1Y, 48, 4, 1239);
    			add_location(ul, file$1Y, 54, 6, 1375);
    			add_location(div1, file$1Y, 53, 4, 1363);
    			add_location(br, file$1Y, 63, 4, 1595);
    			set_style(h51, "display", /*showNext*/ ctx[1]);
    			attr_dev(h51, "class", "mt-5");
    			add_location(h51, file$1Y, 64, 4, 1604);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn rerun");
    			add_location(button0, file$1Y, 67, 6, 1689);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn rerun");
    			add_location(button1, file$1Y, 70, 6, 1795);
    			add_location(div2, file$1Y, 66, 4, 1677);
    			add_location(p, file$1Y, 74, 4, 1909);
    			add_location(div3, file$1Y, 45, 2, 1108);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, h4);
    			append_dev(div3, t1);
    			append_dev(div3, h50);
    			append_dev(h50, t2);
    			append_dev(h50, strong0);
    			append_dev(h50, t4);
    			append_dev(h50, strong1);
    			append_dev(div3, t6);
    			append_dev(div3, div0);
    			append_dev(div0, label);
    			append_dev(label, img);
    			append_dev(div3, t7);
    			append_dev(div3, div1);
    			append_dev(div1, ul);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			append_dev(div3, t8);
    			append_dev(div3, br);
    			append_dev(div3, t9);
    			append_dev(div3, h51);
    			append_dev(h51, t10);
    			append_dev(div3, t11);
    			append_dev(div3, div2);
    			append_dev(div2, button0);
    			append_dev(div2, t13);
    			append_dev(div2, button1);
    			append_dev(div3, t15);
    			append_dev(div3, p);
    			append_dev(p, t16);
    			append_dev(p, t17);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler_1*/ ctx[9], false, false, false),
    					listen_dev(button1, "click", /*click_handler_2*/ ctx[10], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*ques_Img*/ 1 && img.src !== (img_src_value = /*ques_Img*/ ctx[0])) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*selectionArray, assign_resp*/ 80) {
    				each_value = /*selectionArray*/ ctx[4];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1B(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1B(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*showPopUp*/ 4) set_data_dev(t10, /*showPopUp*/ ctx[2]);

    			if (dirty & /*showNext*/ 2) {
    				set_style(h51, "display", /*showNext*/ ctx[1]);
    			}

    			if (dirty & /*c_Ans*/ 8) set_data_dev(t17, /*c_Ans*/ ctx[3]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1Z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1Z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MD_M7", slots, []);
    	let ques_Img = "";
    	let selectionArray = [{ s_opt: "yes", s_val: true }, { s_opt: "no", s_val: false }];
    	let user_resp = "";
    	let showNext = "none";
    	let showPopUp;
    	let c_Ans = false;
    	let sArray = shapeArray_for_M7;

    	function initImgs() {
    		$$invalidate(3, c_Ans = null);
    		let ques_rIn = Math.floor(Math.random() * sArray.length);
    		$$invalidate(0, ques_Img = sArray[ques_rIn].img_src);
    		$$invalidate(3, c_Ans = sArray[ques_rIn].symmetric);
    		console.log("inside init", { ques_Img });
    		console.log("inside init", { c_Ans });
    		$$invalidate(2, showPopUp = null);
    		$$invalidate(1, showNext = "none");
    	}

    	initImgs();

    	function assign_resp(p_Ans) {
    		user_resp = p_Ans;
    	}

    	function checkAns() {
    		$$invalidate(1, showNext = "inline-block");

    		if (user_resp == c_Ans) {
    			$$invalidate(2, showPopUp = randomCorrect());
    			return;
    		} else {
    			$$invalidate(2, showPopUp = randomWrong());
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$4.warn(`<G1_MD_M7> was created with unknown prop '${key}'`);
    	});

    	const click_handler = item => assign_resp(item.s_val);
    	const click_handler_1 = () => checkAns();
    	const click_handler_2 = () => initImgs();

    	$$self.$capture_state = () => ({
    		shapeArray_for_M7,
    		randomCorrect,
    		randomWrong,
    		ques_Img,
    		selectionArray,
    		user_resp,
    		showNext,
    		showPopUp,
    		c_Ans,
    		sArray,
    		initImgs,
    		assign_resp,
    		checkAns
    	});

    	$$self.$inject_state = $$props => {
    		if ("ques_Img" in $$props) $$invalidate(0, ques_Img = $$props.ques_Img);
    		if ("selectionArray" in $$props) $$invalidate(4, selectionArray = $$props.selectionArray);
    		if ("user_resp" in $$props) user_resp = $$props.user_resp;
    		if ("showNext" in $$props) $$invalidate(1, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(2, showPopUp = $$props.showPopUp);
    		if ("c_Ans" in $$props) $$invalidate(3, c_Ans = $$props.c_Ans);
    		if ("sArray" in $$props) sArray = $$props.sArray;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		ques_Img,
    		showNext,
    		showPopUp,
    		c_Ans,
    		selectionArray,
    		initImgs,
    		assign_resp,
    		checkAns,
    		click_handler,
    		click_handler_1,
    		click_handler_2
    	];
    }

    class G1_MD_M7 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1Z, create_fragment$1Z, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MD_M7",
    			options,
    			id: create_fragment$1Z.name
    		});
    	}
    }

    const wrng=[
        'you may be wrong',
        'ohh just miss',
        'you didnt get it',
        'wronggggggg'
    ];

    const rght=[
        'you are right',
        'you have done it',
        'splendid',
        'correct'
    ];

    function right(){
        return (rght[Math.floor(Math.random() * rght.length)]);
    }
    function wrong(){
        return (wrng[Math.floor(Math.random() * wrng.length)]);
    }

    /* src/components/taskComponents/rough12.svelte generated by Svelte v3.37.0 */
    const file$1X = "src/components/taskComponents/rough12.svelte";

    function get_each_context$1A(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$v(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	child_ctx[17] = list;
    	child_ctx[18] = i;
    	return child_ctx;
    }

    // (11:5) {#if x.show}
    function create_if_block_5$1(ctx) {
    	let span;
    	let t_value = /*x*/ ctx[16].value + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			add_location(span, file$1X, 11, 5, 160);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*temp*/ 16 && t_value !== (t_value = /*x*/ ctx[16].value + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$1.name,
    		type: "if",
    		source: "(11:5) {#if x.show}",
    		ctx
    	});

    	return block;
    }

    // (14:5) {#if !x.show}
    function create_if_block_4$2(ctx) {
    	let span;
    	let input;
    	let mounted;
    	let dispose;

    	function input_input_handler() {
    		/*input_input_handler*/ ctx[8].call(input, /*each_value_1*/ ctx[17], /*index*/ ctx[18]);
    	}

    	const block = {
    		c: function create() {
    			span = element("span");
    			input = element("input");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "maxlength", "6");
    			add_location(input, file$1X, 14, 12, 226);
    			add_location(span, file$1X, 14, 5, 219);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, input);
    			set_input_value(input, /*x*/ ctx[16].resp);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*temp*/ 16 && input.value !== /*x*/ ctx[16].resp) {
    				set_input_value(input, /*x*/ ctx[16].resp);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$2.name,
    		type: "if",
    		source: "(14:5) {#if !x.show}",
    		ctx
    	});

    	return block;
    }

    // (17:5) {#if index == 1}
    function create_if_block_3$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("=");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$2.name,
    		type: "if",
    		source: "(17:5) {#if index == 1}",
    		ctx
    	});

    	return block;
    }

    // (20:5) {#if index == 0}
    function create_if_block_2$k(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("+");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$k.name,
    		type: "if",
    		source: "(20:5) {#if index == 0}",
    		ctx
    	});

    	return block;
    }

    // (9:4) {#each y as x,index}
    function create_each_block_1$v(ctx) {
    	let t0;
    	let t1;
    	let t2;
    	let if_block3_anchor;
    	let if_block0 = /*x*/ ctx[16].show && create_if_block_5$1(ctx);
    	let if_block1 = !/*x*/ ctx[16].show && create_if_block_4$2(ctx);
    	let if_block2 = /*index*/ ctx[18] == 1 && create_if_block_3$2(ctx);
    	let if_block3 = /*index*/ ctx[18] == 0 && create_if_block_2$k(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			t2 = space();
    			if (if_block3) if_block3.c();
    			if_block3_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			if (if_block3) if_block3.m(target, anchor);
    			insert_dev(target, if_block3_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*x*/ ctx[16].show) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_5$1(ctx);
    					if_block0.c();
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (!/*x*/ ctx[16].show) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_4$2(ctx);
    					if_block1.c();
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block3) if_block3.d(detaching);
    			if (detaching) detach_dev(if_block3_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$v.name,
    		type: "each",
    		source: "(9:4) {#each y as x,index}",
    		ctx
    	});

    	return block;
    }

    // (6:2) {#each temp as y}
    function create_each_block$1A(ctx) {
    	let div;
    	let t;
    	let each_value_1 = /*y*/ ctx[13];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$v(get_each_context_1$v(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			add_location(div, file$1X, 6, 2, 78);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*temp*/ 16) {
    				each_value_1 = /*y*/ ctx[13];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$v(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$v(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, t);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1A.name,
    		type: "each",
    		source: "(6:2) {#each temp as y}",
    		ctx
    	});

    	return block;
    }

    // (33:1) {#if defaultAns}
    function create_if_block$1j(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*answer*/ ctx[1]) return create_if_block_1$k;
    		return create_else_block$1d;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1j.name,
    		type: "if",
    		source: "(33:1) {#if defaultAns}",
    		ctx
    	});

    	return block;
    }

    // (36:2) {:else}
    function create_else_block$1d(ctx) {
    	let p;
    	let t;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t = text(/*wrngAns*/ ctx[6]);
    			add_location(p, file$1X, 36, 3, 502);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*wrngAns*/ 64) set_data_dev(t, /*wrngAns*/ ctx[6]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1d.name,
    		type: "else",
    		source: "(36:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (34:2) {#if answer}
    function create_if_block_1$k(ctx) {
    	let p;
    	let t;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t = text(/*crtAns*/ ctx[5]);
    			add_location(p, file$1X, 34, 3, 473);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*crtAns*/ 32) set_data_dev(t, /*crtAns*/ ctx[5]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$k.name,
    		type: "if",
    		source: "(34:2) {#if answer}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1Y(ctx) {
    	let div1;
    	let div0;
    	let p;
    	let t1;
    	let t2;
    	let t3;
    	let button0;
    	let t5;
    	let button1;
    	let mounted;
    	let dispose;
    	let each_value = /*temp*/ ctx[4];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1A(get_each_context$1A(ctx, each_value, i));
    	}

    	let if_block = /*defaultAns*/ ctx[2] && create_if_block$1j(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			p = element("p");
    			p.textContent = "Multiples Of Ten";
    			t1 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t2 = space();
    			if (if_block) if_block.c();
    			t3 = space();
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t5 = space();
    			button1 = element("button");
    			button1.textContent = "Next";
    			add_location(p, file$1X, 3, 2, 31);
    			add_location(div0, file$1X, 2, 1, 23);
    			add_location(button0, file$1X, 42, 1, 542);
    			add_location(button1, file$1X, 43, 1, 586);
    			attr_dev(div1, "class", "abcd svelte-15b5vj");
    			add_location(div1, file$1X, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, p);
    			append_dev(div0, t1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div0, null);
    			}

    			append_dev(div1, t2);
    			if (if_block) if_block.m(div1, null);
    			append_dev(div1, t3);
    			append_dev(div1, button0);
    			append_dev(div1, t5);
    			append_dev(div1, button1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*submit*/ ctx[7], false, false, false),
    					listen_dev(button1, "click", /*click_handler*/ ctx[9], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*temp*/ 16) {
    				each_value = /*temp*/ ctx[4];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1A(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1A(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (/*defaultAns*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$1j(ctx);
    					if_block.c();
    					if_block.m(div1, t3);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_each(each_blocks, detaching);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1Y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const num1 = 10;
    const num2 = 20;

    function instance$1Y($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Rough12", slots, []);
    	let answer = false;
    	let defaultAns = false;

    	let ninja = [
    		{ show: true, value: null, resp: null },
    		{ show: true, value: null, resp: null },
    		{ show: true, value: null, resp: null }
    	];

    	let temp = [];
    	let showPopUp;
    	let crtAns;
    	let wrngAns;

    	//let answer ;
    	let resp = null;

    	let originalAns = -1;

    	function Add(x, noOfIterates) {
    		$$invalidate(4, temp = []);

    		for (let a of x) {
    			a.show = true;
    		}

    		$$invalidate(5, crtAns = right());
    		$$invalidate(6, wrngAns = wrong());
    		resp = null;
    		$$invalidate(2, defaultAns = false);
    		x[0].value = Math.floor(Math.random() * num1);
    		x[1].value = Math.floor(Math.random() * num2);
    		x[2].value = Math.abs(x[0].value + x[1].value);
    		let randomNo = Math.floor(Math.random() * 3);
    		$$invalidate(3, ninja[randomNo].show = false, ninja);
    		originalAns = ninja[randomNo].value;
    		temp.push(x);
    		let base = 10;

    		for (let y = 0; y < noOfIterates; y++) {
    			let obj = [
    				{ show: true, value: null },
    				{ show: true, value: null },
    				{ show: true, value: null }
    			];

    			obj[0].value = parseInt(x[0].value) * base;
    			obj[0].show = x[0].show;
    			obj[1].value = parseInt(x[1].value) * base;
    			obj[1].show = x[1].show;
    			obj[2].value = obj[0].value + obj[1].value;
    			obj[2].show = x[2].show;
    			temp.push(obj);
    			base = base * 10;
    		}
    	}

    	Add(ninja, 2);

    	function submit() {
    		for (let x of temp) {
    			let respObj = x.findIndex(obj => obj.show == false);

    			// let valueObj = x.map((element, index) => {
    			// 				if (element.show === true) {
    			// 				return index;
    			// 				}
    			// 			})
    			// 			.filter(element => element >= 0);
    			if (respObj == 0) {
    				if (parseInt(x[0].resp) + parseInt(x[1].value) === parseInt(x[2].value)) {
    					$$invalidate(2, defaultAns = true);
    					showPopUp = right();
    					$$invalidate(1, answer = true);
    				} else {
    					$$invalidate(1, answer = false);
    					return;
    				}
    			} else if (respObj == 1) {
    				if (parseInt(x[1].resp) + parseInt(x[0].value) === parseInt(x[2].value)) {
    					$$invalidate(2, defaultAns = true);
    					showPopUp = right();
    					$$invalidate(1, answer = true);
    				} else {
    					$$invalidate(1, answer = false);
    					return;
    				}
    			} else if (respObj == 2) {
    				if (parseInt(x[0].value) + parseInt(x[1].value) === parseInt(x[2].resp)) {
    					$$invalidate(2, defaultAns = true);
    					showPopUp = right();
    					$$invalidate(1, answer = true);
    				} else {
    					$$invalidate(1, answer = false);
    					return;
    				}
    			} else {
    				$$invalidate(2, defaultAns = true);
    				showPopUp = wrong();
    				$$invalidate(1, answer = false);
    				return;
    			}
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Rough12> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler(each_value_1, index) {
    		each_value_1[index].resp = this.value;
    		$$invalidate(4, temp);
    	}

    	const click_handler = () => Add(ninja, 2);

    	$$self.$capture_state = () => ({
    		right,
    		wrong,
    		num1,
    		num2,
    		answer,
    		defaultAns,
    		ninja,
    		temp,
    		showPopUp,
    		crtAns,
    		wrngAns,
    		resp,
    		originalAns,
    		Add,
    		submit
    	});

    	$$self.$inject_state = $$props => {
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("defaultAns" in $$props) $$invalidate(2, defaultAns = $$props.defaultAns);
    		if ("ninja" in $$props) $$invalidate(3, ninja = $$props.ninja);
    		if ("temp" in $$props) $$invalidate(4, temp = $$props.temp);
    		if ("showPopUp" in $$props) showPopUp = $$props.showPopUp;
    		if ("crtAns" in $$props) $$invalidate(5, crtAns = $$props.crtAns);
    		if ("wrngAns" in $$props) $$invalidate(6, wrngAns = $$props.wrngAns);
    		if ("resp" in $$props) resp = $$props.resp;
    		if ("originalAns" in $$props) originalAns = $$props.originalAns;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		Add,
    		answer,
    		defaultAns,
    		ninja,
    		temp,
    		crtAns,
    		wrngAns,
    		submit,
    		input_input_handler,
    		click_handler
    	];
    }

    class Rough12 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1Y, create_fragment$1Y, safe_not_equal, { Add: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Rough12",
    			options,
    			id: create_fragment$1Y.name
    		});
    	}

    	get Add() {
    		return this.$$.ctx[0];
    	}

    	set Add(value) {
    		throw new Error("<Rough12>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var digits = [
        {
    		color: '#B10DC9',
    		id: '0',
    		label: 'zero',
    		img_name: 'zero.png'
    	},
    	{
    		color: '#001f3f',
    		id: '1',
    		label: 'one',
    		img_name: 'one.png'
    	},
    	{
    		color: '#0074D9',
    		id: '2',
    		label: 'two',
    		img_name: 'two.png'
    	},
    	{
    		color: '#7FDBFF',
    		id: '3',
    		label: 'three',
    		img_name: 'three.png'
    	},
    	{
    		color: '#39CCCC',
    		id: '4',
    		label: 'four',
    		img_name: 'four.png'
    	},
    	{
    		color: '#3D9970',
    		id: '5',
    		label: 'five',
    		img_name: 'five.png'
    	},
    	{
    		color: '#2ECC40',
    		id: '6',
    		label: 'six',
    		img_name: 'six.png'
    	},
    	{
    		color: '#01FF70',
    		id: '7',
    		label: 'seven',
    		img_name: 'seven.png'
    	},
    	{
    		color: '#FFDC00',
    		id: '8',
    		label: 'eight',
    		img_name: 'eight.png'
    	},
    	{
    		color: '#FF851B',
    		id: '9',
    		label: 'nine',
    		img_name: 'nine.png'
    	},
    	{
    		color: '#FF4136',
    		id: '10',
    		label: 'ten',
    		img_name: 'ten.png'
    	}
    ];

    /* src/components/Input_digitpad.svelte generated by Svelte v3.37.0 */

    const { console: console_1$3 } = globals;
    const file$1W = "src/components/Input_digitpad.svelte";

    function get_each_context$1z(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	child_ctx[5] = i;
    	return child_ctx;
    }

    // (11:4) {#each Array(max_button) as _, i}
    function create_each_block$1z(ctx) {
    	let div;
    	let button;
    	let t0;
    	let t1;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[2](/*i*/ ctx[5]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			t0 = text(/*i*/ ctx[5]);
    			t1 = space();
    			set_style(button, "background-color", digits[/*i*/ ctx[5]].color);
    			attr_dev(button, "class", "svelte-a3kgf8");
    			add_location(button, file$1W, 12, 8, 294);
    			attr_dev(div, "class", "square");
    			add_location(div, file$1W, 11, 6, 265);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);
    			append_dev(button, t0);
    			append_dev(div, t1);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1z.name,
    		type: "each",
    		source: "(11:4) {#each Array(max_button) as _, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1X(ctx) {
    	let div1;
    	let div0;
    	let each_value = Array(/*max_button*/ ctx[1]);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1z(get_each_context$1z(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "class", "grid-wide");
    			add_location(div0, file$1W, 9, 2, 197);
    			attr_dev(div1, "class", "digipad");
    			add_location(div1, file$1W, 8, 0, 173);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div0, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*digits, usr_select, max_button*/ 3) {
    				each_value = Array(/*max_button*/ ctx[1]);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1z(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1z(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1X.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1X($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Input_digitpad", slots, []);
    	let { usr_select = "" } = $$props;
    	let { max_button } = $$props;
    	console.log("inside Input DigitPad");
    	const writable_props = ["usr_select", "max_button"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$3.warn(`<Input_digitpad> was created with unknown prop '${key}'`);
    	});

    	const click_handler = i => $$invalidate(0, usr_select = i);

    	$$self.$$set = $$props => {
    		if ("usr_select" in $$props) $$invalidate(0, usr_select = $$props.usr_select);
    		if ("max_button" in $$props) $$invalidate(1, max_button = $$props.max_button);
    	};

    	$$self.$capture_state = () => ({ digits, usr_select, max_button });

    	$$self.$inject_state = $$props => {
    		if ("usr_select" in $$props) $$invalidate(0, usr_select = $$props.usr_select);
    		if ("max_button" in $$props) $$invalidate(1, max_button = $$props.max_button);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [usr_select, max_button, click_handler];
    }

    class Input_digitpad extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1X, create_fragment$1X, safe_not_equal, { usr_select: 0, max_button: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Input_digitpad",
    			options,
    			id: create_fragment$1X.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*max_button*/ ctx[1] === undefined && !("max_button" in props)) {
    			console_1$3.warn("<Input_digitpad> was created without expected prop 'max_button'");
    		}
    	}

    	get usr_select() {
    		throw new Error("<Input_digitpad>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set usr_select(value) {
    		throw new Error("<Input_digitpad>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get max_button() {
    		throw new Error("<Input_digitpad>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set max_button(value) {
    		throw new Error("<Input_digitpad>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const BOX_SHPCOLOR_LOWNUM = 0;
    const BOX_SHPCOLOR_HIGHNUM = 28;
    const BOX_SHAPES_LIST = ["square", "triangle", "rectangle", "circle"];
    const BOX_COLOR_LIST = ["red", "blue", "green", "yellow", "pink", "white", "black"];
    // filename is formatted in this manner: box_with_color_shape.png
    // location or path is images/shapes/box_with_color_shape.png
    const BOX_SHPCOLOR_REPO = [
        {id:0, color:"", shape:"", img_fn:"empty_box_for_shape.png"},
        {id:1, color:"red", shape:"square", img_fn:"box_with_red_square.png"},
        {id:2, color:"blue", shape:"square", img_fn:"box_with_blue_square.png"},
        {id:3, color:"green", shape:"square", img_fn:"box_with_green_square.png"},
        {id:4, color:"yellow", shape:"square", img_fn:"box_with_yellow_square.png"},
        {id:5, color:"pink", shape:"square", img_fn:"box_with_pink_square.png"},
        {id:6, color:"white", shape:"square", img_fn:"box_with_white_square.png"},
        {id:7, color:"black", shape:"square", img_fn:"box_with_black_square.png"},
        {id:8, color:"red", shape:"triangle", img_fn:"box_with_red_triangle.png"},
        {id:9, color:"blue", shape:"triangle", img_fn:"box_with_blue_triangle.png"},
        {id:10, color:"green", shape:"triangle", img_fn:"box_with_green_triangle.png"},
        {id:11, color:"yellow", shape:"triangle", img_fn:"box_with_yellow_triangle.png"},
        {id:12, color:"pink", shape:"triangle", img_fn:"box_with_pink_triangle.png"},
        {id:13, color:"white", shape:"triangle", img_fn:"box_with_white_triangle.png"},
        {id:14, color:"black", shape:"triangle", img_fn:"box_with_black_triangle.png"},
        {id:15, color:"red", shape:"rectangle", img_fn:"box_with_red_rectangle.png"},
        {id:16, color:"blue", shape:"rectangle", img_fn:"box_with_blue_rectangle.png"},
        {id:17, color:"green", shape:"rectangle", img_fn:"box_with_green_rectangle.png"},
        {id:18, color:"yellow", shape:"rectangle", img_fn:"box_with_yellow_rectangle.png"},
        {id:19, color:"pink", shape:"rectangle", img_fn:"box_with_pink_rectangle.png"},
        {id:20, color:"white", shape:"rectangle", img_fn:"box_with_white_rectangle.png"},
        {id:21, color:"black", shape:"rectangle", img_fn:"box_with_black_rectangle.png"},
        {id:22, color:"red", shape:"circle", img_fn:"box_with_red_circle.png"},
        {id:23, color:"blue", shape:"circle", img_fn:"box_with_blue_circle.png"},
        {id:24, color:"green", shape:"circle", img_fn:"box_with_green_circle.png"},
        {id:25, color:"yellow", shape:"circle", img_fn:"box_with_yellow_circle.png"},
        {id:26, color:"pink", shape:"circle", img_fn:"box_with_pink_circle.png"},
        {id:27, color:"white", shape:"circle", img_fn:"box_with_white_circle.png"},
        {id:28, color:"black", shape:"circle", img_fn:"box_with_black_circle.png"}
    ];

    const BOX_DOTS_REPO = [
        {id:0, color:"", shape:"", img_fn:"empty_box_for_shape.png"},
        {id:1, color:"red", shape:"circle", img_fn:"box_with_red_circle.png"},
        {id:2, color:"blue", shape:"circle", img_fn:"box_with_blue_circle.png"},
        {id:3, color:"green", shape:"circle", img_fn:"box_with_green_circle.png"},
        {id:4, color:"yellow", shape:"circle", img_fn:"box_with_yellow_circle.png"},
        {id:5, color:"pink", shape:"circle", img_fn:"box_with_pink_circle.png"},
        {id:6, color:"white", shape:"circle", img_fn:"box_with_white_circle.png"},
        {id:7, color:"black", shape:"circle", img_fn:"box_with_black_circle.png"}
    ];

    var images = /*#__PURE__*/Object.freeze({
        __proto__: null,
        BOX_SHPCOLOR_LOWNUM: BOX_SHPCOLOR_LOWNUM,
        BOX_SHPCOLOR_HIGHNUM: BOX_SHPCOLOR_HIGHNUM,
        BOX_SHAPES_LIST: BOX_SHAPES_LIST,
        BOX_COLOR_LIST: BOX_COLOR_LIST,
        BOX_SHPCOLOR_REPO: BOX_SHPCOLOR_REPO,
        BOX_DOTS_REPO: BOX_DOTS_REPO
    });

    const CORRECT_ANS_MSG_LOWNUM = 0;
    const CORRECT_ANS_MSG_HIGHNUM =9;
    const CORRECT_ANS_MSG  = [
            {id:0, lang:"en", msg: 'Yes, you got it!'},
            {id:1, lang:"en", msg: 'Correct!'},
            {id:2, lang:"en", msg: 'Wow, you are a champ!'},
            {id:3, lang:"en", msg: 'You are a winner!'},
            {id:4, lang:"en", msg: 'Splendid!'},
            {id:5, lang:"en", msg: 'You got it!'},
            {id:6, lang:"en", msg: 'You got the correct answer!'},
            {id:7, lang:"en", msg: 'You are doing great!'},
            {id:8, lang:"en", msg: 'Perfect!'},
            {id:9, lang:"en", msg: 'Super!'}
        ];

    var c_ans = /*#__PURE__*/Object.freeze({
        __proto__: null,
        CORRECT_ANS_MSG_LOWNUM: CORRECT_ANS_MSG_LOWNUM,
        CORRECT_ANS_MSG_HIGHNUM: CORRECT_ANS_MSG_HIGHNUM,
        CORRECT_ANS_MSG: CORRECT_ANS_MSG
    });

    const WRONG_ANS_MSG_LOWNUM = 0;
    const WRONG_ANS_MSG_HIGHNUM =9;
    const WRONG_ANS_MSG = [
    	{id:0, lang:"en", msg: 'Sorry, you did not get it.'},
    	{id:1, lang:"en", msg: 'Incorrect.'},
        {id:2, lang:"en", msg: 'Better luck next time, champ!'},
        {id:3, lang:"en", msg: 'Oops, you missed!'},
        {id:4, lang:"en", msg: 'Good try, but not correct.'},
        {id:5, lang:"en", msg: 'Sorry, try again!'},
        {id:6, lang:"en", msg: 'You did not get the answer.'},
        {id:7, lang:"en", msg: 'Sorry! Keep trying.'},
        {id:8, lang:"en", msg: 'Sorry, better luck next time.'},
        {id:9, lang:"en", msg: 'Yikes! missed it.'}
    ];

    var w_ans = /*#__PURE__*/Object.freeze({
        __proto__: null,
        WRONG_ANS_MSG_LOWNUM: WRONG_ANS_MSG_LOWNUM,
        WRONG_ANS_MSG_HIGHNUM: WRONG_ANS_MSG_HIGHNUM,
        WRONG_ANS_MSG: WRONG_ANS_MSG
    });

    /* src/components/G1_MA_A2.svelte generated by Svelte v3.37.0 */
    const file$1V = "src/components/G1_MA_A2.svelte";

    function get_each_context$1y(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	child_ctx[22] = i;
    	return child_ctx;
    }

    // (105:16) {:else}
    function create_else_block_3(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (img.src !== (img_src_value = "images/shapes/" + BOX_SHPCOLOR_REPO[0].img_fn)) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "align", "middle");
    			attr_dev(img, "width", "10%");
    			attr_dev(img, "height", "auto");
    			attr_dev(img, "alt", "");
    			add_location(img, file$1V, 105, 20, 3697);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3.name,
    		type: "else",
    		source: "(105:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (98:16) {#if box_has_img[i]}
    function create_if_block_6(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (img.src !== (img_src_value = "images/shapes/" + BOX_SHPCOLOR_REPO[/*img_rn*/ ctx[1]].img_fn)) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "align", "middle");
    			attr_dev(img, "width", "10%");
    			attr_dev(img, "height", "auto");
    			attr_dev(img, "alt", "");
    			add_location(img, file$1V, 98, 20, 3413);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*img_rn*/ 2 && img.src !== (img_src_value = "images/shapes/" + BOX_SHPCOLOR_REPO[/*img_rn*/ ctx[1]].img_fn)) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(98:16) {#if box_has_img[i]}",
    		ctx
    	});

    	return block;
    }

    // (80:29) 
    function create_if_block_4$1(ctx) {
    	let br;
    	let t;
    	let if_block_anchor;

    	function select_block_type_2(ctx, dirty) {
    		if (/*box_has_img*/ ctx[6][/*i*/ ctx[22]]) return create_if_block_5;
    		return create_else_block_2$a;
    	}

    	let current_block_type = select_block_type_2(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			br = element("br");
    			t = space();
    			if_block.c();
    			if_block_anchor = empty();
    			add_location(br, file$1V, 80, 16, 2733);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, br, anchor);
    			insert_dev(target, t, anchor);
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t);
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(80:29) ",
    		ctx
    	});

    	return block;
    }

    // (64:12) {#if i < 5}
    function create_if_block_2$j(ctx) {
    	let if_block_anchor;

    	function select_block_type_1(ctx, dirty) {
    		if (/*box_has_img*/ ctx[6][/*i*/ ctx[22]]) return create_if_block_3$1;
    		return create_else_block_1$a;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$j.name,
    		type: "if",
    		source: "(64:12) {#if i < 5}",
    		ctx
    	});

    	return block;
    }

    // (89:16) {:else}
    function create_else_block_2$a(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (img.src !== (img_src_value = "images/shapes/" + BOX_SHPCOLOR_REPO[0].img_fn)) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "align", "middle");
    			attr_dev(img, "width", "10%");
    			attr_dev(img, "height", "auto");
    			attr_dev(img, "alt", "");
    			add_location(img, file$1V, 89, 20, 3079);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$a.name,
    		type: "else",
    		source: "(89:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (82:16) {#if box_has_img[i]}
    function create_if_block_5(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (img.src !== (img_src_value = "images/shapes/" + BOX_SHPCOLOR_REPO[/*img_rn*/ ctx[1]].img_fn)) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "align", "middle");
    			attr_dev(img, "width", "10%");
    			attr_dev(img, "height", "auto");
    			attr_dev(img, "alt", "");
    			add_location(img, file$1V, 82, 20, 2795);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*img_rn*/ 2 && img.src !== (img_src_value = "images/shapes/" + BOX_SHPCOLOR_REPO[/*img_rn*/ ctx[1]].img_fn)) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(82:16) {#if box_has_img[i]}",
    		ctx
    	});

    	return block;
    }

    // (72:16) {:else}
    function create_else_block_1$a(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (img.src !== (img_src_value = "images/shapes/" + BOX_SHPCOLOR_REPO[0].img_fn)) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "align", "middle");
    			attr_dev(img, "width", "10%");
    			attr_dev(img, "height", "auto");
    			attr_dev(img, "alt", "");
    			add_location(img, file$1V, 72, 20, 2430);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$a.name,
    		type: "else",
    		source: "(72:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (65:16) {#if box_has_img[i]}
    function create_if_block_3$1(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (img.src !== (img_src_value = "images/shapes/" + BOX_SHPCOLOR_REPO[/*img_rn*/ ctx[1]].img_fn)) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "align", "middle");
    			attr_dev(img, "width", "10%");
    			attr_dev(img, "height", "auto");
    			attr_dev(img, "alt", "");
    			add_location(img, file$1V, 65, 20, 2146);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*img_rn*/ 2 && img.src !== (img_src_value = "images/shapes/" + BOX_SHPCOLOR_REPO[/*img_rn*/ ctx[1]].img_fn)) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(65:16) {#if box_has_img[i]}",
    		ctx
    	});

    	return block;
    }

    // (63:8) {#each Array(COUNT_HIGHNUM) as _, i}
    function create_each_block$1y(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[22] < 5) return create_if_block_2$j;
    		if (/*i*/ ctx[22] == 5) return create_if_block_4$1;
    		if (/*box_has_img*/ ctx[6][/*i*/ ctx[22]]) return create_if_block_6;
    		return create_else_block_3;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1y.name,
    		type: "each",
    		source: "(63:8) {#each Array(COUNT_HIGHNUM) as _, i}",
    		ctx
    	});

    	return block;
    }

    // (120:8) {#if ans_submit}
    function create_if_block$1i(ctx) {
    	let if_block_anchor;

    	function select_block_type_3(ctx, dirty) {
    		if (/*usr_resp*/ ctx[5] === /*correct_answer*/ ctx[4]) return create_if_block_1$j;
    		return create_else_block$1c;
    	}

    	let current_block_type = select_block_type_3(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_3(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1i.name,
    		type: "if",
    		source: "(120:8) {#if ans_submit}",
    		ctx
    	});

    	return block;
    }

    // (123:8) {:else}
    function create_else_block$1c(ctx) {
    	let p;
    	let t_value = WRONG_ANS_MSG[/*w_ans_rn*/ ctx[3]].msg + "";
    	let t;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t = text(t_value);
    			add_location(p, file$1V, 123, 12, 4276);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*w_ans_rn*/ 8 && t_value !== (t_value = WRONG_ANS_MSG[/*w_ans_rn*/ ctx[3]].msg + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1c.name,
    		type: "else",
    		source: "(123:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (121:8) {#if (usr_resp === correct_answer)}
    function create_if_block_1$j(ctx) {
    	let p;
    	let t_value = CORRECT_ANS_MSG[/*c_ans_rn*/ ctx[2]].msg + "";
    	let t;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t = text(t_value);
    			add_location(p, file$1V, 121, 12, 4203);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*c_ans_rn*/ 4 && t_value !== (t_value = CORRECT_ANS_MSG[/*c_ans_rn*/ ctx[2]].msg + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$j.name,
    		type: "if",
    		source: "(121:8) {#if (usr_resp === correct_answer)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1W(ctx) {
    	let div2;
    	let div0;
    	let p0;
    	let t1;
    	let p1;
    	let t3;
    	let h2;
    	let t4;
    	let t5_value = BOX_SHPCOLOR_REPO[/*img_rn*/ ctx[1]].color + "";
    	let t5;
    	let t6;
    	let t7_value = BOX_SHPCOLOR_REPO[/*img_rn*/ ctx[1]].shape + "";
    	let t7;
    	let t8;
    	let t9;
    	let t10;
    	let div1;
    	let br;
    	let t11;
    	let p2;
    	let t13;
    	let npad;
    	let updating_usr_select;
    	let t14;
    	let t15;
    	let button0;
    	let t17;
    	let button1;
    	let t19;
    	let button2;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = Array(COUNT_HIGHNUM);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1y(get_each_context$1y(ctx, each_value, i));
    	}

    	function npad_usr_select_binding(value) {
    		/*npad_usr_select_binding*/ ctx[10](value);
    	}

    	let npad_props = { max_button: /*max_button*/ ctx[7] };

    	if (/*usr_resp*/ ctx[5] !== void 0) {
    		npad_props.usr_select = /*usr_resp*/ ctx[5];
    	}

    	npad = new Input_digitpad({ props: npad_props, $$inline: true });
    	binding_callbacks.push(() => bind(npad, "usr_select", npad_usr_select_binding));
    	let if_block = /*ans_submit*/ ctx[0] && create_if_block$1i(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			p0 = element("p");
    			p0.textContent = "Practice for counting upto 10:";
    			t1 = space();
    			p1 = element("p");
    			p1.textContent = "A full frame has 10 squares with shapes.";
    			t3 = space();
    			h2 = element("h2");
    			t4 = text("How many more ");
    			t5 = text(t5_value);
    			t6 = space();
    			t7 = text(t7_value);
    			t8 = text("s do you need to make 10?");
    			t9 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t10 = space();
    			div1 = element("div");
    			br = element("br");
    			t11 = space();
    			p2 = element("p");
    			p2.textContent = "Enter your answer here:";
    			t13 = space();
    			create_component(npad.$$.fragment);
    			t14 = space();
    			if (if_block) if_block.c();
    			t15 = space();
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t17 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t19 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			set_style(p0, "color", "gray");
    			add_location(p0, file$1V, 58, 8, 1708);
    			set_style(p1, "color", "gray");
    			add_location(p1, file$1V, 59, 8, 1774);
    			add_location(h2, file$1V, 60, 8, 1849);
    			add_location(div0, file$1V, 57, 4, 1694);
    			add_location(br, file$1V, 116, 8, 4021);
    			add_location(p2, file$1V, 117, 8, 4034);
    			add_location(div1, file$1V, 115, 4, 4007);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1V, 127, 4, 4362);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1V, 128, 4, 4458);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1V, 129, 4, 4555);
    			attr_dev(div2, "class", "stack-large");
    			add_location(div2, file$1V, 56, 0, 1664);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, p0);
    			append_dev(div0, t1);
    			append_dev(div0, p1);
    			append_dev(div0, t3);
    			append_dev(div0, h2);
    			append_dev(h2, t4);
    			append_dev(h2, t5);
    			append_dev(h2, t6);
    			append_dev(h2, t7);
    			append_dev(h2, t8);
    			append_dev(div0, t9);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div0, null);
    			}

    			append_dev(div2, t10);
    			append_dev(div2, div1);
    			append_dev(div1, br);
    			append_dev(div1, t11);
    			append_dev(div1, p2);
    			append_dev(div1, t13);
    			mount_component(npad, div1, null);
    			append_dev(div1, t14);
    			if (if_block) if_block.m(div1, null);
    			append_dev(div2, t15);
    			append_dev(div2, button0);
    			append_dev(div2, t17);
    			append_dev(div2, button1);
    			append_dev(div2, t19);
    			append_dev(div2, button2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[11], false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[12], false, false, false),
    					listen_dev(button2, "click", /*click_handler_2*/ ctx[13], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*img_rn*/ 2) && t5_value !== (t5_value = BOX_SHPCOLOR_REPO[/*img_rn*/ ctx[1]].color + "")) set_data_dev(t5, t5_value);
    			if ((!current || dirty & /*img_rn*/ 2) && t7_value !== (t7_value = BOX_SHPCOLOR_REPO[/*img_rn*/ ctx[1]].shape + "")) set_data_dev(t7, t7_value);

    			if (dirty & /*images, img_rn, box_has_img*/ 66) {
    				each_value = Array(COUNT_HIGHNUM);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1y(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1y(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			const npad_changes = {};

    			if (!updating_usr_select && dirty & /*usr_resp*/ 32) {
    				updating_usr_select = true;
    				npad_changes.usr_select = /*usr_resp*/ ctx[5];
    				add_flush_callback(() => updating_usr_select = false);
    			}

    			npad.$set(npad_changes);

    			if (/*ans_submit*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$1i(ctx);
    					if_block.c();
    					if_block.m(div1, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(npad.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(npad.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_each(each_blocks, detaching);
    			destroy_component(npad);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1W.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const COUNT_LOWNUM = 0;
    const COUNT_HIGHNUM = 10;

    function skill_exit() {
    	
    }

    function instance$1W($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MA_A2", slots, []);
    	let ans_submit = false;
    	let rerun = false;
    	let usr_exit = false;
    	let cnt_rn = COUNT_LOWNUM;
    	let img_rn = BOX_SHPCOLOR_LOWNUM;
    	let c_ans_rn = CORRECT_ANS_MSG_LOWNUM;
    	let w_ans_rn = WRONG_ANS_MSG_LOWNUM;
    	let correct_answer = -1;
    	let usr_resp = -1;
    	let clrLabel = "";
    	let shpLabel = "";
    	let imgFn = "";
    	let box_has_img = [];
    	let max_button = 11;

    	function init_shapes() {
    		cnt_rn = Math.floor(Math.random() * COUNT_HIGHNUM + COUNT_LOWNUM);
    		$$invalidate(1, img_rn = Math.floor(Math.random() * BOX_SHPCOLOR_HIGHNUM + BOX_SHPCOLOR_LOWNUM));
    		$$invalidate(2, c_ans_rn = Math.floor(Math.random() * CORRECT_ANS_MSG_HIGHNUM + CORRECT_ANS_MSG_LOWNUM));
    		$$invalidate(3, w_ans_rn = Math.floor(Math.random() * WRONG_ANS_MSG_HIGHNUM + WRONG_ANS_MSG_LOWNUM));
    		$$invalidate(4, correct_answer = COUNT_HIGHNUM - cnt_rn);

    		for (let i = 0; i < COUNT_HIGHNUM; i++) {
    			if (i < cnt_rn) {
    				$$invalidate(6, box_has_img[i] = true, box_has_img);
    			} else {
    				$$invalidate(6, box_has_img[i] = false, box_has_img);
    			}
    		}

    		
    		imgFn = BOX_SHPCOLOR_REPO[img_rn].img_fn;
    		$$invalidate(5, usr_resp = -1);
    		$$invalidate(0, ans_submit = false);
    	}

    	
    	init_shapes();

    	function submitted() {
    		$$invalidate(0, ans_submit = true);
    	}

    	
    	
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MA_A2> was created with unknown prop '${key}'`);
    	});

    	function npad_usr_select_binding(value) {
    		usr_resp = value;
    		$$invalidate(5, usr_resp);
    	}

    	const click_handler = () => submitted();
    	const click_handler_1 = () => init_shapes();
    	const click_handler_2 = () => skill_exit();

    	$$self.$capture_state = () => ({
    		NPad: Input_digitpad,
    		images,
    		c_ans,
    		w_ans,
    		ans_submit,
    		rerun,
    		usr_exit,
    		COUNT_LOWNUM,
    		COUNT_HIGHNUM,
    		cnt_rn,
    		img_rn,
    		c_ans_rn,
    		w_ans_rn,
    		correct_answer,
    		usr_resp,
    		clrLabel,
    		shpLabel,
    		imgFn,
    		box_has_img,
    		max_button,
    		init_shapes,
    		submitted,
    		skill_exit
    	});

    	$$self.$inject_state = $$props => {
    		if ("ans_submit" in $$props) $$invalidate(0, ans_submit = $$props.ans_submit);
    		if ("rerun" in $$props) rerun = $$props.rerun;
    		if ("usr_exit" in $$props) usr_exit = $$props.usr_exit;
    		if ("cnt_rn" in $$props) cnt_rn = $$props.cnt_rn;
    		if ("img_rn" in $$props) $$invalidate(1, img_rn = $$props.img_rn);
    		if ("c_ans_rn" in $$props) $$invalidate(2, c_ans_rn = $$props.c_ans_rn);
    		if ("w_ans_rn" in $$props) $$invalidate(3, w_ans_rn = $$props.w_ans_rn);
    		if ("correct_answer" in $$props) $$invalidate(4, correct_answer = $$props.correct_answer);
    		if ("usr_resp" in $$props) $$invalidate(5, usr_resp = $$props.usr_resp);
    		if ("clrLabel" in $$props) clrLabel = $$props.clrLabel;
    		if ("shpLabel" in $$props) shpLabel = $$props.shpLabel;
    		if ("imgFn" in $$props) imgFn = $$props.imgFn;
    		if ("box_has_img" in $$props) $$invalidate(6, box_has_img = $$props.box_has_img);
    		if ("max_button" in $$props) $$invalidate(7, max_button = $$props.max_button);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		ans_submit,
    		img_rn,
    		c_ans_rn,
    		w_ans_rn,
    		correct_answer,
    		usr_resp,
    		box_has_img,
    		max_button,
    		init_shapes,
    		submitted,
    		npad_usr_select_binding,
    		click_handler,
    		click_handler_1,
    		click_handler_2
    	];
    }

    class G1_MA_A2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1W, create_fragment$1W, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MA_A2",
    			options,
    			id: create_fragment$1W.name
    		});
    	}
    }

    let task01$1A = {
      heading : "",
      question: "",
      valueArray: [], 
      answer: 0, 
      operator: "+",
      columns: 0
    };

    let columns$h = 2;
    let maxValue$1b = 999;
    let minValue$1b = 100;


    function taskOne$1A() {
      task01$1A.heading = "Add two numbers up to three digits - word problems";
      task01$1A.answer = 0;
      task01$1A.columns = columns$h;
      task01$1A.valueArray = [];
          for (let i = 0; i < columns$h; i++) {
            task01$1A.valueArray[i] = Math.floor(Math.random() * (maxValue$1b - minValue$1b + 1) ) + minValue$1b; 
            task01$1A.answer += task01$1A.valueArray[i];        
          }
            while(task01$1A.answer > maxValue$1b){
                task01$1A.answer = 0;
            for (let i = 0; i < columns$h; i++) {
                task01$1A.valueArray[i] = Math.floor(Math.random() * (maxValue$1b - minValue$1b + 1) ) + minValue$1b; 
                task01$1A.answer += task01$1A.valueArray[i];        
            }
            }
      task01$1A.question = "Since he was hired, a chef has served "+task01$1A.valueArray[0]+" adults and "+task01$1A.valueArray[1]+" children. What is the total number of guests served?";
      return task01$1A;
    }

    /* src/components/taskComponents/GIII_MA_C3.svelte generated by Svelte v3.37.0 */
    const file$1U = "src/components/taskComponents/GIII_MA_C3.svelte";

    function create_fragment$1V(ctx) {
    	let div6;
    	let div5;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div4;
    	let div1;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let input;
    	let t4;
    	let div2;
    	let h5;
    	let t5;
    	let t6;
    	let solution;
    	let t7;
    	let div3;
    	let button0;
    	let t9;
    	let button1;
    	let t11;
    	let button2;
    	let current;
    	let mounted;
    	let dispose;

    	solution = new AdditionSolution({
    			props: {
    				num_qnty: /*task01*/ ctx[0].columns,
    				usr_resp: /*answer*/ ctx[1],
    				num: /*task01*/ ctx[0].valueArray,
    				ans_submit: /*showSolution*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div6 = element("div");
    			div5 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div4 = element("div");
    			div1 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			input = element("input");
    			t4 = space();
    			div2 = element("div");
    			h5 = element("h5");
    			t5 = text(/*showPopUp*/ ctx[3]);
    			t6 = space();
    			create_component(solution.$$.fragment);
    			t7 = space();
    			div3 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t9 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t11 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$1U, 51, 9, 1075);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1U, 50, 5, 1026);
    			add_location(h4, file$1U, 57, 11, 1247);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$1U, 58, 11, 1285);
    			add_location(div1, file$1U, 55, 7, 1228);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1U, 62, 11, 1427);
    			add_location(div2, file$1U, 61, 7, 1410);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1U, 66, 11, 1667);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1U, 67, 11, 1762);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1U, 68, 11, 1857);
    			attr_dev(div3, "class", "mt-3");
    			add_location(div3, file$1U, 65, 7, 1637);
    			attr_dev(div4, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div4, file$1U, 54, 5, 1157);
    			attr_dev(div5, "class", "shadow-sm  bg-white rounded");
    			add_location(div5, file$1U, 49, 4, 979);
    			attr_dev(div6, "class", "container mt-5");
    			add_location(div6, file$1U, 48, 1, 946);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div5);
    			append_dev(div5, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div5, t1);
    			append_dev(div5, div4);
    			append_dev(div4, div1);
    			append_dev(div1, h4);
    			append_dev(h4, t2);
    			append_dev(div1, t3);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div4, t4);
    			append_dev(div4, div2);
    			append_dev(div2, h5);
    			append_dev(h5, t5);
    			append_dev(div4, t6);
    			mount_component(solution, div4, null);
    			append_dev(div4, t7);
    			append_dev(div4, div3);
    			append_dev(div3, button0);
    			append_dev(div3, t9);
    			append_dev(div3, button1);
    			append_dev(div3, t11);
    			append_dev(div3, button2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[7]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*task01*/ 1) && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*task01*/ 1) && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (!current || dirty & /*showPopUp*/ 8) set_data_dev(t5, /*showPopUp*/ ctx[3]);

    			if (!current || dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}

    			const solution_changes = {};
    			if (dirty & /*task01*/ 1) solution_changes.num_qnty = /*task01*/ ctx[0].columns;
    			if (dirty & /*answer*/ 2) solution_changes.usr_resp = /*answer*/ ctx[1];
    			if (dirty & /*task01*/ 1) solution_changes.num = /*task01*/ ctx[0].valueArray;
    			if (dirty & /*showSolution*/ 16) solution_changes.ans_submit = /*showSolution*/ ctx[4];
    			solution.$set(solution_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div6);
    			destroy_component(solution);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1V.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1V($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GIII_MA_C3", slots, []);
    	let task01 = taskOne$1A();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			$$invalidate(2, showNext = "inline-block");
    			return;
    		} else {
    			$$invalidate(4, showSolution = true);
    			$$invalidate(3, showPopUp = randomWrong());
    			$$invalidate(2, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(4, showSolution = false);
    		$$invalidate(0, task01 = taskOne$1A());
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GIII_MA_C3> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1A,
    		randomCorrect,
    		randomWrong,
    		Solution: AdditionSolution,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) $$invalidate(4, showSolution = $$props.showSolution);
    		if ("CheckAnswer" in $$props) $$invalidate(5, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(6, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class GIII_MA_C3 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1V, create_fragment$1V, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GIII_MA_C3",
    			options,
    			id: create_fragment$1V.name
    		});
    	}
    }

    let task01$1z = {
      heading : "",
      question: "",
      valueArray: [], 
      answer: 0, 
      operator: "+",
      columns: 0
    };

    let columns$g = 2;
    let maxValue$1a = 9;
    let minValue$1a = 1;


    function taskOne$1z() {
      task01$1z.heading = "Addition word problems - one digit";
      task01$1z.question = "When Laura painted her house, she used 5 litres of white paint and 5 litres of brown paint. How many litres of paint did Laura use in all?";
      task01$1z.answer = 0;
      task01$1z.columns = columns$g;
      task01$1z.valueArray = [];
          for (let i = 0; i < columns$g; i++) {
            task01$1z.valueArray[i] = Math.floor(Math.random() * (maxValue$1a - minValue$1a + 1) ) + minValue$1a; 
            task01$1z.answer += task01$1z.valueArray[i];        
          }
            while(task01$1z.answer > maxValue$1a){
                task01$1z.answer = 0;
            for (let i = 0; i < columns$g; i++) {
                task01$1z.valueArray[i] = Math.floor(Math.random() * (maxValue$1a - minValue$1a + 1) ) + minValue$1a; 
                task01$1z.answer += task01$1z.valueArray[i];        
            }
            }
        task01$1z.question = "When Laura painted her house, she used "+task01$1z.valueArray[0]+" litres of white paint and "+task01$1z.valueArray[1]+" litres of brown paint. How many litres of paint did Laura use in all?";
      return task01$1z;
    }

    /* src/components/taskComponents/GII_MA_E10.svelte generated by Svelte v3.37.0 */
    const file$1T = "src/components/taskComponents/GII_MA_E10.svelte";

    function create_fragment$1U(ctx) {
    	let div6;
    	let div5;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div4;
    	let div1;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let input;
    	let t4;
    	let div2;
    	let h5;
    	let t5;
    	let t6;
    	let solution;
    	let t7;
    	let div3;
    	let button0;
    	let t9;
    	let button1;
    	let t11;
    	let button2;
    	let current;
    	let mounted;
    	let dispose;

    	solution = new AdditionSolution({
    			props: {
    				num_qnty: /*task01*/ ctx[0].columns,
    				usr_resp: /*answer*/ ctx[1],
    				num: /*task01*/ ctx[0].valueArray,
    				ans_submit: /*showSolution*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div6 = element("div");
    			div5 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div4 = element("div");
    			div1 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			input = element("input");
    			t4 = space();
    			div2 = element("div");
    			h5 = element("h5");
    			t5 = text(/*showPopUp*/ ctx[3]);
    			t6 = space();
    			create_component(solution.$$.fragment);
    			t7 = space();
    			div3 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t9 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t11 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$1T, 51, 9, 1075);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1T, 50, 5, 1026);
    			add_location(h4, file$1T, 57, 11, 1247);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$1T, 58, 11, 1285);
    			add_location(div1, file$1T, 55, 7, 1228);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1T, 62, 11, 1427);
    			add_location(div2, file$1T, 61, 7, 1410);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1T, 66, 11, 1667);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1T, 67, 11, 1762);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1T, 68, 11, 1857);
    			attr_dev(div3, "class", "mt-3");
    			add_location(div3, file$1T, 65, 7, 1637);
    			attr_dev(div4, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div4, file$1T, 54, 5, 1157);
    			attr_dev(div5, "class", "shadow-sm  bg-white rounded");
    			add_location(div5, file$1T, 49, 4, 979);
    			attr_dev(div6, "class", "container mt-5");
    			add_location(div6, file$1T, 48, 1, 946);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div5);
    			append_dev(div5, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div5, t1);
    			append_dev(div5, div4);
    			append_dev(div4, div1);
    			append_dev(div1, h4);
    			append_dev(h4, t2);
    			append_dev(div1, t3);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div4, t4);
    			append_dev(div4, div2);
    			append_dev(div2, h5);
    			append_dev(h5, t5);
    			append_dev(div4, t6);
    			mount_component(solution, div4, null);
    			append_dev(div4, t7);
    			append_dev(div4, div3);
    			append_dev(div3, button0);
    			append_dev(div3, t9);
    			append_dev(div3, button1);
    			append_dev(div3, t11);
    			append_dev(div3, button2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[7]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*task01*/ 1) && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*task01*/ 1) && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (!current || dirty & /*showPopUp*/ 8) set_data_dev(t5, /*showPopUp*/ ctx[3]);

    			if (!current || dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}

    			const solution_changes = {};
    			if (dirty & /*task01*/ 1) solution_changes.num_qnty = /*task01*/ ctx[0].columns;
    			if (dirty & /*answer*/ 2) solution_changes.usr_resp = /*answer*/ ctx[1];
    			if (dirty & /*task01*/ 1) solution_changes.num = /*task01*/ ctx[0].valueArray;
    			if (dirty & /*showSolution*/ 16) solution_changes.ans_submit = /*showSolution*/ ctx[4];
    			solution.$set(solution_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div6);
    			destroy_component(solution);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1U.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1U($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GII_MA_E10", slots, []);
    	let task01 = taskOne$1z();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			$$invalidate(2, showNext = "inline-block");
    			return;
    		} else {
    			$$invalidate(4, showSolution = true);
    			$$invalidate(3, showPopUp = randomWrong());
    			$$invalidate(2, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(4, showSolution = false);
    		$$invalidate(0, task01 = taskOne$1z());
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GII_MA_E10> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1z,
    		randomCorrect,
    		randomWrong,
    		Solution: AdditionSolution,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) $$invalidate(4, showSolution = $$props.showSolution);
    		if ("CheckAnswer" in $$props) $$invalidate(5, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(6, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class GII_MA_E10 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1U, create_fragment$1U, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GII_MA_E10",
    			options,
    			id: create_fragment$1U.name
    		});
    	}
    }

    let task01$1y = {    
        question: "Fill in the missing number.",
        displayValueOne: 0,
        displayValueTwo: 0,
        answer: 0,
        randomAnswer: 0,
        operators: ["-", "+"],
        operator : '',
        variation : 0
      };
      
      const maxValue$19 = 100000;
      const minValue$19 = 10000;


      function taskOne$1y() {
        task01$1y.variation = Math.floor(Math.random() * (task01$1y.operators.length));
          task01$1y.randomAnswer = Math.floor(Math.random() * (task01$1y.operators.length));
          task01$1y.displayValueOne = Math.floor(Math.random() * (maxValue$19 - minValue$19)) + minValue$19;
         
            task01$1y.operator = task01$1y.operators[task01$1y.randomAnswer];      
          if(task01$1y.operator == "-"){
            task01$1y.displayValueTwo = Math.floor(Math.random() * (task01$1y.displayValueOne - minValue$19)) + minValue$19;
            task01$1y.answer = task01$1y.displayValueOne - task01$1y.displayValueTwo;
          }else {
            task01$1y.displayValueTwo = task01$1y.displayValueOne + task01$1y.displayValueTwo;
            task01$1y.answer = task01$1y.displayValueOne + task01$1y.displayValueTwo;
          }

          
          return task01$1y;
      }

    /* src/components/taskComponents/GV_MA_B3.svelte generated by Svelte v3.37.0 */
    const file$1S = "src/components/taskComponents/GV_MA_B3.svelte";

    // (77:16) {:else}
    function create_else_block$1b(ctx) {
    	let input;
    	let t0;
    	let h4;
    	let t1_value = /*task01*/ ctx[0].operator + "";
    	let t1;
    	let t2;
    	let t3_value = /*task01*/ ctx[0].displayValueTwo + "";
    	let t3;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");
    			t0 = space();
    			h4 = element("h4");
    			t1 = text(t1_value);
    			t2 = space();
    			t3 = text(t3_value);
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$1S, 78, 16, 1947);
    			add_location(h4, file$1S, 79, 16, 2045);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*answer*/ ctx[1]);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, h4, anchor);
    			append_dev(h4, t1);
    			append_dev(h4, t2);
    			append_dev(h4, t3);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", /*input_input_handler_1*/ ctx[7]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t1, t1_value);
    			if (dirty & /*task01*/ 1 && t3_value !== (t3_value = /*task01*/ ctx[0].displayValueTwo + "")) set_data_dev(t3, t3_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(h4);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1b.name,
    		type: "else",
    		source: "(77:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (73:12) {#if task01.variation == 0}
    function create_if_block$1h(ctx) {
    	let h4;
    	let t0_value = /*task01*/ ctx[0].displayValueOne + "";
    	let t0;
    	let t1;
    	let t2_value = /*task01*/ ctx[0].operator + "";
    	let t2;
    	let t3;
    	let input;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			h4 = element("h4");
    			t0 = text(t0_value);
    			t1 = space();
    			t2 = text(t2_value);
    			t3 = space();
    			input = element("input");
    			set_style(h4, "padding-left", "16px");
    			add_location(h4, file$1S, 73, 20, 1641);
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$1S, 74, 40, 1768);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h4, anchor);
    			append_dev(h4, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*answer*/ ctx[1]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[6]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].displayValueOne + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h4);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(input);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1h.name,
    		type: "if",
    		source: "(73:12) {#if task01.variation == 0}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1T(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h20;
    	let t1;
    	let div5;
    	let div2;
    	let h21;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let t4;
    	let hr;
    	let t5;
    	let h4;
    	let t6_value = /*task01*/ ctx[0].answer + "";
    	let t6;
    	let t7;
    	let div3;
    	let h5;
    	let t8;
    	let t9;
    	let div4;
    	let button0;
    	let t11;
    	let button1;
    	let t13;
    	let button2;
    	let mounted;
    	let dispose;

    	function select_block_type(ctx, dirty) {
    		if (/*task01*/ ctx[0].variation == 0) return create_if_block$1h;
    		return create_else_block$1b;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h20 = element("h2");
    			h20.textContent = "Complete addition and subtraction sentences";
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h21 = element("h2");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			if_block.c();
    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			h4 = element("h4");
    			t6 = text(t6_value);
    			t7 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t8 = text(/*showPopUp*/ ctx[3]);
    			t9 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t11 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t13 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h20, "class", "text-center display-4 mb-0");
    			add_location(h20, file$1S, 62, 10, 1290);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1S, 61, 6, 1240);
    			add_location(h21, file$1S, 67, 12, 1493);
    			add_location(hr, file$1S, 82, 16, 2135);
    			add_location(h4, file$1S, 83, 12, 2152);
    			add_location(div1, file$1S, 68, 12, 1532);
    			add_location(div2, file$1S, 66, 8, 1474);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1S, 88, 12, 2244);
    			add_location(div3, file$1S, 87, 8, 2226);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1S, 92, 12, 2375);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1S, 93, 12, 2471);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1S, 94, 12, 2567);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$1S, 91, 8, 2344);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$1S, 65, 6, 1402);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$1S, 60, 5, 1192);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$1S, 59, 1, 1158);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h20);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h21);
    			append_dev(h21, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			if_block.m(div1, null);
    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, h4);
    			append_dev(h4, t6);
    			append_dev(div5, t7);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t11);
    			append_dev(div4, button1);
    			append_dev(div4, t13);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div1, t4);
    				}
    			}

    			if (dirty & /*task01*/ 1 && t6_value !== (t6_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t8, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1T.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1T($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GV_MA_B3", slots, []);
    	let task01 = taskOne$1y();
    	let answer;
    	let showNext = "none";
    	let showPopUp;

    	let CheckAnswer = function () {
    		if (task01.variation == 1) {
    			if (answer == task01.displayValueOne) {
    				$$invalidate(3, showPopUp = randomCorrect());
    				$$invalidate(2, showNext = "inline-block");
    				return;
    			} else {
    				$$invalidate(3, showPopUp = randomWrong());
    				$$invalidate(2, showNext = "inline-block");
    			}
    		} else {
    			if (answer == task01.displayValueTwo) {
    				$$invalidate(3, showPopUp = randomCorrect());
    				$$invalidate(2, showNext = "inline-block");
    				return;
    			} else {
    				$$invalidate(3, showPopUp = randomWrong());
    				$$invalidate(2, showNext = "inline-block");
    			}
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$1y());
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GV_MA_B3> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	function input_input_handler_1() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1y,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler,
    		input_input_handler_1
    	];
    }

    class GV_MA_B3 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1T, create_fragment$1T, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GV_MA_B3",
    			options,
    			id: create_fragment$1T.name
    		});
    	}
    }

    let task01$1x = {
      heading : "",
      question: "Type the missing digit:",
      valueArray: [],
      answer: [],
      operator: "+",
      displayValues:[],
      columns: 0
    };

    let columns$f = 0;
    let maxValue$18 = 0;
    let minValue$18 = 0;
    let heading$4 = "";
    let question$4 = "";
    let maxInputs$a = 2;


    function MaxandMin$4(max, min,col,headingtext,qst, maxinput) {
      minValue$18 = min;
      maxValue$18 = max;
      columns$f = col;
      heading$4 = headingtext;
      question$4 = qst; 
      maxInputs$a = maxinput;
    }

    function taskOne$1x() {

      task01$1x.heading = heading$4;
      task01$1x.question = question$4;
      task01$1x.answer = [];
      task01$1x.columns = columns$f;
      task01$1x.valueArray = [];
      task01$1x.displayValues = [];
     
      let sum = 0;
      for (let i = 0; i < columns$f; i++) {
        task01$1x.valueArray[i] = Math.floor(Math.random() * (maxValue$18 - minValue$18 + 1) ) + minValue$18; 
        sum += task01$1x.valueArray[i];   
      }
      sum.toString().split('');
     
      
      let tempArray = [];

      task01$1x.valueArray.forEach(element => {    
        task01$1x.displayValues.push(element.toString().split('').reverse());
      });

      task01$1x.displayValues.push(sum.toString().split('').reverse());

      for (let index = 0; index < task01$1x.displayValues.length; index++) {
        tempArray[index] = [...task01$1x.displayValues[index]];    
      }
      
      let tempRandom = 0;
      let tempRandomInput = 0; 
      
     
      for (let index = 0; index < maxInputs$a; index++) {      
      tempRandom = Math.floor(Math.random() * task01$1x.displayValues.length);
      tempRandomInput = Math.floor(Math.random() * task01$1x.displayValues[tempRandom].length);
        if(task01$1x.displayValues[tempRandom][tempRandomInput] == 'i'){
          while(task01$1x.displayValues[tempRandom][tempRandomInput] == 'i'){              
            tempRandom = Math.floor(Math.random() * task01$1x.displayValues.length);
            tempRandomInput = Math.floor(Math.random() * task01$1x.displayValues[tempRandom].length);      
          }
          
          task01$1x.displayValues[tempRandom][tempRandomInput] = 'i'; 
        
        }else {     
          task01$1x.displayValues[tempRandom][tempRandomInput] = 'i';   
          
        }
      }

      
    let tempId = 0;
      for (let i = 0; i <  task01$1x.displayValues.length; i++) {
        
          for (let j = 0; j <  task01$1x.displayValues[i].length; j++) {

              if(task01$1x.displayValues[i][j] == 'i'){
                task01$1x.displayValues[i][j] = ('i'+tempId);
                tempId++;
                task01$1x.answer.push(tempArray[i][j]);
              }
            
          }
      }

      return task01$1x;
    }

    /* src/components/taskComponents/GIII_MA_C4.svelte generated by Svelte v3.37.0 */
    const file$1R = "src/components/taskComponents/GIII_MA_C4.svelte";

    function get_each_context$1x(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	child_ctx[15] = i;
    	return child_ctx;
    }

    function get_each_context_2$d(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	child_ctx[19] = list;
    	child_ctx[20] = i;
    	return child_ctx;
    }

    function get_each_context_1$u(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	child_ctx[17] = list;
    	child_ctx[18] = i;
    	return child_ctx;
    }

    // (87:27) {:else}
    function create_else_block_1$9(ctx) {
    	let tr;
    	let t;
    	let each_value_2 = /*value*/ ctx[13];
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$d(get_each_context_2$d(ctx, each_value_2, i));
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			attr_dev(tr, "class", "tablerow");
    			add_location(tr, file$1R, 87, 27, 2606);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			append_dev(tr, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*answer, task01*/ 3) {
    				each_value_2 = /*value*/ ctx[13];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$d(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_2$d(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, t);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_2.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$9.name,
    		type: "else",
    		source: "(87:27) {:else}",
    		ctx
    	});

    	return block;
    }

    // (75:23) {#if i == (task01.displayValues.length-1)}
    function create_if_block$1g(ctx) {
    	let hr;
    	let t0;
    	let tr;
    	let t1;
    	let each_value_1 = /*value*/ ctx[13];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$u(get_each_context_1$u(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			hr = element("hr");
    			t0 = space();
    			tr = element("tr");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			add_location(hr, file$1R, 75, 23, 2025);
    			attr_dev(tr, "class", "tablerow");
    			add_location(tr, file$1R, 76, 23, 2053);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, hr, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, tr, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*answer, task01*/ 3) {
    				each_value_1 = /*value*/ ctx[13];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$u(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$u(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, t1);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(hr);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(tr);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1g.name,
    		type: "if",
    		source: "(75:23) {#if i == (task01.displayValues.length-1)}",
    		ctx
    	});

    	return block;
    }

    // (93:28) {:else}
    function create_else_block_2$9(ctx) {
    	let td;
    	let t_value = /*val*/ ctx[16] + "";
    	let t;

    	const block = {
    		c: function create() {
    			td = element("td");
    			t = text(t_value);
    			attr_dev(td, "align", "right");
    			add_location(td, file$1R, 93, 32, 2953);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*val*/ ctx[16] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$9.name,
    		type: "else",
    		source: "(93:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (91:28) {#if val[0] == 'i'}
    function create_if_block_2$i(ctx) {
    	let td;
    	let input;
    	let mounted;
    	let dispose;

    	function input_input_handler_1() {
    		/*input_input_handler_1*/ ctx[7].call(input, /*val*/ ctx[16]);
    	}

    	const block = {
    		c: function create() {
    			td = element("td");
    			input = element("input");
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "style", " width : 30px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$1R, 91, 46, 2772);
    			attr_dev(td, "align", "right");
    			add_location(td, file$1R, 91, 28, 2754);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, input);
    			set_input_value(input, /*answer*/ ctx[1][/*val*/ ctx[16][1]]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler_1);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*answer, task01*/ 3 && input.value !== /*answer*/ ctx[1][/*val*/ ctx[16][1]]) {
    				set_input_value(input, /*answer*/ ctx[1][/*val*/ ctx[16][1]]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$i.name,
    		type: "if",
    		source: "(91:28) {#if val[0] == 'i'}",
    		ctx
    	});

    	return block;
    }

    // (89:28) {#each value as val}
    function create_each_block_2$d(ctx) {
    	let if_block_anchor;

    	function select_block_type_2(ctx, dirty) {
    		if (/*val*/ ctx[16][0] == "i") return create_if_block_2$i;
    		return create_else_block_2$9;
    	}

    	let current_block_type = select_block_type_2(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$d.name,
    		type: "each",
    		source: "(89:28) {#each value as val}",
    		ctx
    	});

    	return block;
    }

    // (82:24) {:else}
    function create_else_block$1a(ctx) {
    	let td;
    	let t_value = /*val*/ ctx[16] + "";
    	let t;

    	const block = {
    		c: function create() {
    			td = element("td");
    			t = text(t_value);
    			attr_dev(td, "align", "right");
    			add_location(td, file$1R, 82, 28, 2403);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*val*/ ctx[16] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1a.name,
    		type: "else",
    		source: "(82:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (80:24) {#if val[0] == 'i'}
    function create_if_block_1$i(ctx) {
    	let td;
    	let input;
    	let mounted;
    	let dispose;

    	function input_input_handler() {
    		/*input_input_handler*/ ctx[6].call(input, /*val*/ ctx[16]);
    	}

    	const block = {
    		c: function create() {
    			td = element("td");
    			input = element("input");
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "style", " width : 30px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$1R, 80, 42, 2230);
    			attr_dev(td, "align", "right");
    			add_location(td, file$1R, 80, 24, 2212);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, input);
    			set_input_value(input, /*answer*/ ctx[1][/*val*/ ctx[16][1]]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*answer, task01*/ 3 && input.value !== /*answer*/ ctx[1][/*val*/ ctx[16][1]]) {
    				set_input_value(input, /*answer*/ ctx[1][/*val*/ ctx[16][1]]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$i.name,
    		type: "if",
    		source: "(80:24) {#if val[0] == 'i'}",
    		ctx
    	});

    	return block;
    }

    // (78:24) {#each value as val}
    function create_each_block_1$u(ctx) {
    	let if_block_anchor;

    	function select_block_type_1(ctx, dirty) {
    		if (/*val*/ ctx[16][0] == "i") return create_if_block_1$i;
    		return create_else_block$1a;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$u.name,
    		type: "each",
    		source: "(78:24) {#each value as val}",
    		ctx
    	});

    	return block;
    }

    // (73:20) {#each task01.displayValues as value , i}
    function create_each_block$1x(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[15] == /*task01*/ ctx[0].displayValues.length - 1) return create_if_block$1g;
    		return create_else_block_1$9;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1x.name,
    		type: "each",
    		source: "(73:20) {#each task01.displayValues as value , i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1S(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h20;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h21;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let div3;
    	let h5;
    	let t5;
    	let t6;
    	let div4;
    	let button0;
    	let t8;
    	let button1;
    	let t10;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].displayValues;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1x(get_each_context$1x(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h20 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h21 = element("h2");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t5 = text(/*showPopUp*/ ctx[3]);
    			t6 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t8 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t10 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h20, "class", "text-center display-4 mb-0");
    			add_location(h20, file$1R, 62, 10, 1515);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1R, 61, 6, 1465);
    			add_location(h21, file$1R, 67, 12, 1691);
    			attr_dev(table, "width", "100");
    			add_location(table, file$1R, 70, 16, 1771);
    			add_location(div1, file$1R, 68, 12, 1730);
    			add_location(div2, file$1R, 66, 8, 1672);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1R, 105, 12, 3283);
    			add_location(div3, file$1R, 104, 8, 3265);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1R, 111, 12, 3422);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1R, 112, 12, 3518);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1R, 113, 12, 3614);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$1R, 110, 8, 3391);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$1R, 65, 6, 1600);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$1R, 60, 5, 1417);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$1R, 59, 1, 1383);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h20);
    			append_dev(h20, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h21);
    			append_dev(h21, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div5, t4);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t5);
    			append_dev(div5, t6);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t8);
    			append_dev(div4, button1);
    			append_dev(div4, t10);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01, answer*/ 3) {
    				each_value = /*task01*/ ctx[0].displayValues;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1x(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1x(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*showPopUp*/ 8) set_data_dev(t5, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1S.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const max$v = 999;
    const min$v = 100;
    const maxInputs$9 = 2;
    const numberofColumn$t = 2;

    function instance$1S($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GIII_MA_C4", slots, []);
    	let question = "Add :";
    	let heading = "Complete the addition sentence - sums up to 10";
    	let showSolution = false;
    	let maxandmin = MaxandMin$4(max$v, min$v, numberofColumn$t, heading, question, maxInputs$9);
    	let task01 = taskOne$1x();
    	let answer = [];
    	let showNext = "none";
    	let showPopUp;
    	let tempString = "";

    	let CheckAnswer = function () {
    		for (let index = 0; index < task01.answer.length; index++) {
    			if (answer[index] != task01.answer[index]) {
    				$$invalidate(3, showPopUp = randomWrong());
    				$$invalidate(2, showNext = "inline-block");
    				showSolution = true;
    				return;
    			} else {
    				$$invalidate(3, showPopUp = randomCorrect());
    				$$invalidate(2, showNext = "inline-block");
    			}
    		}
    	};

    	let NextQuestion = function () {
    		showSolution = false;
    		$$invalidate(1, answer = []);
    		$$invalidate(0, task01 = taskOne$1x());
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GIII_MA_C4> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler(val) {
    		answer[val[1]] = this.value;
    		$$invalidate(1, answer);
    		$$invalidate(0, task01);
    	}

    	function input_input_handler_1(val) {
    		answer[val[1]] = this.value;
    		$$invalidate(1, answer);
    		$$invalidate(0, task01);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1x,
    		randomCorrect,
    		randomWrong,
    		MaxandMin: MaxandMin$4,
    		question,
    		heading,
    		max: max$v,
    		min: min$v,
    		maxInputs: maxInputs$9,
    		numberofColumn: numberofColumn$t,
    		showSolution,
    		maxandmin,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		tempString,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("question" in $$props) question = $$props.question;
    		if ("heading" in $$props) heading = $$props.heading;
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("maxandmin" in $$props) maxandmin = $$props.maxandmin;
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("tempString" in $$props) tempString = $$props.tempString;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler,
    		input_input_handler_1
    	];
    }

    class GIII_MA_C4 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1S, create_fragment$1S, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GIII_MA_C4",
    			options,
    			id: create_fragment$1S.name
    		});
    	}
    }

    /* src/components/taskComponents/GII_MA_E11.svelte generated by Svelte v3.37.0 */
    const file$1Q = "src/components/taskComponents/GII_MA_E11.svelte";

    function get_each_context$1w(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	child_ctx[15] = i;
    	return child_ctx;
    }

    function get_each_context_2$c(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	child_ctx[19] = list;
    	child_ctx[20] = i;
    	return child_ctx;
    }

    function get_each_context_1$t(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	child_ctx[17] = list;
    	child_ctx[18] = i;
    	return child_ctx;
    }

    // (87:27) {:else}
    function create_else_block_1$8(ctx) {
    	let tr;
    	let t;
    	let each_value_2 = /*value*/ ctx[13];
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$c(get_each_context_2$c(ctx, each_value_2, i));
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			attr_dev(tr, "class", "tablerow");
    			add_location(tr, file$1Q, 87, 27, 2621);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			append_dev(tr, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*answer, task01*/ 3) {
    				each_value_2 = /*value*/ ctx[13];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$c(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_2$c(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, t);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_2.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$8.name,
    		type: "else",
    		source: "(87:27) {:else}",
    		ctx
    	});

    	return block;
    }

    // (75:23) {#if i == (task01.displayValues.length-1)}
    function create_if_block$1f(ctx) {
    	let hr;
    	let t0;
    	let tr;
    	let t1;
    	let each_value_1 = /*value*/ ctx[13];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$t(get_each_context_1$t(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			hr = element("hr");
    			t0 = space();
    			tr = element("tr");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			add_location(hr, file$1Q, 75, 23, 2040);
    			attr_dev(tr, "class", "tablerow");
    			add_location(tr, file$1Q, 76, 23, 2068);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, hr, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, tr, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*answer, task01*/ 3) {
    				each_value_1 = /*value*/ ctx[13];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$t(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$t(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, t1);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(hr);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(tr);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1f.name,
    		type: "if",
    		source: "(75:23) {#if i == (task01.displayValues.length-1)}",
    		ctx
    	});

    	return block;
    }

    // (93:28) {:else}
    function create_else_block_2$8(ctx) {
    	let td;
    	let t_value = /*val*/ ctx[16] + "";
    	let t;

    	const block = {
    		c: function create() {
    			td = element("td");
    			t = text(t_value);
    			attr_dev(td, "align", "right");
    			add_location(td, file$1Q, 93, 32, 2968);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*val*/ ctx[16] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$8.name,
    		type: "else",
    		source: "(93:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (91:28) {#if val[0] == 'i'}
    function create_if_block_2$h(ctx) {
    	let td;
    	let input;
    	let mounted;
    	let dispose;

    	function input_input_handler_1() {
    		/*input_input_handler_1*/ ctx[7].call(input, /*val*/ ctx[16]);
    	}

    	const block = {
    		c: function create() {
    			td = element("td");
    			input = element("input");
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "style", " width : 30px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$1Q, 91, 46, 2787);
    			attr_dev(td, "align", "right");
    			add_location(td, file$1Q, 91, 28, 2769);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, input);
    			set_input_value(input, /*answer*/ ctx[1][/*val*/ ctx[16][1]]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler_1);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*answer, task01*/ 3 && input.value !== /*answer*/ ctx[1][/*val*/ ctx[16][1]]) {
    				set_input_value(input, /*answer*/ ctx[1][/*val*/ ctx[16][1]]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$h.name,
    		type: "if",
    		source: "(91:28) {#if val[0] == 'i'}",
    		ctx
    	});

    	return block;
    }

    // (89:28) {#each value as val}
    function create_each_block_2$c(ctx) {
    	let if_block_anchor;

    	function select_block_type_2(ctx, dirty) {
    		if (/*val*/ ctx[16][0] == "i") return create_if_block_2$h;
    		return create_else_block_2$8;
    	}

    	let current_block_type = select_block_type_2(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$c.name,
    		type: "each",
    		source: "(89:28) {#each value as val}",
    		ctx
    	});

    	return block;
    }

    // (82:24) {:else}
    function create_else_block$19(ctx) {
    	let td;
    	let t_value = /*val*/ ctx[16] + "";
    	let t;

    	const block = {
    		c: function create() {
    			td = element("td");
    			t = text(t_value);
    			attr_dev(td, "align", "right");
    			add_location(td, file$1Q, 82, 28, 2418);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*val*/ ctx[16] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$19.name,
    		type: "else",
    		source: "(82:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (80:24) {#if val[0] == 'i'}
    function create_if_block_1$h(ctx) {
    	let td;
    	let input;
    	let mounted;
    	let dispose;

    	function input_input_handler() {
    		/*input_input_handler*/ ctx[6].call(input, /*val*/ ctx[16]);
    	}

    	const block = {
    		c: function create() {
    			td = element("td");
    			input = element("input");
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "style", " width : 30px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$1Q, 80, 42, 2245);
    			attr_dev(td, "align", "right");
    			add_location(td, file$1Q, 80, 24, 2227);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, input);
    			set_input_value(input, /*answer*/ ctx[1][/*val*/ ctx[16][1]]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*answer, task01*/ 3 && input.value !== /*answer*/ ctx[1][/*val*/ ctx[16][1]]) {
    				set_input_value(input, /*answer*/ ctx[1][/*val*/ ctx[16][1]]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$h.name,
    		type: "if",
    		source: "(80:24) {#if val[0] == 'i'}",
    		ctx
    	});

    	return block;
    }

    // (78:24) {#each value as val}
    function create_each_block_1$t(ctx) {
    	let if_block_anchor;

    	function select_block_type_1(ctx, dirty) {
    		if (/*val*/ ctx[16][0] == "i") return create_if_block_1$h;
    		return create_else_block$19;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$t.name,
    		type: "each",
    		source: "(78:24) {#each value as val}",
    		ctx
    	});

    	return block;
    }

    // (73:20) {#each task01.displayValues as value , i}
    function create_each_block$1w(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[15] == /*task01*/ ctx[0].displayValues.length - 1) return create_if_block$1f;
    		return create_else_block_1$8;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1w.name,
    		type: "each",
    		source: "(73:20) {#each task01.displayValues as value , i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1R(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h20;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h21;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let div3;
    	let h5;
    	let t5;
    	let t6;
    	let div4;
    	let button0;
    	let t8;
    	let button1;
    	let t10;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].displayValues;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1w(get_each_context$1w(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h20 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h21 = element("h2");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t5 = text(/*showPopUp*/ ctx[3]);
    			t6 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t8 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t10 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h20, "class", "text-center display-4 mb-0");
    			add_location(h20, file$1Q, 62, 10, 1530);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1Q, 61, 6, 1480);
    			add_location(h21, file$1Q, 67, 12, 1706);
    			attr_dev(table, "width", "100");
    			add_location(table, file$1Q, 70, 16, 1786);
    			add_location(div1, file$1Q, 68, 12, 1745);
    			add_location(div2, file$1Q, 66, 8, 1687);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1Q, 105, 12, 3298);
    			add_location(div3, file$1Q, 104, 8, 3280);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1Q, 111, 12, 3437);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1Q, 112, 12, 3533);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1Q, 113, 12, 3629);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$1Q, 110, 8, 3406);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$1Q, 65, 6, 1615);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$1Q, 60, 5, 1432);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$1Q, 59, 1, 1398);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h20);
    			append_dev(h20, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h21);
    			append_dev(h21, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div5, t4);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t5);
    			append_dev(div5, t6);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t8);
    			append_dev(div4, button1);
    			append_dev(div4, t10);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01, answer*/ 3) {
    				each_value = /*task01*/ ctx[0].displayValues;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1w(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1w(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*showPopUp*/ 8) set_data_dev(t5, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1R.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const max$u = 10;
    const min$u = 0;
    const maxInputs$8 = 1;
    const numberofColumn$s = 2;

    function instance$1R($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GII_MA_E11", slots, []);
    	let question = "Fill in the missing number.";
    	let heading = "Complete the addition sentence - one digit";
    	let showSolution = false;
    	let maxandmin = MaxandMin$4(max$u, min$u, numberofColumn$s, heading, question, maxInputs$8);
    	let task01 = taskOne$1x();
    	let answer = [];
    	let showNext = "none";
    	let showPopUp;
    	let tempString = "";

    	let CheckAnswer = function () {
    		for (let index = 0; index < task01.answer.length; index++) {
    			if (answer[index] != task01.answer[index]) {
    				$$invalidate(3, showPopUp = randomWrong());
    				$$invalidate(2, showNext = "inline-block");
    				showSolution = true;
    				return;
    			} else {
    				$$invalidate(3, showPopUp = randomCorrect());
    				$$invalidate(2, showNext = "inline-block");
    			}
    		}
    	};

    	let NextQuestion = function () {
    		showSolution = false;
    		$$invalidate(1, answer = []);
    		$$invalidate(0, task01 = taskOne$1x());
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GII_MA_E11> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler(val) {
    		answer[val[1]] = this.value;
    		$$invalidate(1, answer);
    		$$invalidate(0, task01);
    	}

    	function input_input_handler_1(val) {
    		answer[val[1]] = this.value;
    		$$invalidate(1, answer);
    		$$invalidate(0, task01);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1x,
    		randomCorrect,
    		randomWrong,
    		MaxandMin: MaxandMin$4,
    		question,
    		heading,
    		max: max$u,
    		min: min$u,
    		maxInputs: maxInputs$8,
    		numberofColumn: numberofColumn$s,
    		showSolution,
    		maxandmin,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		tempString,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("question" in $$props) question = $$props.question;
    		if ("heading" in $$props) heading = $$props.heading;
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("maxandmin" in $$props) maxandmin = $$props.maxandmin;
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("tempString" in $$props) tempString = $$props.tempString;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler,
    		input_input_handler_1
    	];
    }

    class GII_MA_E11 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1R, create_fragment$1R, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GII_MA_E11",
    			options,
    			id: create_fragment$1R.name
    		});
    	}
    }

    let task01$1w = {    
        question: "Type the missing digit:",
        ValueOne: 0,
        ValueTwo: 0,
        ValueThree: 0,
        answer: 0,
        randomAnswer: 0,
        operators: ["-", "+"],
        operator : '',
        displayValues : {
            one : [],
            two : [],
            three : []
        }
      };

      const maxValue$17 = 10000;
      const minValue$17 = 100;
      
      function taskOne$1w() {
          task01$1w.randomAnswer = Math.floor(Math.random() * (task01$1w.operators.length));
          task01$1w.ValueOne = Math.floor(Math.random() * (maxValue$17 - minValue$17)) + minValue$17;
        
          task01$1w.operator = task01$1w.operators[task01$1w.randomAnswer];      
          if(task01$1w.operator == "-"){
            task01$1w.ValueTwo = Math.floor(Math.random() * (task01$1w.ValueOne - minValue$17)) + minValue$17;
            task01$1w.ValueThree = task01$1w.ValueOne - task01$1w.ValueTwo;
          }
          else if(task01$1w.operator == "+"){     
            task01$1w.ValueTwo = Math.floor(Math.random() * (maxValue$17 - minValue$17)) + minValue$17;   
            task01$1w.ValueThree = task01$1w.ValueOne + task01$1w.ValueTwo;     
          }


          task01$1w.displayValues.one = Array.from(task01$1w.ValueOne.toString());
          task01$1w.displayValues.two = Array.from(task01$1w.ValueTwo.toString());
          task01$1w.displayValues.three = Array.from(task01$1w.ValueThree.toString());

          let randomValue = Math.floor(Math.random() * 3);

          if(randomValue == 0){
            let randomInput = Math.floor(Math.random() * task01$1w.displayValues.one.length);
            task01$1w.answer =  task01$1w.displayValues.one[randomInput];
            task01$1w.displayValues.one[randomInput] = 'input';
          }else if(randomValue == 1){
            let randomInput = Math.floor(Math.random() * task01$1w.displayValues.two.length);
            task01$1w.answer =  task01$1w.displayValues.two[randomInput];
            task01$1w.displayValues.two[randomInput] = 'input';
          }else if(randomValue == 2){       
            let randomInput = Math.floor(Math.random() * task01$1w.displayValues.three.length);
            task01$1w.answer =  task01$1w.displayValues.three[randomInput];
            task01$1w.displayValues.three[randomInput] = 'input';
          }

          return task01$1w;
      }

    /* src/components/taskComponents/GV_MA_B4.svelte generated by Svelte v3.37.0 */
    const file$1P = "src/components/taskComponents/GV_MA_B4.svelte";

    function get_each_context$1v(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	child_ctx[11] = i;
    	return child_ctx;
    }

    function get_each_context_1$s(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	child_ctx[11] = i;
    	return child_ctx;
    }

    function get_each_context_2$b(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	child_ctx[11] = i;
    	return child_ctx;
    }

    // (66:32) {:else}
    function create_else_block_2$7(ctx) {
    	let h5;
    	let t_value = /*value*/ ctx[9] + "";
    	let t;

    	const block = {
    		c: function create() {
    			h5 = element("h5");
    			t = text(t_value);
    			attr_dev(h5, "style", "display: inline-block; width : 30px; text-align: center;");
    			add_location(h5, file$1P, 66, 32, 1667);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h5, anchor);
    			append_dev(h5, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*value*/ ctx[9] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h5);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$7.name,
    		type: "else",
    		source: "(66:32) {:else}",
    		ctx
    	});

    	return block;
    }

    // (64:28) {#if task01.displayValues.one[i] === 'input'}
    function create_if_block_2$g(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "style", "width : 30px;");
    			attr_dev(input, "maxlength", "1");
    			add_location(input, file$1P, 64, 28, 1486);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*answer*/ ctx[1]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[6]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$g.name,
    		type: "if",
    		source: "(64:28) {#if task01.displayValues.one[i] === 'input'}",
    		ctx
    	});

    	return block;
    }

    // (63:24) {#each task01.displayValues.one as value,i}
    function create_each_block_2$b(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*task01*/ ctx[0].displayValues.one[/*i*/ ctx[11]] === "input") return create_if_block_2$g;
    		return create_else_block_2$7;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$b.name,
    		type: "each",
    		source: "(63:24) {#each task01.displayValues.one as value,i}",
    		ctx
    	});

    	return block;
    }

    // (85:32) {:else}
    function create_else_block_1$7(ctx) {
    	let h5;
    	let t_value = /*value*/ ctx[9] + "";
    	let t;

    	const block = {
    		c: function create() {
    			h5 = element("h5");
    			t = text(t_value);
    			attr_dev(h5, "style", "display: inline-block; width : 30px; text-align: center;");
    			add_location(h5, file$1P, 85, 32, 2557);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h5, anchor);
    			append_dev(h5, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*value*/ ctx[9] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h5);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$7.name,
    		type: "else",
    		source: "(85:32) {:else}",
    		ctx
    	});

    	return block;
    }

    // (83:28) {#if task01.displayValues.two[i] === 'input'}
    function create_if_block_1$g(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "style", "width : 30px;");
    			attr_dev(input, "maxlength", "1");
    			add_location(input, file$1P, 83, 32, 2375);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*answer*/ ctx[1]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", /*input_input_handler_1*/ ctx[7]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$g.name,
    		type: "if",
    		source: "(83:28) {#if task01.displayValues.two[i] === 'input'}",
    		ctx
    	});

    	return block;
    }

    // (82:24) {#each task01.displayValues.two as value,i}
    function create_each_block_1$s(ctx) {
    	let if_block_anchor;

    	function select_block_type_1(ctx, dirty) {
    		if (/*task01*/ ctx[0].displayValues.two[/*i*/ ctx[11]] === "input") return create_if_block_1$g;
    		return create_else_block_1$7;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$s.name,
    		type: "each",
    		source: "(82:24) {#each task01.displayValues.two as value,i}",
    		ctx
    	});

    	return block;
    }

    // (102:32) {:else}
    function create_else_block$18(ctx) {
    	let h5;
    	let t_value = /*value*/ ctx[9] + "";
    	let t;

    	const block = {
    		c: function create() {
    			h5 = element("h5");
    			t = text(t_value);
    			attr_dev(h5, "style", "display: inline-block; width : 30px; text-align: center;");
    			add_location(h5, file$1P, 102, 32, 3310);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h5, anchor);
    			append_dev(h5, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*value*/ ctx[9] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h5);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$18.name,
    		type: "else",
    		source: "(102:32) {:else}",
    		ctx
    	});

    	return block;
    }

    // (100:28) {#if task01.displayValues.three[i] === 'input'}
    function create_if_block$1e(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "style", "width : 30px;");
    			attr_dev(input, "maxlength", "1");
    			add_location(input, file$1P, 100, 28, 3160);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*answer*/ ctx[1]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", /*input_input_handler_2*/ ctx[8]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1e.name,
    		type: "if",
    		source: "(100:28) {#if task01.displayValues.three[i] === 'input'}",
    		ctx
    	});

    	return block;
    }

    // (99:24) {#each task01.displayValues.three as value,i}
    function create_each_block$1v(ctx) {
    	let if_block_anchor;

    	function select_block_type_2(ctx, dirty) {
    		if (/*task01*/ ctx[0].displayValues.three[/*i*/ ctx[11]] === "input") return create_if_block$1e;
    		return create_else_block$18;
    	}

    	let current_block_type = select_block_type_2(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1v.name,
    		type: "each",
    		source: "(99:24) {#each task01.displayValues.three as value,i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1Q(ctx) {
    	let div13;
    	let div12;
    	let div0;
    	let h20;
    	let t1;
    	let div11;
    	let div8;
    	let h21;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div7;
    	let div2;
    	let div1;
    	let t4;
    	let div4;
    	let h50;
    	let t5_value = /*task01*/ ctx[0].operator + "";
    	let t5;
    	let t6;
    	let div3;
    	let t7;
    	let div6;
    	let div5;
    	let t8;
    	let h6;
    	let t9_value = /*task01*/ ctx[0].answer + "";
    	let t9;
    	let t10;
    	let div9;
    	let h51;
    	let t11;
    	let t12;
    	let div10;
    	let button0;
    	let t14;
    	let button1;
    	let t16;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value_2 = /*task01*/ ctx[0].displayValues.one;
    	validate_each_argument(each_value_2);
    	let each_blocks_2 = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks_2[i] = create_each_block_2$b(get_each_context_2$b(ctx, each_value_2, i));
    	}

    	let each_value_1 = /*task01*/ ctx[0].displayValues.two;
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1$s(get_each_context_1$s(ctx, each_value_1, i));
    	}

    	let each_value = /*task01*/ ctx[0].displayValues.three;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1v(get_each_context$1v(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div13 = element("div");
    			div12 = element("div");
    			div0 = element("div");
    			h20 = element("h2");
    			h20.textContent = "Fill in the missing digits";
    			t1 = space();
    			div11 = element("div");
    			div8 = element("div");
    			h21 = element("h2");
    			t2 = text(t2_value);
    			t3 = space();
    			div7 = element("div");
    			div2 = element("div");
    			div1 = element("div");

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].c();
    			}

    			t4 = space();
    			div4 = element("div");
    			h50 = element("h5");
    			t5 = text(t5_value);
    			t6 = space();
    			div3 = element("div");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t7 = space();
    			div6 = element("div");
    			div5 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t8 = space();
    			h6 = element("h6");
    			t9 = text(t9_value);
    			t10 = space();
    			div9 = element("div");
    			h51 = element("h5");
    			t11 = text(/*showPopUp*/ ctx[3]);
    			t12 = space();
    			div10 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t14 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t16 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h20, "class", "text-center display-4 mb-0");
    			add_location(h20, file$1P, 51, 10, 931);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1P, 50, 6, 881);
    			add_location(h21, file$1P, 56, 12, 1117);
    			attr_dev(div1, "class", "col-3");
    			add_location(div1, file$1P, 61, 20, 1271);
    			attr_dev(div2, "class", "row ");
    			add_location(div2, file$1P, 59, 16, 1197);
    			attr_dev(h50, "style", "display: inline-block; width : 30px; text-align: center;");
    			add_location(h50, file$1P, 77, 19, 2011);
    			attr_dev(div3, "class", "col-3");
    			set_style(div3, "display", "inline-block");
    			add_location(div3, file$1P, 79, 20, 2124);
    			attr_dev(div4, "class", "row");
    			add_location(div4, file$1P, 75, 16, 1953);
    			attr_dev(div5, "class", "col-5 ");
    			add_location(div5, file$1P, 97, 20, 2917);
    			attr_dev(div6, "class", "row");
    			add_location(div6, file$1P, 94, 16, 2841);
    			add_location(h6, file$1P, 108, 16, 3527);
    			add_location(div7, file$1P, 57, 12, 1156);
    			add_location(div8, file$1P, 55, 8, 1098);
    			set_style(h51, "display", /*showNext*/ ctx[2]);
    			attr_dev(h51, "class", "mt-5");
    			add_location(h51, file$1P, 113, 12, 3619);
    			add_location(div9, file$1P, 112, 8, 3601);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1P, 117, 12, 3749);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1P, 118, 12, 3845);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1P, 119, 12, 3941);
    			attr_dev(div10, "class", "mt-3");
    			add_location(div10, file$1P, 116, 8, 3718);
    			attr_dev(div11, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div11, file$1P, 54, 6, 1026);
    			attr_dev(div12, "class", "shadow-sm  bg-white rounded");
    			add_location(div12, file$1P, 49, 5, 833);
    			attr_dev(div13, "class", "container mt-5");
    			add_location(div13, file$1P, 48, 1, 799);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div13, anchor);
    			append_dev(div13, div12);
    			append_dev(div12, div0);
    			append_dev(div0, h20);
    			append_dev(div12, t1);
    			append_dev(div12, div11);
    			append_dev(div11, div8);
    			append_dev(div8, h21);
    			append_dev(h21, t2);
    			append_dev(div8, t3);
    			append_dev(div8, div7);
    			append_dev(div7, div2);
    			append_dev(div2, div1);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].m(div1, null);
    			}

    			append_dev(div7, t4);
    			append_dev(div7, div4);
    			append_dev(div4, h50);
    			append_dev(h50, t5);
    			append_dev(div4, t6);
    			append_dev(div4, div3);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div3, null);
    			}

    			append_dev(div7, t7);
    			append_dev(div7, div6);
    			append_dev(div6, div5);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div5, null);
    			}

    			append_dev(div7, t8);
    			append_dev(div7, h6);
    			append_dev(h6, t9);
    			append_dev(div11, t10);
    			append_dev(div11, div9);
    			append_dev(div9, h51);
    			append_dev(h51, t11);
    			append_dev(div11, t12);
    			append_dev(div11, div10);
    			append_dev(div10, button0);
    			append_dev(div10, t14);
    			append_dev(div10, button1);
    			append_dev(div10, t16);
    			append_dev(div10, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*answer, task01*/ 3) {
    				each_value_2 = /*task01*/ ctx[0].displayValues.one;
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$b(ctx, each_value_2, i);

    					if (each_blocks_2[i]) {
    						each_blocks_2[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_2[i] = create_each_block_2$b(child_ctx);
    						each_blocks_2[i].c();
    						each_blocks_2[i].m(div1, null);
    					}
    				}

    				for (; i < each_blocks_2.length; i += 1) {
    					each_blocks_2[i].d(1);
    				}

    				each_blocks_2.length = each_value_2.length;
    			}

    			if (dirty & /*task01*/ 1 && t5_value !== (t5_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t5, t5_value);

    			if (dirty & /*answer, task01*/ 3) {
    				each_value_1 = /*task01*/ ctx[0].displayValues.two;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$s(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_1$s(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(div3, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_1.length;
    			}

    			if (dirty & /*answer, task01*/ 3) {
    				each_value = /*task01*/ ctx[0].displayValues.three;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1v(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1v(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div5, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*task01*/ 1 && t9_value !== (t9_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t9, t9_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t11, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h51, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div13);
    			destroy_each(each_blocks_2, detaching);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1Q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1Q($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GV_MA_B4", slots, []);
    	let task01 = taskOne$1w();
    	let answer;
    	let showNext = "none";
    	let showPopUp;

    	let CheckAnswer = function () {
    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			$$invalidate(2, showNext = "inline-block");
    			return;
    		} else {
    			$$invalidate(3, showPopUp = randomWrong());
    			$$invalidate(2, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$1w());
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GV_MA_B4> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	function input_input_handler_1() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	function input_input_handler_2() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1w,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler,
    		input_input_handler_1,
    		input_input_handler_2
    	];
    }

    class GV_MA_B4 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1Q, create_fragment$1Q, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GV_MA_B4",
    			options,
    			id: create_fragment$1Q.name
    		});
    	}
    }

    /* src/components/taskComponents/GIV_MA_B3.svelte generated by Svelte v3.37.0 */
    const file$1O = "src/components/taskComponents/GIV_MA_B3.svelte";

    function get_each_context$1u(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	child_ctx[15] = i;
    	return child_ctx;
    }

    function get_each_context_2$a(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	child_ctx[19] = list;
    	child_ctx[20] = i;
    	return child_ctx;
    }

    function get_each_context_1$r(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	child_ctx[17] = list;
    	child_ctx[18] = i;
    	return child_ctx;
    }

    // (87:27) {:else}
    function create_else_block_1$6(ctx) {
    	let tr;
    	let t;
    	let each_value_2 = /*value*/ ctx[13];
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$a(get_each_context_2$a(ctx, each_value_2, i));
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			attr_dev(tr, "class", "tablerow");
    			add_location(tr, file$1O, 87, 27, 2616);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			append_dev(tr, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*answer, task01*/ 3) {
    				each_value_2 = /*value*/ ctx[13];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$a(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_2$a(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, t);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_2.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$6.name,
    		type: "else",
    		source: "(87:27) {:else}",
    		ctx
    	});

    	return block;
    }

    // (75:23) {#if i == (task01.displayValues.length-1)}
    function create_if_block$1d(ctx) {
    	let hr;
    	let t0;
    	let tr;
    	let t1;
    	let each_value_1 = /*value*/ ctx[13];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$r(get_each_context_1$r(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			hr = element("hr");
    			t0 = space();
    			tr = element("tr");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			add_location(hr, file$1O, 75, 23, 2035);
    			attr_dev(tr, "class", "tablerow");
    			add_location(tr, file$1O, 76, 23, 2063);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, hr, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, tr, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*answer, task01*/ 3) {
    				each_value_1 = /*value*/ ctx[13];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$r(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$r(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, t1);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(hr);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(tr);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1d.name,
    		type: "if",
    		source: "(75:23) {#if i == (task01.displayValues.length-1)}",
    		ctx
    	});

    	return block;
    }

    // (93:28) {:else}
    function create_else_block_2$6(ctx) {
    	let td;
    	let t_value = /*val*/ ctx[16] + "";
    	let t;

    	const block = {
    		c: function create() {
    			td = element("td");
    			t = text(t_value);
    			attr_dev(td, "align", "right");
    			add_location(td, file$1O, 93, 32, 2963);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*val*/ ctx[16] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$6.name,
    		type: "else",
    		source: "(93:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (91:28) {#if val[0] == 'i'}
    function create_if_block_2$f(ctx) {
    	let td;
    	let input;
    	let mounted;
    	let dispose;

    	function input_input_handler_1() {
    		/*input_input_handler_1*/ ctx[7].call(input, /*val*/ ctx[16]);
    	}

    	const block = {
    		c: function create() {
    			td = element("td");
    			input = element("input");
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "style", " width : 30px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$1O, 91, 46, 2782);
    			attr_dev(td, "align", "right");
    			add_location(td, file$1O, 91, 28, 2764);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, input);
    			set_input_value(input, /*answer*/ ctx[1][/*val*/ ctx[16][1]]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler_1);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*answer, task01*/ 3 && input.value !== /*answer*/ ctx[1][/*val*/ ctx[16][1]]) {
    				set_input_value(input, /*answer*/ ctx[1][/*val*/ ctx[16][1]]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$f.name,
    		type: "if",
    		source: "(91:28) {#if val[0] == 'i'}",
    		ctx
    	});

    	return block;
    }

    // (89:28) {#each value as val}
    function create_each_block_2$a(ctx) {
    	let if_block_anchor;

    	function select_block_type_2(ctx, dirty) {
    		if (/*val*/ ctx[16][0] == "i") return create_if_block_2$f;
    		return create_else_block_2$6;
    	}

    	let current_block_type = select_block_type_2(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$a.name,
    		type: "each",
    		source: "(89:28) {#each value as val}",
    		ctx
    	});

    	return block;
    }

    // (82:24) {:else}
    function create_else_block$17(ctx) {
    	let td;
    	let t_value = /*val*/ ctx[16] + "";
    	let t;

    	const block = {
    		c: function create() {
    			td = element("td");
    			t = text(t_value);
    			attr_dev(td, "align", "right");
    			add_location(td, file$1O, 82, 28, 2413);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*val*/ ctx[16] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$17.name,
    		type: "else",
    		source: "(82:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (80:24) {#if val[0] == 'i'}
    function create_if_block_1$f(ctx) {
    	let td;
    	let input;
    	let mounted;
    	let dispose;

    	function input_input_handler() {
    		/*input_input_handler*/ ctx[6].call(input, /*val*/ ctx[16]);
    	}

    	const block = {
    		c: function create() {
    			td = element("td");
    			input = element("input");
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "style", " width : 30px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$1O, 80, 42, 2240);
    			attr_dev(td, "align", "right");
    			add_location(td, file$1O, 80, 24, 2222);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, input);
    			set_input_value(input, /*answer*/ ctx[1][/*val*/ ctx[16][1]]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*answer, task01*/ 3 && input.value !== /*answer*/ ctx[1][/*val*/ ctx[16][1]]) {
    				set_input_value(input, /*answer*/ ctx[1][/*val*/ ctx[16][1]]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$f.name,
    		type: "if",
    		source: "(80:24) {#if val[0] == 'i'}",
    		ctx
    	});

    	return block;
    }

    // (78:24) {#each value as val}
    function create_each_block_1$r(ctx) {
    	let if_block_anchor;

    	function select_block_type_1(ctx, dirty) {
    		if (/*val*/ ctx[16][0] == "i") return create_if_block_1$f;
    		return create_else_block$17;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$r.name,
    		type: "each",
    		source: "(78:24) {#each value as val}",
    		ctx
    	});

    	return block;
    }

    // (73:20) {#each task01.displayValues as value , i}
    function create_each_block$1u(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[15] == /*task01*/ ctx[0].displayValues.length - 1) return create_if_block$1d;
    		return create_else_block_1$6;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1u.name,
    		type: "each",
    		source: "(73:20) {#each task01.displayValues as value , i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1P(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h20;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h21;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let div3;
    	let h5;
    	let t5;
    	let t6;
    	let div4;
    	let button0;
    	let t8;
    	let button1;
    	let t10;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].displayValues;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1u(get_each_context$1u(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h20 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h21 = element("h2");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t5 = text(/*showPopUp*/ ctx[3]);
    			t6 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t8 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t10 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h20, "class", "text-center display-4 mb-0");
    			add_location(h20, file$1O, 62, 10, 1525);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1O, 61, 6, 1475);
    			add_location(h21, file$1O, 67, 12, 1701);
    			attr_dev(table, "width", "100");
    			add_location(table, file$1O, 70, 16, 1781);
    			add_location(div1, file$1O, 68, 12, 1740);
    			add_location(div2, file$1O, 66, 8, 1682);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1O, 105, 12, 3293);
    			add_location(div3, file$1O, 104, 8, 3275);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1O, 111, 12, 3432);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1O, 112, 12, 3528);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1O, 113, 12, 3624);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$1O, 110, 8, 3401);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$1O, 65, 6, 1610);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$1O, 60, 5, 1427);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$1O, 59, 1, 1393);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h20);
    			append_dev(h20, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h21);
    			append_dev(h21, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div5, t4);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t5);
    			append_dev(div5, t6);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t8);
    			append_dev(div4, button1);
    			append_dev(div4, t10);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01, answer*/ 3) {
    				each_value = /*task01*/ ctx[0].displayValues;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1u(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1u(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*showPopUp*/ 8) set_data_dev(t5, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1P.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const max$t = 9999;
    const min$t = 1000;
    const maxInputs$7 = 2;
    const numberofColumn$r = 2;

    function instance$1P($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GIV_MA_B3", slots, []);
    	let question = "Type the missing digit:";
    	let heading = "Addition: fill in the missing digits";
    	let showSolution = false;
    	let maxandmin = MaxandMin$4(max$t, min$t, numberofColumn$r, heading, question, maxInputs$7);
    	let task01 = taskOne$1x();
    	let answer = [];
    	let showNext = "none";
    	let showPopUp;
    	let tempString = "";

    	let CheckAnswer = function () {
    		for (let index = 0; index < task01.answer.length; index++) {
    			if (answer[index] != task01.answer[index]) {
    				$$invalidate(3, showPopUp = randomWrong());
    				$$invalidate(2, showNext = "inline-block");
    				showSolution = true;
    				return;
    			} else {
    				$$invalidate(3, showPopUp = randomCorrect());
    				$$invalidate(2, showNext = "inline-block");
    			}
    		}
    	};

    	let NextQuestion = function () {
    		showSolution = false;
    		$$invalidate(1, answer = []);
    		$$invalidate(0, task01 = taskOne$1x());
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GIV_MA_B3> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler(val) {
    		answer[val[1]] = this.value;
    		$$invalidate(1, answer);
    		$$invalidate(0, task01);
    	}

    	function input_input_handler_1(val) {
    		answer[val[1]] = this.value;
    		$$invalidate(1, answer);
    		$$invalidate(0, task01);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1x,
    		randomCorrect,
    		randomWrong,
    		MaxandMin: MaxandMin$4,
    		question,
    		heading,
    		max: max$t,
    		min: min$t,
    		maxInputs: maxInputs$7,
    		numberofColumn: numberofColumn$r,
    		showSolution,
    		maxandmin,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		tempString,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("question" in $$props) question = $$props.question;
    		if ("heading" in $$props) heading = $$props.heading;
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("maxandmin" in $$props) maxandmin = $$props.maxandmin;
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("tempString" in $$props) tempString = $$props.tempString;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler,
    		input_input_handler_1
    	];
    }

    class GIV_MA_B3 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1P, create_fragment$1P, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GIV_MA_B3",
    			options,
    			id: create_fragment$1P.name
    		});
    	}
    }

    /* src/components/taskComponents/GIII_MA_C9.svelte generated by Svelte v3.37.0 */
    const file$1N = "src/components/taskComponents/GIII_MA_C9.svelte";

    function get_each_context$1t(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	child_ctx[15] = i;
    	return child_ctx;
    }

    function get_each_context_2$9(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	child_ctx[19] = list;
    	child_ctx[20] = i;
    	return child_ctx;
    }

    function get_each_context_1$q(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	child_ctx[17] = list;
    	child_ctx[18] = i;
    	return child_ctx;
    }

    // (87:27) {:else}
    function create_else_block_1$5(ctx) {
    	let tr;
    	let t;
    	let each_value_2 = /*value*/ ctx[13];
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$9(get_each_context_2$9(ctx, each_value_2, i));
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			attr_dev(tr, "class", "tablerow");
    			add_location(tr, file$1N, 87, 27, 2604);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			append_dev(tr, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*answer, task01*/ 3) {
    				each_value_2 = /*value*/ ctx[13];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$9(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_2$9(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, t);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_2.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$5.name,
    		type: "else",
    		source: "(87:27) {:else}",
    		ctx
    	});

    	return block;
    }

    // (75:23) {#if i == (task01.displayValues.length-1)}
    function create_if_block$1c(ctx) {
    	let hr;
    	let t0;
    	let tr;
    	let t1;
    	let each_value_1 = /*value*/ ctx[13];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$q(get_each_context_1$q(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			hr = element("hr");
    			t0 = space();
    			tr = element("tr");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			add_location(hr, file$1N, 75, 23, 2023);
    			attr_dev(tr, "class", "tablerow");
    			add_location(tr, file$1N, 76, 23, 2051);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, hr, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, tr, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*answer, task01*/ 3) {
    				each_value_1 = /*value*/ ctx[13];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$q(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$q(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, t1);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(hr);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(tr);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1c.name,
    		type: "if",
    		source: "(75:23) {#if i == (task01.displayValues.length-1)}",
    		ctx
    	});

    	return block;
    }

    // (93:28) {:else}
    function create_else_block_2$5(ctx) {
    	let td;
    	let t_value = /*val*/ ctx[16] + "";
    	let t;

    	const block = {
    		c: function create() {
    			td = element("td");
    			t = text(t_value);
    			attr_dev(td, "align", "right");
    			add_location(td, file$1N, 93, 32, 2951);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*val*/ ctx[16] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$5.name,
    		type: "else",
    		source: "(93:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (91:28) {#if val[0] == 'i'}
    function create_if_block_2$e(ctx) {
    	let td;
    	let input;
    	let mounted;
    	let dispose;

    	function input_input_handler_1() {
    		/*input_input_handler_1*/ ctx[7].call(input, /*val*/ ctx[16]);
    	}

    	const block = {
    		c: function create() {
    			td = element("td");
    			input = element("input");
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "style", " width : 30px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$1N, 91, 46, 2770);
    			attr_dev(td, "align", "right");
    			add_location(td, file$1N, 91, 28, 2752);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, input);
    			set_input_value(input, /*answer*/ ctx[1][/*val*/ ctx[16][1]]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler_1);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*answer, task01*/ 3 && input.value !== /*answer*/ ctx[1][/*val*/ ctx[16][1]]) {
    				set_input_value(input, /*answer*/ ctx[1][/*val*/ ctx[16][1]]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$e.name,
    		type: "if",
    		source: "(91:28) {#if val[0] == 'i'}",
    		ctx
    	});

    	return block;
    }

    // (89:28) {#each value as val}
    function create_each_block_2$9(ctx) {
    	let if_block_anchor;

    	function select_block_type_2(ctx, dirty) {
    		if (/*val*/ ctx[16][0] == "i") return create_if_block_2$e;
    		return create_else_block_2$5;
    	}

    	let current_block_type = select_block_type_2(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$9.name,
    		type: "each",
    		source: "(89:28) {#each value as val}",
    		ctx
    	});

    	return block;
    }

    // (82:24) {:else}
    function create_else_block$16(ctx) {
    	let td;
    	let t_value = /*val*/ ctx[16] + "";
    	let t;

    	const block = {
    		c: function create() {
    			td = element("td");
    			t = text(t_value);
    			attr_dev(td, "align", "right");
    			add_location(td, file$1N, 82, 28, 2401);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*val*/ ctx[16] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$16.name,
    		type: "else",
    		source: "(82:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (80:24) {#if val[0] == 'i'}
    function create_if_block_1$e(ctx) {
    	let td;
    	let input;
    	let mounted;
    	let dispose;

    	function input_input_handler() {
    		/*input_input_handler*/ ctx[6].call(input, /*val*/ ctx[16]);
    	}

    	const block = {
    		c: function create() {
    			td = element("td");
    			input = element("input");
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "style", " width : 30px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$1N, 80, 42, 2228);
    			attr_dev(td, "align", "right");
    			add_location(td, file$1N, 80, 24, 2210);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, input);
    			set_input_value(input, /*answer*/ ctx[1][/*val*/ ctx[16][1]]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*answer, task01*/ 3 && input.value !== /*answer*/ ctx[1][/*val*/ ctx[16][1]]) {
    				set_input_value(input, /*answer*/ ctx[1][/*val*/ ctx[16][1]]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$e.name,
    		type: "if",
    		source: "(80:24) {#if val[0] == 'i'}",
    		ctx
    	});

    	return block;
    }

    // (78:24) {#each value as val}
    function create_each_block_1$q(ctx) {
    	let if_block_anchor;

    	function select_block_type_1(ctx, dirty) {
    		if (/*val*/ ctx[16][0] == "i") return create_if_block_1$e;
    		return create_else_block$16;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$q.name,
    		type: "each",
    		source: "(78:24) {#each value as val}",
    		ctx
    	});

    	return block;
    }

    // (73:20) {#each task01.displayValues as value , i}
    function create_each_block$1t(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[15] == /*task01*/ ctx[0].displayValues.length - 1) return create_if_block$1c;
    		return create_else_block_1$5;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1t.name,
    		type: "each",
    		source: "(73:20) {#each task01.displayValues as value , i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1O(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h20;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h21;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let div3;
    	let h5;
    	let t5;
    	let t6;
    	let div4;
    	let button0;
    	let t8;
    	let button1;
    	let t10;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].displayValues;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1t(get_each_context$1t(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h20 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h21 = element("h2");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t5 = text(/*showPopUp*/ ctx[3]);
    			t6 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t8 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t10 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h20, "class", "text-center display-4 mb-0");
    			add_location(h20, file$1N, 62, 10, 1513);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1N, 61, 6, 1463);
    			add_location(h21, file$1N, 67, 12, 1689);
    			attr_dev(table, "width", "100");
    			add_location(table, file$1N, 70, 16, 1769);
    			add_location(div1, file$1N, 68, 12, 1728);
    			add_location(div2, file$1N, 66, 8, 1670);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1N, 105, 12, 3281);
    			add_location(div3, file$1N, 104, 8, 3263);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1N, 111, 12, 3420);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1N, 112, 12, 3516);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1N, 113, 12, 3612);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$1N, 110, 8, 3389);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$1N, 65, 6, 1598);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$1N, 60, 5, 1415);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$1N, 59, 1, 1381);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h20);
    			append_dev(h20, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h21);
    			append_dev(h21, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div5, t4);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t5);
    			append_dev(div5, t6);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t8);
    			append_dev(div4, button1);
    			append_dev(div4, t10);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01, answer*/ 3) {
    				each_value = /*task01*/ ctx[0].displayValues;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1t(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1t(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*showPopUp*/ 8) set_data_dev(t5, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1O.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const max$s = 999;
    const min$s = 1;
    const maxInputs$6 = 2;
    const numberofColumn$q = 3;

    function instance$1O($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GIII_MA_C9", slots, []);
    	let question = "Add :";
    	let heading = "Complete the addition sentence - sums up to 10";
    	let showSolution = false;
    	let maxandmin = MaxandMin$4(max$s, min$s, numberofColumn$q, heading, question, maxInputs$6);
    	let task01 = taskOne$1x();
    	let answer = [];
    	let showNext = "none";
    	let showPopUp;
    	let tempString = "";

    	let CheckAnswer = function () {
    		for (let index = 0; index < task01.answer.length; index++) {
    			if (answer[index] != task01.answer[index]) {
    				$$invalidate(3, showPopUp = randomWrong());
    				$$invalidate(2, showNext = "inline-block");
    				showSolution = true;
    				return;
    			} else {
    				$$invalidate(3, showPopUp = randomCorrect());
    				$$invalidate(2, showNext = "inline-block");
    			}
    		}
    	};

    	let NextQuestion = function () {
    		showSolution = false;
    		$$invalidate(1, answer = []);
    		$$invalidate(0, task01 = taskOne$1x());
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GIII_MA_C9> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler(val) {
    		answer[val[1]] = this.value;
    		$$invalidate(1, answer);
    		$$invalidate(0, task01);
    	}

    	function input_input_handler_1(val) {
    		answer[val[1]] = this.value;
    		$$invalidate(1, answer);
    		$$invalidate(0, task01);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1x,
    		randomCorrect,
    		randomWrong,
    		MaxandMin: MaxandMin$4,
    		question,
    		heading,
    		max: max$s,
    		min: min$s,
    		maxInputs: maxInputs$6,
    		numberofColumn: numberofColumn$q,
    		showSolution,
    		maxandmin,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		tempString,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("question" in $$props) question = $$props.question;
    		if ("heading" in $$props) heading = $$props.heading;
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("maxandmin" in $$props) maxandmin = $$props.maxandmin;
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("tempString" in $$props) tempString = $$props.tempString;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler,
    		input_input_handler_1
    	];
    }

    class GIII_MA_C9 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1O, create_fragment$1O, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GIII_MA_C9",
    			options,
    			id: create_fragment$1O.name
    		});
    	}
    }

    let task01$1v = {    
        question: " Choose numbers with a particular sum or difference",
        ValueOne: 0,
        ValueTwo: 0,
        answer: 0,
        options: ["-", "+"],
        sum:'-',
        option : [0,0],
        displayValues : [],
        
      };
      let arraylenght$2 = 8;
      const maxNumber$c = 1000;
      const minNumber$c = 1;
      function taskOne$1v() {
        let arraySize =  Math.floor(Math.random() * (arraylenght$2 - 4)) + 4;    task01$1v.displayValues = randomNumbers$2(arraySize,maxNumber$c,minNumber$c);
        let temp = randomNumbers$2(task01$1v.option.length,task01$1v.displayValues.length,0);
        for (let i = 0; i < temp.length; i++) {
            task01$1v.option[i]=task01$1v.displayValues[temp[i]];
        }
        task01$1v.randomAnswer = Math.floor(Math.random() * (task01$1v.options.length));
        task01$1v.sum = task01$1v.options[task01$1v.randomAnswer];
        if(task01$1v.sum == "-"){

            task01$1v.answer = Math.abs(task01$1v.option[0] - task01$1v.option[1]);
          }else if(task01$1v.sum == "+"){        
            task01$1v.answer = Math.abs(task01$1v.option[0] + task01$1v.option[1]);     
          }
        return task01$1v;
      }
      

      function randomNumbers$2(count, max , min){
        var stop = count;
        var numbers = [];
        for (let i = 0; i < stop; i++) {
        var n =  Math.floor(Math.random() * (max - min)) + min;
        var check = numbers.includes(n);
            
            if(check === false) {
                numbers.push(n);
            } else {
                while(check === true){
                n =  Math.floor(Math.random() * (max - min)) + min;
                check = numbers.includes(n);
                    if(check === false){
                    numbers.push(n);
                    }
                }
            }
            }
        return numbers;
      }

    /* src/components/taskComponents/GV_MA_B5.svelte generated by Svelte v3.37.0 */
    const file$1M = "src/components/taskComponents/GV_MA_B5.svelte";

    function get_each_context$1s(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    // (63:15) {#each task01.displayValues as displayValue}
    function create_each_block$1s(ctx) {
    	let div;
    	let h1;
    	let t_value = /*displayValue*/ ctx[9] + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			h1 = element("h1");
    			t = text(t_value);
    			add_location(h1, file$1M, 63, 24, 1512);
    			add_location(div, file$1M, 63, 19, 1507);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h1);
    			append_dev(h1, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*displayValue*/ ctx[9] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1s.name,
    		type: "each",
    		source: "(63:15) {#each task01.displayValues as displayValue}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1N(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h20;
    	let t1;
    	let div5;
    	let div2;
    	let h21;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let t4;
    	let input0;
    	let t5;
    	let h22;
    	let t7;
    	let input1;
    	let t8;
    	let h23;
    	let t9;
    	let t10_value = /*task01*/ ctx[0].answer + "";
    	let t10;
    	let t11;
    	let t12;
    	let h24;
    	let t13_value = /*task01*/ ctx[0].option + "";
    	let t13;
    	let t14;
    	let t15;
    	let div3;
    	let h5;
    	let t16;
    	let t17;
    	let div4;
    	let button0;
    	let t19;
    	let button1;
    	let t21;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].displayValues;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1s(get_each_context$1s(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h20 = element("h2");
    			h20.textContent = "Choose numbers with a particular sum or difference";
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h21 = element("h2");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			input0 = element("input");
    			t5 = space();
    			h22 = element("h2");
    			h22.textContent = "and";
    			t7 = space();
    			input1 = element("input");
    			t8 = space();
    			h23 = element("h2");
    			t9 = text("have a difference of ");
    			t10 = text(t10_value);
    			t11 = text(".");
    			t12 = space();
    			h24 = element("h2");
    			t13 = text(t13_value);
    			t14 = text(".");
    			t15 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t16 = text(/*showPopUp*/ ctx[4]);
    			t17 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t19 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t21 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h20, "class", "text-center display-4 mb-0");
    			add_location(h20, file$1M, 55, 9, 1175);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1M, 54, 5, 1126);
    			add_location(h21, file$1M, 60, 11, 1380);
    			attr_dev(input0, "type", "text");
    			set_style(input0, "margin-left", "5px");
    			add_location(input0, file$1M, 65, 15, 1587);
    			add_location(h22, file$1M, 66, 15, 1673);
    			attr_dev(input1, "type", "text");
    			set_style(input1, "margin-left", "5px");
    			add_location(input1, file$1M, 67, 15, 1704);
    			add_location(h23, file$1M, 68, 15, 1790);
    			add_location(h24, file$1M, 69, 15, 1853);
    			add_location(div1, file$1M, 61, 11, 1418);
    			add_location(div2, file$1M, 59, 7, 1362);
    			set_style(h5, "display", /*showNext*/ ctx[3]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1M, 74, 8, 1940);
    			add_location(div3, file$1M, 73, 7, 1926);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1M, 78, 8, 2058);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1M, 79, 8, 2150);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1M, 80, 8, 2242);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$1M, 77, 4, 2031);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$1M, 58, 5, 1291);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$1M, 53, 4, 1079);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$1M, 52, 1, 1046);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h20);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h21);
    			append_dev(h21, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, input0);
    			set_input_value(input0, /*answer01*/ ctx[1]);
    			append_dev(div1, t5);
    			append_dev(div1, h22);
    			append_dev(div1, t7);
    			append_dev(div1, input1);
    			set_input_value(input1, /*answer02*/ ctx[2]);
    			append_dev(div1, t8);
    			append_dev(div1, h23);
    			append_dev(h23, t9);
    			append_dev(h23, t10);
    			append_dev(h23, t11);
    			append_dev(div1, t12);
    			append_dev(div1, h24);
    			append_dev(h24, t13);
    			append_dev(h24, t14);
    			append_dev(div5, t15);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t16);
    			append_dev(div5, t17);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t19);
    			append_dev(div4, button1);
    			append_dev(div4, t21);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[7]),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[8]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].displayValues;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1s(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1s(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, t4);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer01*/ 2 && input0.value !== /*answer01*/ ctx[1]) {
    				set_input_value(input0, /*answer01*/ ctx[1]);
    			}

    			if (dirty & /*answer02*/ 4 && input1.value !== /*answer02*/ ctx[2]) {
    				set_input_value(input1, /*answer02*/ ctx[2]);
    			}

    			if (dirty & /*task01*/ 1 && t10_value !== (t10_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t10, t10_value);
    			if (dirty & /*task01*/ 1 && t13_value !== (t13_value = /*task01*/ ctx[0].option + "")) set_data_dev(t13, t13_value);
    			if (dirty & /*showPopUp*/ 16) set_data_dev(t16, /*showPopUp*/ ctx[4]);

    			if (dirty & /*showNext*/ 8) {
    				set_style(h5, "display", /*showNext*/ ctx[3]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1N.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1N($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GV_MA_B5", slots, []);
    	let task01 = taskOne$1v();
    	let answer01, answer02;
    	let showNext = "none";
    	let showPopUp;

    	let CheckAnswer = function () {
    		if (answer01 == task01.option[0] && answer02 == task01.option[1]) {
    			$$invalidate(4, showPopUp = randomCorrect());
    			$$invalidate(3, showNext = "inline-block");
    		} else if (answer01 == task01.option[1] && answer02 == task01.option[0]) {
    			$$invalidate(4, showPopUp = randomCorrect());
    			$$invalidate(3, showNext = "inline-block");
    		} else {
    			$$invalidate(4, showPopUp = randomWrong());
    			$$invalidate(3, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer01 = null);
    		$$invalidate(2, answer02 = null);
    		$$invalidate(0, task01 = taskOne$1v());
    		$$invalidate(3, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GV_MA_B5> was created with unknown prop '${key}'`);
    	});

    	function input0_input_handler() {
    		answer01 = this.value;
    		$$invalidate(1, answer01);
    	}

    	function input1_input_handler() {
    		answer02 = this.value;
    		$$invalidate(2, answer02);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1v,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer01,
    		answer02,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer01" in $$props) $$invalidate(1, answer01 = $$props.answer01);
    		if ("answer02" in $$props) $$invalidate(2, answer02 = $$props.answer02);
    		if ("showNext" in $$props) $$invalidate(3, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(4, showPopUp = $$props.showPopUp);
    		if ("CheckAnswer" in $$props) $$invalidate(5, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(6, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer01,
    		answer02,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input0_input_handler,
    		input1_input_handler
    	];
    }

    class GV_MA_B5 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1N, create_fragment$1N, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GV_MA_B5",
    			options,
    			id: create_fragment$1N.name
    		});
    	}
    }

    let task01$1u = {
        questionOption:["Which property of addition is shown?","Which equation shows the identity property of addition?"],
        question : '',
        startValue : 0,
        startText : '',
        startTextArray : ["Closure" , "Commutative","Associative" , "Identity"],
        optionTextArray : ["a + b = c" , "a+b = b+a ","(a+b) + c = a+(b+c)" , "a+0 = a"],
        endValue : 0,
        endText : '',
        answer : 0,
        endTextArray : ["ones" , "tens"]
    };

    const maxNumber$b = 10;
    const minNumber$b = 0;


    function taskOne$1u(){

        let qst = Math.floor(Math.random() * (task01$1u.questionOption.length - minNumber$b)) + minNumber$b;
        task01$1u.answer = Math.floor(Math.random() * (task01$1u.startTextArray.length - minNumber$b)) + minNumber$b;
        task01$1u.endValue = Math.floor(Math.random() * (task01$1u.startTextArray.length - minNumber$b)) + minNumber$b;
        task01$1u.startValue = qst;

        let a = Math.floor(Math.random() * maxNumber$b) + 1;
        let b = Math.floor(Math.random() * maxNumber$b) + 1;
        let c = Math.floor(Math.random() * maxNumber$b) + 1;
        task01$1u.optionTextArray[0] = (a+"+"+b+"="+(a+b)).toString();
        task01$1u.optionTextArray[1] = (a+"+"+b+"="+b+"+"+c).toString();
        task01$1u.optionTextArray[2] = ("("+a+"+"+b+") + "+c+" = "+a+"+("+b+"+"+c+")").toString();
        task01$1u.optionTextArray[3] = (a+"+0 = "+a).toString();
        if(qst != 0){
            task01$1u.questionOption[1] = "Which equation shows the "+ task01$1u.startTextArray[task01$1u.answer]+" property of addition?";
        }
        task01$1u.question = task01$1u.questionOption[qst];

        


        return task01$1u;
    }

    /* src/components/taskComponents/GV_MA_B6.svelte generated by Svelte v3.37.0 */
    const file$1L = "src/components/taskComponents/GV_MA_B6.svelte";

    function get_each_context_1$p(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	child_ctx[9] = i;
    	return child_ctx;
    }

    function get_each_context$1r(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	child_ctx[9] = i;
    	return child_ctx;
    }

    // (69:19) {:else}
    function create_else_block$15(ctx) {
    	let div;
    	let each_value_1 = /*task01*/ ctx[0].optionTextArray;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$p(get_each_context_1$p(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(div, file$1L, 69, 19, 1719);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*handleClick, task01*/ 17) {
    				each_value_1 = /*task01*/ ctx[0].optionTextArray;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$p(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$p(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$15.name,
    		type: "else",
    		source: "(69:19) {:else}",
    		ctx
    	});

    	return block;
    }

    // (62:15) {#if task01.startValue == 0}
    function create_if_block$1b(ctx) {
    	let h2;
    	let t0_value = /*task01*/ ctx[0].optionTextArray[/*task01*/ ctx[0].endValue] + "";
    	let t0;
    	let t1;
    	let div;
    	let each_value = /*task01*/ ctx[0].startTextArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1r(get_each_context$1r(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(h2, file$1L, 62, 20, 1326);
    			add_location(div, file$1L, 63, 20, 1397);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    			append_dev(h2, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].optionTextArray[/*task01*/ ctx[0].endValue] + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*handleClick, task01*/ 17) {
    				each_value = /*task01*/ ctx[0].startTextArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1r(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1r(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1b.name,
    		type: "if",
    		source: "(62:15) {#if task01.startValue == 0}",
    		ctx
    	});

    	return block;
    }

    // (71:20) {#each  task01.optionTextArray as optionValue, i}
    function create_each_block_1$p(ctx) {
    	let button;
    	let t_value = /*optionValue*/ ctx[7] + "";
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "class", "btn btn-outline-success");
    			add_location(button, file$1L, 71, 20, 1815);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleClick*/ ctx[4](/*i*/ ctx[9]), false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*optionValue*/ ctx[7] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$p.name,
    		type: "each",
    		source: "(71:20) {#each  task01.optionTextArray as optionValue, i}",
    		ctx
    	});

    	return block;
    }

    // (65:24) {#each  task01.startTextArray as optionValue , i}
    function create_each_block$1r(ctx) {
    	let button;
    	let t_value = /*optionValue*/ ctx[7] + "";
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "class", "btn btn-outline-success");
    			add_location(button, file$1L, 65, 24, 1501);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleClick*/ ctx[4](/*i*/ ctx[9]), false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*optionValue*/ ctx[7] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1r.name,
    		type: "each",
    		source: "(65:24) {#each  task01.startTextArray as optionValue , i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1M(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h20;
    	let t1;
    	let div5;
    	let div2;
    	let h21;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let t4;
    	let h3;
    	let t5_value = /*task01*/ ctx[0].answer + "";
    	let t5;
    	let t6;
    	let div3;
    	let h5;
    	let t7;
    	let t8;
    	let div4;
    	let button0;
    	let t10;
    	let button1;
    	let mounted;
    	let dispose;

    	function select_block_type(ctx, dirty) {
    		if (/*task01*/ ctx[0].startValue == 0) return create_if_block$1b;
    		return create_else_block$15;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h20 = element("h2");
    			h20.textContent = "Properties of addition";
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h21 = element("h2");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			if_block.c();
    			t4 = space();
    			h3 = element("h3");
    			t5 = text(t5_value);
    			t6 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t7 = text(/*showPopUp*/ ctx[2]);
    			t8 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Rerun";
    			t10 = space();
    			button1 = element("button");
    			button1.textContent = "Exit This Skill";
    			attr_dev(h20, "class", "text-center display-4 mb-0");
    			add_location(h20, file$1L, 54, 10, 1031);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1L, 53, 6, 981);
    			add_location(h21, file$1L, 59, 12, 1213);
    			add_location(h3, file$1L, 76, 15, 2010);
    			add_location(div1, file$1L, 60, 12, 1252);
    			add_location(div2, file$1L, 58, 8, 1194);
    			set_style(h5, "display", /*showNext*/ ctx[1]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1L, 82, 12, 2103);
    			add_location(div3, file$1L, 81, 8, 2085);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1L, 87, 12, 2238);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1L, 88, 12, 2334);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$1L, 85, 8, 2206);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$1L, 57, 6, 1122);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$1L, 52, 5, 933);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$1L, 51, 1, 899);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h20);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h21);
    			append_dev(h21, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			if_block.m(div1, null);
    			append_dev(div1, t4);
    			append_dev(div1, h3);
    			append_dev(h3, t5);
    			append_dev(div5, t6);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t7);
    			append_dev(div5, t8);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t10);
    			append_dev(div4, button1);

    			if (!mounted) {
    				dispose = listen_dev(button0, "click", /*NextQuestion*/ ctx[3], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div1, t4);
    				}
    			}

    			if (dirty & /*task01*/ 1 && t5_value !== (t5_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t5, t5_value);
    			if (dirty & /*showPopUp*/ 4) set_data_dev(t7, /*showPopUp*/ ctx[2]);

    			if (dirty & /*showNext*/ 2) {
    				set_style(h5, "display", /*showNext*/ ctx[1]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1M.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1M($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GV_MA_B6", slots, []);
    	let task01 = taskOne$1u();
    	let answer;
    	let showNext = "none";
    	let showPopUp;

    	let CheckAnswer = function () {
    		if (answer == task01.answer) {
    			$$invalidate(2, showPopUp = randomCorrect());
    			$$invalidate(1, showNext = "inline-block");
    			return;
    		} else {
    			$$invalidate(2, showPopUp = randomWrong());
    			$$invalidate(1, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		answer = null;
    		$$invalidate(0, task01 = taskOne$1u());
    		$$invalidate(1, showNext = "none");
    	};

    	const handleClick = parameter => () => {
    		answer = parameter;
    		CheckAnswer();
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GV_MA_B6> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1u,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		handleClick
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) answer = $$props.answer;
    		if ("showNext" in $$props) $$invalidate(1, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(2, showPopUp = $$props.showPopUp);
    		if ("CheckAnswer" in $$props) CheckAnswer = $$props.CheckAnswer;
    		if ("NextQuestion" in $$props) $$invalidate(3, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [task01, showNext, showPopUp, NextQuestion, handleClick];
    }

    class GV_MA_B6 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1M, create_fragment$1M, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GV_MA_B6",
    			options,
    			id: create_fragment$1M.name
    		});
    	}
    }

    let task01$1t = {
      question: "Estimate the sum by rounding each number to the nearest thousand and then adding.",
      displayValue: 0,
      displayValueTwo: 0,
      answer: 0,
      randomAnswer: 0,
      options: [1000, 10, 100,10000],
      Disoptions: ["thousand", "ten", "hundred", "ten thousand"],
      opraters : ['+' , '-'],
      operatorNum : 0,
      qstOpt : ""

    };

    const maxNumber$a = 1000000;
    const minNumber$a = 100000;

    function taskOne$1t() {
        task01$1t.randomAnswer = Math.floor(Math.random() * (task01$1t.options.length));
        let tempNum = Math.floor(Math.random() * (task01$1t.opraters.length));
        task01$1t.displayValue = Math.floor(Math.random() * (maxNumber$a - minNumber$a)) + minNumber$a;
        task01$1t.displayValueTwo = Math.floor(Math.random() * (maxNumber$a - minNumber$a)) + minNumber$a;
        console.log(tempNum);
        if(tempNum === 0){
           
            task01$1t.question = "Estimate the sum by rounding each number to the nearest "+ task01$1t.Disoptions[task01$1t.randomAnswer]; 
            task01$1t.answer = roundUp(task01$1t.displayValue,task01$1t.options[task01$1t.randomAnswer]) + roundUp(task01$1t.displayValueTwo,task01$1t.options[task01$1t.randomAnswer]);
        }else {
            console.log("SUB");
            task01$1t.displayValueTwo = Math.floor(Math.random() * (task01$1t.displayValue - minNumber$a)) + minNumber$a;
            task01$1t.question = "Estimate the difference by rounding each number to the nearest "+ task01$1t.Disoptions[task01$1t.randomAnswer]; 
            task01$1t.answer = roundUp(task01$1t.displayValue,task01$1t.options[task01$1t.randomAnswer]) - roundUp(task01$1t.displayValueTwo,task01$1t.options[task01$1t.randomAnswer]);
        }    
        task01$1t.qstOpt = task01$1t.displayValue + " " +  task01$1t.opraters[tempNum] + " " + task01$1t.displayValueTwo;
       
        return task01$1t;
    }

    /* src/components/taskComponents/GV_MA_B7.svelte generated by Svelte v3.37.0 */
    const file$1K = "src/components/taskComponents/GV_MA_B7.svelte";

    function create_fragment$1L(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h20;
    	let t1;
    	let div5;
    	let div2;
    	let h21;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let h40;
    	let t4_value = /*task01*/ ctx[0].qstOpt + "";
    	let t4;
    	let t5;
    	let h41;
    	let t7;
    	let input;
    	let t8;
    	let h6;
    	let t9;
    	let t10_value = /*task01*/ ctx[0].answer + "";
    	let t10;
    	let t11;
    	let div3;
    	let h5;
    	let t12;
    	let t13;
    	let div4;
    	let button0;
    	let t15;
    	let button1;
    	let t17;
    	let button2;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h20 = element("h2");
    			h20.textContent = "Estimate sums and differences of whole numbers";
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h21 = element("h2");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			h40 = element("h4");
    			t4 = text(t4_value);
    			t5 = space();
    			h41 = element("h4");
    			h41.textContent = "The sum is approximately";
    			t7 = space();
    			input = element("input");
    			t8 = space();
    			h6 = element("h6");
    			t9 = text("answer");
    			t10 = text(t10_value);
    			t11 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t12 = text(/*showPopUp*/ ctx[3]);
    			t13 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t15 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t17 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h20, "class", "text-center display-4 mb-0");
    			add_location(h20, file$1K, 51, 10, 931);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1K, 50, 6, 881);
    			add_location(h21, file$1K, 56, 12, 1137);
    			add_location(h40, file$1K, 58, 16, 1202);
    			add_location(h41, file$1K, 60, 16, 1262);
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$1K, 61, 16, 1314);
    			add_location(h6, file$1K, 63, 16, 1432);
    			add_location(div1, file$1K, 57, 12, 1176);
    			add_location(div2, file$1K, 55, 8, 1118);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1K, 69, 12, 1532);
    			add_location(div3, file$1K, 68, 8, 1514);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1K, 73, 12, 1666);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1K, 74, 12, 1762);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1K, 75, 12, 1858);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$1K, 72, 8, 1635);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$1K, 54, 6, 1046);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$1K, 49, 5, 833);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$1K, 48, 1, 799);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h20);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h21);
    			append_dev(h21, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, h40);
    			append_dev(h40, t4);
    			append_dev(div1, t5);
    			append_dev(div1, h41);
    			append_dev(div1, t7);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t8);
    			append_dev(div1, h6);
    			append_dev(h6, t9);
    			append_dev(h6, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t12);
    			append_dev(div5, t13);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t15);
    			append_dev(div4, button1);
    			append_dev(div4, t17);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*task01*/ 1 && t4_value !== (t4_value = /*task01*/ ctx[0].qstOpt + "")) set_data_dev(t4, t4_value);

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t10_value !== (t10_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t10, t10_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t12, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1L.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1L($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GV_MA_B7", slots, []);
    	let task01 = taskOne$1t();
    	let answer;
    	let showNext = "none";
    	let showPopUp;

    	let CheckAnswer = function () {
    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			$$invalidate(2, showNext = "inline-block");
    			return;
    		} else {
    			$$invalidate(3, showPopUp = randomWrong());
    			$$invalidate(2, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$1t());
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GV_MA_B7> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1t,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class GV_MA_B7 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1L, create_fragment$1L, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GV_MA_B7",
    			options,
    			id: create_fragment$1L.name
    		});
    	}
    }

    let task01$1s = {
      question: "Zach just transferred 777 out of his bank account. As a result, the account now has 944 left in it. About how much money was in the account before the transfer? Choose the better estimate.",
      displayValue: 0,
      displayValueTwo: 0,
      answer: 0,
      randomAnswer: 0,
      options: [10, 100],
      Disoptions: [ "ten", "hundred"],
      opraters : ['+' , '-'],
      operatorNum : [0,0],
      qstOpt : ""
        
    };
    const maxNumber$9 = 1000;
    const minNumber$9 = 10;

    function taskOne$1s() {
        task01$1s.randomAnswer = Math.floor(Math.random() * (task01$1s.options.length));
        let tempNum = Math.floor(Math.random() * (task01$1s.opraters.length));
        task01$1s.displayValue = Math.floor(Math.random() * (maxNumber$9 - minNumber$9)) + minNumber$9;   
        
        

        if(tempNum === 0){ 
            task01$1s.displayValueTwo = Math.floor(Math.random() *(maxNumber$9 - minNumber$9)) + minNumber$9;
            task01$1s.operatorNum[0] = roundUp(task01$1s.displayValue,task01$1s.options[task01$1s.randomAnswer]) + roundUp(task01$1s.displayValueTwo,task01$1s.options[task01$1s.randomAnswer]);
            task01$1s.operatorNum[1] = Math.abs(roundUp(task01$1s.displayValue,task01$1s.options[task01$1s.randomAnswer]) - roundUp(task01$1s.displayValueTwo,task01$1s.options[task01$1s.randomAnswer]));  
            task01$1s.answer = roundUp(task01$1s.displayValue,task01$1s.options[task01$1s.randomAnswer]) + roundUp(task01$1s.displayValueTwo,task01$1s.options[task01$1s.randomAnswer]);
            
        }else {  
          task01$1s.displayValueTwo = Math.floor(Math.random() *(task01$1s.displayValue - minNumber$9)) + minNumber$9;   
          task01$1s.operatorNum[0] = roundUp(task01$1s.displayValue,task01$1s.options[task01$1s.randomAnswer]) + roundUp(task01$1s.displayValueTwo,task01$1s.options[task01$1s.randomAnswer]);
          task01$1s.operatorNum[1] = roundUp(task01$1s.displayValue,task01$1s.options[task01$1s.randomAnswer]) - roundUp(task01$1s.displayValueTwo,task01$1s.options[task01$1s.randomAnswer]);
            
         
            task01$1s.answer = roundUp(task01$1s.displayValue,task01$1s.options[task01$1s.randomAnswer]) - roundUp(task01$1s.displayValueTwo,task01$1s.options[task01$1s.randomAnswer]);
        }
        task01$1s.question = "Zach just transferred "+ task01$1s.displayValue + " out of his bank account. As a result, the account now has " + task01$1s.displayValueTwo +" left in it. About how much money was in the account before the transfer? Choose the better estimate. ";
        return task01$1s;
    }

    /* src/components/taskComponents/GV_MA_B8.svelte generated by Svelte v3.37.0 */
    const file$1J = "src/components/taskComponents/GV_MA_B8.svelte";

    function create_fragment$1K(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h20;
    	let t1;
    	let div5;
    	let div2;
    	let h21;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let h40;
    	let t4_value = /*task01*/ ctx[0].qstOpt + "";
    	let t4;
    	let t5;
    	let h41;
    	let t7;
    	let button0;
    	let t8_value = /*task01*/ ctx[0].operatorNum[0] + "";
    	let t8;
    	let t9;
    	let button1;
    	let t10_value = /*task01*/ ctx[0].operatorNum[1] + "";
    	let t10;
    	let t11;
    	let h6;
    	let t12;
    	let t13_value = /*task01*/ ctx[0].answer + "";
    	let t13;
    	let t14;
    	let div3;
    	let h5;
    	let t15;
    	let t16;
    	let div4;
    	let button2;
    	let t18;
    	let button3;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h20 = element("h2");
    			h20.textContent = "Estimate sums and differences: word problems";
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h21 = element("h2");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			h40 = element("h4");
    			t4 = text(t4_value);
    			t5 = space();
    			h41 = element("h4");
    			h41.textContent = "The sum is approximately";
    			t7 = space();
    			button0 = element("button");
    			t8 = text(t8_value);
    			t9 = space();
    			button1 = element("button");
    			t10 = text(t10_value);
    			t11 = space();
    			h6 = element("h6");
    			t12 = text("answer");
    			t13 = text(t13_value);
    			t14 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t15 = text(/*showPopUp*/ ctx[2]);
    			t16 = space();
    			div4 = element("div");
    			button2 = element("button");
    			button2.textContent = "Rerun";
    			t18 = space();
    			button3 = element("button");
    			button3.textContent = "Exit This Skill";
    			attr_dev(h20, "class", "text-center display-4 mb-0");
    			add_location(h20, file$1J, 55, 10, 1033);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1J, 54, 6, 983);
    			add_location(h21, file$1J, 60, 12, 1237);
    			add_location(h40, file$1J, 62, 16, 1302);
    			add_location(h41, file$1J, 64, 16, 1362);
    			attr_dev(button0, "class", "btn btn-outline-success");
    			add_location(button0, file$1J, 65, 16, 1414);
    			attr_dev(button1, "class", "btn btn-outline-success");
    			add_location(button1, file$1J, 66, 16, 1551);
    			add_location(h6, file$1J, 67, 16, 1688);
    			add_location(div1, file$1J, 61, 12, 1276);
    			add_location(div2, file$1J, 59, 8, 1218);
    			set_style(h5, "display", /*showNext*/ ctx[1]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1J, 72, 12, 1786);
    			add_location(div3, file$1J, 71, 8, 1768);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1J, 76, 12, 1920);
    			attr_dev(button3, "type", "button");
    			attr_dev(button3, "class", "btn toggle-btn");
    			add_location(button3, file$1J, 77, 12, 2016);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$1J, 75, 8, 1889);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$1J, 58, 6, 1146);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$1J, 53, 5, 935);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$1J, 52, 1, 901);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h20);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h21);
    			append_dev(h21, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, h40);
    			append_dev(h40, t4);
    			append_dev(div1, t5);
    			append_dev(div1, h41);
    			append_dev(div1, t7);
    			append_dev(div1, button0);
    			append_dev(button0, t8);
    			append_dev(div1, t9);
    			append_dev(div1, button1);
    			append_dev(button1, t10);
    			append_dev(div1, t11);
    			append_dev(div1, h6);
    			append_dev(h6, t12);
    			append_dev(h6, t13);
    			append_dev(div5, t14);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t15);
    			append_dev(div5, t16);
    			append_dev(div5, div4);
    			append_dev(div4, button2);
    			append_dev(div4, t18);
    			append_dev(div4, button3);

    			if (!mounted) {
    				dispose = [
    					listen_dev(
    						button0,
    						"click",
    						function () {
    							if (is_function(/*handleClick*/ ctx[4](/*task01*/ ctx[0].operatorNum[0]))) /*handleClick*/ ctx[4](/*task01*/ ctx[0].operatorNum[0]).apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						button1,
    						"click",
    						function () {
    							if (is_function(/*handleClick*/ ctx[4](/*task01*/ ctx[0].operatorNum[1]))) /*handleClick*/ ctx[4](/*task01*/ ctx[0].operatorNum[1]).apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(button2, "click", /*NextQuestion*/ ctx[3], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*task01*/ 1 && t4_value !== (t4_value = /*task01*/ ctx[0].qstOpt + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].operatorNum[0] + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*task01*/ 1 && t10_value !== (t10_value = /*task01*/ ctx[0].operatorNum[1] + "")) set_data_dev(t10, t10_value);
    			if (dirty & /*task01*/ 1 && t13_value !== (t13_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t13, t13_value);
    			if (dirty & /*showPopUp*/ 4) set_data_dev(t15, /*showPopUp*/ ctx[2]);

    			if (dirty & /*showNext*/ 2) {
    				set_style(h5, "display", /*showNext*/ ctx[1]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1K.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1K($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GV_MA_B8", slots, []);
    	let task01 = taskOne$1s();
    	let answer;
    	let showNext = "none";
    	let showPopUp;

    	let CheckAnswer = function () {
    		if (answer == task01.answer) {
    			$$invalidate(2, showPopUp = randomCorrect());
    			$$invalidate(1, showNext = "inline-block");
    			return;
    		} else {
    			$$invalidate(2, showPopUp = randomWrong());
    			$$invalidate(1, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		answer = null;
    		$$invalidate(0, task01 = taskOne$1s());
    		$$invalidate(1, showNext = "none");
    	};

    	const handleClick = parameter => () => {
    		answer = parameter;
    		CheckAnswer();
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GV_MA_B8> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1s,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		handleClick
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) answer = $$props.answer;
    		if ("showNext" in $$props) $$invalidate(1, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(2, showPopUp = $$props.showPopUp);
    		if ("CheckAnswer" in $$props) CheckAnswer = $$props.CheckAnswer;
    		if ("NextQuestion" in $$props) $$invalidate(3, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [task01, showNext, showPopUp, NextQuestion, handleClick];
    }

    class GV_MA_B8 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1K, create_fragment$1K, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GV_MA_B8",
    			options,
    			id: create_fragment$1K.name
    		});
    	}
    }

    let task01$1r = {
        questionOption:["Which property of addition is shown?","Which equation shows the identity property of addition?"],
        question : '',
        startValue : 0,
        startText : '',
        startTextArray : ["Closure" , "Commutative","Associative" , "Identity"],
        optionTextArray : ["a + b = c" , "a+b = b+a ","(a+b) + c = a+(b+c)" , "a+0 = a"],
        endValue : 0,
        endText : '',
        answer : 0,
        endTextArray : ["ones" , "tens"]
    };

    const maxNumber$8 = 10;
    const minNumber$8 = 0;


    function taskOne$1r(){

        let qst = Math.floor(Math.random() * (task01$1r.questionOption.length - minNumber$8)) + minNumber$8;
        task01$1r.answer = Math.floor(Math.random() * (task01$1r.startTextArray.length - minNumber$8)) + minNumber$8;
        task01$1r.endValue = Math.floor(Math.random() * (task01$1r.startTextArray.length - minNumber$8)) + minNumber$8;
        task01$1r.startValue = qst;

        let a = Math.floor(Math.random() * maxNumber$8) + 1;
        let b = Math.floor(Math.random() * maxNumber$8) + 1;
        let c = Math.floor(Math.random() * maxNumber$8) + 1;
        task01$1r.optionTextArray[0] = (a+"+"+b+"="+(a+b)).toString();
        task01$1r.optionTextArray[1] = (a+"+"+b+"="+b+"+"+c).toString();
        task01$1r.optionTextArray[2] = ("("+a+"+"+b+") + "+c+" = "+a+"+("+b+"+"+c+")").toString();
        task01$1r.optionTextArray[3] = (a+"+0 = "+a).toString();
        if(qst != 0){
            task01$1r.questionOption[1] = "Which equation shows the "+ task01$1r.startTextArray[task01$1r.answer]+" property of addition?";
        }
        task01$1r.question = task01$1r.questionOption[qst];

        


        return task01$1r;
    }

    /* src/components/taskComponents/GIV_MA_B4.svelte generated by Svelte v3.37.0 */
    const file$1I = "src/components/taskComponents/GIV_MA_B4.svelte";

    function get_each_context_1$o(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	child_ctx[9] = i;
    	return child_ctx;
    }

    function get_each_context$1q(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	child_ctx[9] = i;
    	return child_ctx;
    }

    // (69:19) {:else}
    function create_else_block$14(ctx) {
    	let div;
    	let each_value_1 = /*task01*/ ctx[0].optionTextArray;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$o(get_each_context_1$o(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(div, file$1I, 69, 19, 1713);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*handleClick, task01*/ 17) {
    				each_value_1 = /*task01*/ ctx[0].optionTextArray;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$o(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$o(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$14.name,
    		type: "else",
    		source: "(69:19) {:else}",
    		ctx
    	});

    	return block;
    }

    // (62:15) {#if task01.startValue == 0}
    function create_if_block$1a(ctx) {
    	let h2;
    	let t0_value = /*task01*/ ctx[0].optionTextArray[/*task01*/ ctx[0].endValue] + "";
    	let t0;
    	let t1;
    	let div;
    	let each_value = /*task01*/ ctx[0].options;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1q(get_each_context$1q(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(h2, file$1I, 62, 20, 1328);
    			add_location(div, file$1I, 63, 20, 1399);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    			append_dev(h2, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].optionTextArray[/*task01*/ ctx[0].endValue] + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*handleClick, task01*/ 17) {
    				each_value = /*task01*/ ctx[0].options;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1q(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1q(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1a.name,
    		type: "if",
    		source: "(62:15) {#if task01.startValue == 0}",
    		ctx
    	});

    	return block;
    }

    // (71:20) {#each  task01.optionTextArray as optionValue, i}
    function create_each_block_1$o(ctx) {
    	let button;
    	let t_value = /*optionValue*/ ctx[7] + "";
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "class", "btn btn-outline-success");
    			add_location(button, file$1I, 71, 20, 1809);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleClick*/ ctx[4](/*i*/ ctx[9]), false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*optionValue*/ ctx[7] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$o.name,
    		type: "each",
    		source: "(71:20) {#each  task01.optionTextArray as optionValue, i}",
    		ctx
    	});

    	return block;
    }

    // (65:24) {#each  task01.options as optionValue,i }
    function create_each_block$1q(ctx) {
    	let button;
    	let t_value = /*optionValue*/ ctx[7] + "";
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "class", "btn btn-outline-success");
    			add_location(button, file$1I, 65, 24, 1495);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleClick*/ ctx[4](/*i*/ ctx[9]), false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*optionValue*/ ctx[7] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1q.name,
    		type: "each",
    		source: "(65:24) {#each  task01.options as optionValue,i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1J(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h20;
    	let t1;
    	let div5;
    	let div2;
    	let h21;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let t4;
    	let h3;
    	let t5_value = /*task01*/ ctx[0].answer + "";
    	let t5;
    	let t6;
    	let div3;
    	let h5;
    	let t7;
    	let t8;
    	let div4;
    	let button0;
    	let t10;
    	let button1;
    	let mounted;
    	let dispose;

    	function select_block_type(ctx, dirty) {
    		if (/*task01*/ ctx[0].startValue == 0) return create_if_block$1a;
    		return create_else_block$14;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h20 = element("h2");
    			h20.textContent = "Properties of addition";
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h21 = element("h2");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			if_block.c();
    			t4 = space();
    			h3 = element("h3");
    			t5 = text(t5_value);
    			t6 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t7 = text(/*showPopUp*/ ctx[2]);
    			t8 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Rerun";
    			t10 = space();
    			button1 = element("button");
    			button1.textContent = "Exit This Skill";
    			attr_dev(h20, "class", "text-center display-4 mb-0");
    			add_location(h20, file$1I, 54, 10, 1032);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1I, 53, 6, 982);
    			add_location(h21, file$1I, 59, 12, 1215);
    			add_location(h3, file$1I, 76, 15, 2004);
    			add_location(div1, file$1I, 60, 12, 1254);
    			add_location(div2, file$1I, 58, 8, 1196);
    			set_style(h5, "display", /*showNext*/ ctx[1]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1I, 82, 12, 2097);
    			add_location(div3, file$1I, 81, 8, 2079);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1I, 87, 12, 2232);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1I, 88, 12, 2328);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$1I, 85, 8, 2200);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$1I, 57, 6, 1124);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$1I, 52, 5, 934);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$1I, 51, 1, 900);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h20);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h21);
    			append_dev(h21, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			if_block.m(div1, null);
    			append_dev(div1, t4);
    			append_dev(div1, h3);
    			append_dev(h3, t5);
    			append_dev(div5, t6);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t7);
    			append_dev(div5, t8);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t10);
    			append_dev(div4, button1);

    			if (!mounted) {
    				dispose = listen_dev(button0, "click", /*NextQuestion*/ ctx[3], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div1, t4);
    				}
    			}

    			if (dirty & /*task01*/ 1 && t5_value !== (t5_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t5, t5_value);
    			if (dirty & /*showPopUp*/ 4) set_data_dev(t7, /*showPopUp*/ ctx[2]);

    			if (dirty & /*showNext*/ 2) {
    				set_style(h5, "display", /*showNext*/ ctx[1]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1J.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1J($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GIV_MA_B4", slots, []);
    	let task01 = taskOne$1r();
    	let answer;
    	let showNext = "none";
    	let showPopUp;

    	let CheckAnswer = function () {
    		if (answer == task01.answer) {
    			$$invalidate(2, showPopUp = randomCorrect());
    			$$invalidate(1, showNext = "inline-block");
    			return;
    		} else {
    			$$invalidate(2, showPopUp = randomWrong());
    			$$invalidate(1, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		answer = null;
    		$$invalidate(0, task01 = taskOne$1r());
    		$$invalidate(1, showNext = "none");
    	};

    	const handleClick = parameter => () => {
    		answer = parameter;
    		CheckAnswer();
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GIV_MA_B4> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1r,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		handleClick
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) answer = $$props.answer;
    		if ("showNext" in $$props) $$invalidate(1, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(2, showPopUp = $$props.showPopUp);
    		if ("CheckAnswer" in $$props) CheckAnswer = $$props.CheckAnswer;
    		if ("NextQuestion" in $$props) $$invalidate(3, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [task01, showNext, showPopUp, NextQuestion, handleClick];
    }

    class GIV_MA_B4 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1J, create_fragment$1J, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GIV_MA_B4",
    			options,
    			id: create_fragment$1J.name
    		});
    	}
    }

    /* src/components/taskComponents/GIV_MA_B5.svelte generated by Svelte v3.37.0 */
    const file$1H = "src/components/taskComponents/GIV_MA_B5.svelte";

    function get_each_context$1p(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	child_ctx[12] = i;
    	return child_ctx;
    }

    // (74:28) {:else}
    function create_else_block$13(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[10] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$1H, 75, 32, 2135);
    			add_location(tr, file$1H, 74, 28, 2098);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[10] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$13.name,
    		type: "else",
    		source: "(74:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (70:28) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$19(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[10] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$1H, 71, 50, 1931);
    			attr_dev(td, "align", "right");
    			add_location(td, file$1H, 71, 32, 1913);
    			add_location(tr, file$1H, 70, 28, 1876);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[10] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$19.name,
    		type: "if",
    		source: "(70:28) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (69:24) {#each task01.valueArray as col, i }
    function create_each_block$1p(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[12] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$19;
    		return create_else_block$13;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1p.name,
    		type: "each",
    		source: "(69:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1I(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let solution;
    	let t12;
    	let div4;
    	let button0;
    	let t14;
    	let button1;
    	let t16;
    	let button2;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1p(get_each_context$1p(ctx, each_value, i));
    	}

    	solution = new AdditionSolution({
    			props: {
    				num_qnty: /*task01*/ ctx[0].columns,
    				usr_resp: /*answer*/ ctx[1],
    				num: /*task01*/ ctx[0].valueArray,
    				ans_submit: /*showSolution*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			create_component(solution.$$.fragment);
    			t12 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t14 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t16 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$1H, 55, 10, 1401);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1H, 54, 6, 1351);
    			add_location(h4, file$1H, 62, 12, 1579);
    			attr_dev(table, "width", "100");
    			add_location(table, file$1H, 66, 16, 1651);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$1H, 80, 20, 2328);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$1H, 81, 20, 2423);
    			add_location(h6, file$1H, 82, 20, 2545);
    			add_location(div1, file$1H, 64, 12, 1624);
    			add_location(div2, file$1H, 59, 8, 1558);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1H, 87, 12, 2653);
    			add_location(div3, file$1H, 86, 8, 2635);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1H, 91, 12, 2897);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1H, 92, 12, 2993);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1H, 93, 12, 3089);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$1H, 90, 8, 2866);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$1H, 58, 6, 1486);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$1H, 53, 5, 1303);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$1H, 52, 1, 1269);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			mount_component(solution, div5, null);
    			append_dev(div5, t12);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t14);
    			append_dev(div4, button1);
    			append_dev(div4, t16);
    			append_dev(div4, button2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[7]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*task01*/ 1) && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*task01*/ 1) && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1p(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1p(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if ((!current || dirty & /*task01*/ 1) && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (!current || dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (!current || dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}

    			const solution_changes = {};
    			if (dirty & /*task01*/ 1) solution_changes.num_qnty = /*task01*/ ctx[0].columns;
    			if (dirty & /*answer*/ 2) solution_changes.usr_resp = /*answer*/ ctx[1];
    			if (dirty & /*task01*/ 1) solution_changes.num = /*task01*/ ctx[0].valueArray;
    			if (dirty & /*showSolution*/ 16) solution_changes.ans_submit = /*showSolution*/ ctx[4];
    			solution.$set(solution_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			destroy_component(solution);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const max$r = 9999;
    const min$r = 1;

    function instance$1I($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GIV_MA_B5", slots, []);
    	let heading = "Add three or more numbers up to five digits each";
    	let question = "Add :";
    	let task01 = taskOne$1C();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			$$invalidate(4, showSolution = true);
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		let numberofColumn = Math.floor(Math.random() * (5 - 3)) + 3;
    		MaxandMin$5(max$r, min$r, numberofColumn, heading, question);
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$1C());
    		$$invalidate(4, showSolution = false);
    		$$invalidate(2, showNext = "none");
    	};

    	NextQuestion();
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GIV_MA_B5> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1C,
    		randomCorrect,
    		randomWrong,
    		MaxandMin: MaxandMin$5,
    		Solution: AdditionSolution,
    		heading,
    		question,
    		max: max$r,
    		min: min$r,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("heading" in $$props) heading = $$props.heading;
    		if ("question" in $$props) question = $$props.question;
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) $$invalidate(4, showSolution = $$props.showSolution);
    		if ("CheckAnswer" in $$props) $$invalidate(5, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(6, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class GIV_MA_B5 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1I, create_fragment$1I, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GIV_MA_B5",
    			options,
    			id: create_fragment$1I.name
    		});
    	}
    }

    let task01$1q = {
      question: "",
      displayValue: 0,
      displayValueTwo: 0,
      displayValueThree: 0,
      Options: [1, 10, 100, 1000, 10000, 100000],
      variations: 0,
      randomAnswer: 0,
    };
        const maxNumber$7 = 15;
        const minNumber$7 = 1;
        
    function taskOne$1q() {

        task01$1q.variations =  Math.floor(Math.random() * 3 - 1) + 1;
      task01$1q.displayValueOne = Math.floor(Math.random() * maxNumber$7 - minNumber$7) + minNumber$7;
      task01$1q.displayValueTwo = Math.floor(Math.random() * maxNumber$7 - minNumber$7) + minNumber$7;
      

      task01$1q.question = "Complete the pattern:";
      
      return task01$1q;
    }

    /* src/components/taskComponents/GIV_MA_B6.svelte generated by Svelte v3.37.0 */
    const file$1G = "src/components/taskComponents/GIV_MA_B6.svelte";

    function get_each_context$1o(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	child_ctx[10] = list;
    	child_ctx[11] = i;
    	return child_ctx;
    }

    function get_each_context_1$n(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	child_ctx[12] = list;
    	child_ctx[11] = i;
    	return child_ctx;
    }

    function get_each_context_2$8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	child_ctx[13] = list;
    	child_ctx[11] = i;
    	return child_ctx;
    }

    // (96:16) {#if 0 == task01.variations}
    function create_if_block_2$d(ctx) {
    	let each_1_anchor;
    	let each_value_2 = /*task01*/ ctx[2].Options;
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$8(get_each_context_2$8(ctx, each_value_2, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01, answer*/ 12) {
    				each_value_2 = /*task01*/ ctx[2].Options;
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$8(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_2$8(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_2.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$d.name,
    		type: "if",
    		source: "(96:16) {#if 0 == task01.variations}",
    		ctx
    	});

    	return block;
    }

    // (97:20) {#each  task01.Options as optionValue,i }
    function create_each_block_2$8(ctx) {
    	let div;
    	let t0_value = /*task01*/ ctx[2].displayValueOne * /*optionValue*/ ctx[9] + "";
    	let t0;
    	let t1;
    	let input;
    	let t2;
    	let t3_value = (/*task01*/ ctx[2].displayValueOne + /*task01*/ ctx[2].displayValueTwo) * /*optionValue*/ ctx[9] + "";
    	let t3;
    	let mounted;
    	let dispose;

    	function input_input_handler() {
    		/*input_input_handler*/ ctx[6].call(input, /*i*/ ctx[11]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = text(" + ");
    			input = element("input");
    			t2 = text(" = ");
    			t3 = text(t3_value);
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			add_location(input, file$1G, 97, 65, 2666);
    			add_location(div, file$1G, 97, 20, 2621);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, input);
    			set_input_value(input, /*answer*/ ctx[3][/*i*/ ctx[11]]);
    			append_dev(div, t2);
    			append_dev(div, t3);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*task01*/ 4 && t0_value !== (t0_value = /*task01*/ ctx[2].displayValueOne * /*optionValue*/ ctx[9] + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*answer*/ 8 && input.value !== /*answer*/ ctx[3][/*i*/ ctx[11]]) {
    				set_input_value(input, /*answer*/ ctx[3][/*i*/ ctx[11]]);
    			}

    			if (dirty & /*task01*/ 4 && t3_value !== (t3_value = (/*task01*/ ctx[2].displayValueOne + /*task01*/ ctx[2].displayValueTwo) * /*optionValue*/ ctx[9] + "")) set_data_dev(t3, t3_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$8.name,
    		type: "each",
    		source: "(97:20) {#each  task01.Options as optionValue,i }",
    		ctx
    	});

    	return block;
    }

    // (102:15) {#if 1 == task01.variations}
    function create_if_block_1$d(ctx) {
    	let each_1_anchor;
    	let each_value_1 = /*task01*/ ctx[2].Options;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$n(get_each_context_1$n(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*answer, task01*/ 12) {
    				each_value_1 = /*task01*/ ctx[2].Options;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$n(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$n(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$d.name,
    		type: "if",
    		source: "(102:15) {#if 1 == task01.variations}",
    		ctx
    	});

    	return block;
    }

    // (103:15) {#each  task01.Options as optionValue,i }
    function create_each_block_1$n(ctx) {
    	let div;
    	let t0_value = /*task01*/ ctx[2].displayValueOne * /*optionValue*/ ctx[9] + "";
    	let t0;
    	let t1;
    	let t2_value = /*task01*/ ctx[2].displayValueTwo * /*optionValue*/ ctx[9] + "";
    	let t2;
    	let t3;
    	let input;
    	let t4;
    	let mounted;
    	let dispose;

    	function input_input_handler_1() {
    		/*input_input_handler_1*/ ctx[7].call(input, /*i*/ ctx[11]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = text(" + ");
    			t2 = text(t2_value);
    			t3 = text(" = ");
    			input = element("input");
    			t4 = space();
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			add_location(input, file$1G, 103, 100, 3120);
    			add_location(div, file$1G, 103, 15, 3035);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);
    			append_dev(div, t3);
    			append_dev(div, input);
    			set_input_value(input, /*answer*/ ctx[3][/*i*/ ctx[11]]);
    			append_dev(div, t4);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler_1);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*task01*/ 4 && t0_value !== (t0_value = /*task01*/ ctx[2].displayValueOne * /*optionValue*/ ctx[9] + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 4 && t2_value !== (t2_value = /*task01*/ ctx[2].displayValueTwo * /*optionValue*/ ctx[9] + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*answer*/ 8 && input.value !== /*answer*/ ctx[3][/*i*/ ctx[11]]) {
    				set_input_value(input, /*answer*/ ctx[3][/*i*/ ctx[11]]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$n.name,
    		type: "each",
    		source: "(103:15) {#each  task01.Options as optionValue,i }",
    		ctx
    	});

    	return block;
    }

    // (107:10) {#if 2 == task01.variations}
    function create_if_block$18(ctx) {
    	let each_1_anchor;
    	let each_value = /*task01*/ ctx[2].Options;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1o(get_each_context$1o(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01, answer*/ 12) {
    				each_value = /*task01*/ ctx[2].Options;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1o(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1o(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$18.name,
    		type: "if",
    		source: "(107:10) {#if 2 == task01.variations}",
    		ctx
    	});

    	return block;
    }

    // (108:20) {#each  task01.Options as optionValue,i }
    function create_each_block$1o(ctx) {
    	let div;
    	let input;
    	let t0;
    	let t1_value = /*task01*/ ctx[2].displayValueTwo * /*optionValue*/ ctx[9] + "";
    	let t1;
    	let t2;
    	let t3_value = (/*task01*/ ctx[2].displayValueOne + /*task01*/ ctx[2].displayValueTwo) * /*optionValue*/ ctx[9] + "";
    	let t3;
    	let mounted;
    	let dispose;

    	function input_input_handler_2() {
    		/*input_input_handler_2*/ ctx[8].call(input, /*i*/ ctx[11]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			input = element("input");
    			t0 = text("+ ");
    			t1 = text(t1_value);
    			t2 = text(" = ");
    			t3 = text(t3_value);
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			add_location(input, file$1G, 108, 25, 3399);
    			add_location(div, file$1G, 108, 20, 3394);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, input);
    			set_input_value(input, /*answer*/ ctx[3][/*i*/ ctx[11]]);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);
    			append_dev(div, t3);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler_2);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*answer*/ 8 && input.value !== /*answer*/ ctx[3][/*i*/ ctx[11]]) {
    				set_input_value(input, /*answer*/ ctx[3][/*i*/ ctx[11]]);
    			}

    			if (dirty & /*task01*/ 4 && t1_value !== (t1_value = /*task01*/ ctx[2].displayValueTwo * /*optionValue*/ ctx[9] + "")) set_data_dev(t1, t1_value);
    			if (dirty & /*task01*/ 4 && t3_value !== (t3_value = (/*task01*/ ctx[2].displayValueOne + /*task01*/ ctx[2].displayValueTwo) * /*optionValue*/ ctx[9] + "")) set_data_dev(t3, t3_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1o.name,
    		type: "each",
    		source: "(108:20) {#each  task01.Options as optionValue,i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1H(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h20;
    	let t1;
    	let div5;
    	let div2;
    	let h21;
    	let t2_value = /*task01*/ ctx[2].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let t4;
    	let t5;
    	let t6;
    	let div3;
    	let h5;
    	let t7;
    	let t8;
    	let div4;
    	let button0;
    	let t10;
    	let button1;
    	let t12;
    	let button2;
    	let mounted;
    	let dispose;
    	let if_block0 = 0 == /*task01*/ ctx[2].variations && create_if_block_2$d(ctx);
    	let if_block1 = 1 == /*task01*/ ctx[2].variations && create_if_block_1$d(ctx);
    	let if_block2 = 2 == /*task01*/ ctx[2].variations && create_if_block$18(ctx);

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h20 = element("h2");
    			h20.textContent = "Multiplication patterns over increasing place values";
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h21 = element("h2");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			if (if_block0) if_block0.c();
    			t4 = space();
    			if (if_block1) if_block1.c();
    			t5 = space();
    			if (if_block2) if_block2.c();
    			t6 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t7 = text(/*showPopUp*/ ctx[1]);
    			t8 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t10 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t12 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h20, "class", "text-center display-4 mb-0");
    			add_location(h20, file$1G, 85, 10, 2202);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1G, 84, 6, 2152);
    			add_location(h21, file$1G, 92, 12, 2416);
    			attr_dev(div1, "class", " p-2");
    			add_location(div1, file$1G, 93, 12, 2456);
    			add_location(div2, file$1G, 91, 8, 2397);
    			set_style(h5, "display", /*showNext*/ ctx[0]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1G, 115, 13, 3743);
    			add_location(div3, file$1G, 114, 10, 3724);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1G, 118, 12, 3875);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1G, 119, 12, 3971);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1G, 120, 12, 4067);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$1G, 117, 10, 3844);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$1G, 89, 6, 2324);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$1G, 83, 5, 2104);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$1G, 82, 1, 2070);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h20);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h21);
    			append_dev(h21, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			if (if_block0) if_block0.m(div1, null);
    			append_dev(div1, t4);
    			if (if_block1) if_block1.m(div1, null);
    			append_dev(div1, t5);
    			if (if_block2) if_block2.m(div1, null);
    			append_dev(div5, t6);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t7);
    			append_dev(div5, t8);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t10);
    			append_dev(div4, button1);
    			append_dev(div4, t12);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 4 && t2_value !== (t2_value = /*task01*/ ctx[2].question + "")) set_data_dev(t2, t2_value);

    			if (0 == /*task01*/ ctx[2].variations) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_2$d(ctx);
    					if_block0.c();
    					if_block0.m(div1, t4);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (1 == /*task01*/ ctx[2].variations) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_1$d(ctx);
    					if_block1.c();
    					if_block1.m(div1, t5);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (2 == /*task01*/ ctx[2].variations) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block$18(ctx);
    					if_block2.c();
    					if_block2.m(div1, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (dirty & /*showPopUp*/ 2) set_data_dev(t7, /*showPopUp*/ ctx[1]);

    			if (dirty & /*showNext*/ 1) {
    				set_style(h5, "display", /*showNext*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1H($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GIV_MA_B6", slots, []);
    	let showNext = "none";
    	let showPopUp;
    	let task01 = taskOne$1q();
    	let answer = new Array(task01.Options.length);

    	let CheckAnswer = function () {
    		if (task01.variations == 0) {
    			for (let index = 0; index < answer.length; index++) {
    				if (answer[index] != task01.displayValueTwo * task01.Options[index]) {
    					$$invalidate(1, showPopUp = randomWrong());
    					$$invalidate(0, showNext = "inline-block");
    					break;
    				}

    				if (index == answer.length - 1) {
    					$$invalidate(1, showPopUp = randomCorrect());
    					$$invalidate(0, showNext = "inline-block");
    				}
    			}
    		} else if (task01.variations == 1) {
    			for (let index = 0; index < answer.length; index++) {
    				if (answer[index] != (task01.displayValueOne + task01.displayValueTwo) * task01.Options[index]) {
    					$$invalidate(1, showPopUp = randomWrong());
    					$$invalidate(0, showNext = "inline-block");
    					break;
    				}

    				if (index == answer.length - 1) {
    					$$invalidate(1, showPopUp = randomCorrect());
    					$$invalidate(0, showNext = "inline-block");
    				}
    			}
    		} else {
    			for (let index = 0; index < answer.length; index++) {
    				if (answer[index] != task01.displayValueOne * task01.Options[index]) {
    					$$invalidate(1, showPopUp = randomWrong());
    					$$invalidate(0, showNext = "inline-block");
    					break;
    				}

    				if (index == answer.length - 1) {
    					$$invalidate(1, showPopUp = randomCorrect());
    					$$invalidate(0, showNext = "inline-block");
    				}
    			}
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(3, answer = []);
    		$$invalidate(2, task01 = taskOne$1q());
    		$$invalidate(3, answer = new Array(task01.Options.length));
    		$$invalidate(0, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GIV_MA_B6> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler(i) {
    		answer[i] = this.value;
    		$$invalidate(3, answer);
    	}

    	function input_input_handler_1(i) {
    		answer[i] = this.value;
    		$$invalidate(3, answer);
    	}

    	function input_input_handler_2(i) {
    		answer[i] = this.value;
    		$$invalidate(3, answer);
    	}

    	$$self.$capture_state = () => ({
    		randomCorrect,
    		randomWrong,
    		taskOne: taskOne$1q,
    		showNext,
    		showPopUp,
    		task01,
    		answer,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("showNext" in $$props) $$invalidate(0, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(1, showPopUp = $$props.showPopUp);
    		if ("task01" in $$props) $$invalidate(2, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(3, answer = $$props.answer);
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		showNext,
    		showPopUp,
    		task01,
    		answer,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler,
    		input_input_handler_1,
    		input_input_handler_2
    	];
    }

    class GIV_MA_B6 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1H, create_fragment$1H, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GIV_MA_B6",
    			options,
    			id: create_fragment$1H.name
    		});
    	}
    }

    let task01$1p = {    
        question: " Choose numbers with a particular sum ",
        ValueOne: 0,
        ValueTwo: 0,
        answer: 0,
        sum:'+',
        option : [0,0],
        displayValues : [],
        
      };
      let arraylenght$1 = 8;
      
      function taskOne$1p() {
        let arraySize =  Math.floor(Math.random() * (arraylenght$1 - 4)) + 4;    task01$1p.displayValues = randomNumbers$1(arraySize,1000,1);
        let temp = randomNumbers$1(task01$1p.option.length,task01$1p.displayValues.length,0);
        for (let i = 0; i < temp.length; i++) {
            task01$1p.option[i]=task01$1p.displayValues[temp[i]];
        }    
        task01$1p.answer = Math.abs(task01$1p.option[0] + task01$1p.option[1]);     
       
        return task01$1p;
      }
      

      function randomNumbers$1(count, max , min){
        var stop = count;
        var numbers = [];
        for (let i = 0; i < stop; i++) {
        var n =  Math.floor(Math.random() * (max - min)) + min;
        var check = numbers.includes(n);
            
            if(check === false) {
                numbers.push(n);
            } else {
                while(check === true){
                n =  Math.floor(Math.random() * (max - min)) + min;
                check = numbers.includes(n);
                    if(check === false){
                    numbers.push(n);
                    }
                }
            }
            }
        return numbers;
      }

    /* src/components/taskComponents/GIV_MA_B7.svelte generated by Svelte v3.37.0 */
    const file$1F = "src/components/taskComponents/GIV_MA_B7.svelte";

    function get_each_context$1n(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    // (63:15) {#each task01.displayValues as displayValue}
    function create_each_block$1n(ctx) {
    	let div;
    	let h1;
    	let t_value = /*displayValue*/ ctx[9] + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			h1 = element("h1");
    			t = text(t_value);
    			add_location(h1, file$1F, 63, 24, 1474);
    			add_location(div, file$1F, 63, 19, 1469);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h1);
    			append_dev(h1, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*displayValue*/ ctx[9] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1n.name,
    		type: "each",
    		source: "(63:15) {#each task01.displayValues as displayValue}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1G(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h20;
    	let t1;
    	let div5;
    	let div2;
    	let div1;
    	let t2;
    	let input0;
    	let t3;
    	let h21;
    	let t5;
    	let input1;
    	let t6;
    	let h22;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let t10;
    	let h23;
    	let t11_value = /*task01*/ ctx[0].option + "";
    	let t11;
    	let t12;
    	let t13;
    	let div3;
    	let h5;
    	let t14;
    	let t15;
    	let div4;
    	let button0;
    	let t17;
    	let button1;
    	let t19;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].displayValues;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1n(get_each_context$1n(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h20 = element("h2");
    			h20.textContent = "Choose numbers with a particular sum";
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t2 = space();
    			input0 = element("input");
    			t3 = space();
    			h21 = element("h2");
    			h21.textContent = "and";
    			t5 = space();
    			input1 = element("input");
    			t6 = space();
    			h22 = element("h2");
    			t7 = text("have a difference of ");
    			t8 = text(t8_value);
    			t9 = text(".");
    			t10 = space();
    			h23 = element("h2");
    			t11 = text(t11_value);
    			t12 = text(".");
    			t13 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t14 = text(/*showPopUp*/ ctx[4]);
    			t15 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t17 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t19 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h20, "class", "text-center display-4 mb-0");
    			add_location(h20, file$1F, 55, 9, 1176);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1F, 54, 5, 1127);
    			attr_dev(input0, "type", "text");
    			set_style(input0, "margin-left", "5px");
    			add_location(input0, file$1F, 65, 15, 1549);
    			add_location(h21, file$1F, 66, 15, 1635);
    			attr_dev(input1, "type", "text");
    			set_style(input1, "margin-left", "5px");
    			add_location(input1, file$1F, 67, 15, 1666);
    			add_location(h22, file$1F, 68, 15, 1752);
    			add_location(h23, file$1F, 69, 15, 1815);
    			add_location(div1, file$1F, 61, 11, 1380);
    			add_location(div2, file$1F, 59, 7, 1350);
    			set_style(h5, "display", /*showNext*/ ctx[3]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1F, 74, 8, 1902);
    			add_location(div3, file$1F, 73, 7, 1888);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1F, 78, 8, 2020);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1F, 79, 8, 2112);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1F, 80, 8, 2204);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$1F, 77, 4, 1993);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$1F, 58, 5, 1279);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$1F, 53, 4, 1080);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$1F, 52, 1, 1047);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h20);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			append_dev(div1, t2);
    			append_dev(div1, input0);
    			set_input_value(input0, /*answer01*/ ctx[1]);
    			append_dev(div1, t3);
    			append_dev(div1, h21);
    			append_dev(div1, t5);
    			append_dev(div1, input1);
    			set_input_value(input1, /*answer02*/ ctx[2]);
    			append_dev(div1, t6);
    			append_dev(div1, h22);
    			append_dev(h22, t7);
    			append_dev(h22, t8);
    			append_dev(h22, t9);
    			append_dev(div1, t10);
    			append_dev(div1, h23);
    			append_dev(h23, t11);
    			append_dev(h23, t12);
    			append_dev(div5, t13);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t14);
    			append_dev(div5, t15);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t17);
    			append_dev(div4, button1);
    			append_dev(div4, t19);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[7]),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[8]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].displayValues;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1n(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1n(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, t2);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer01*/ 2 && input0.value !== /*answer01*/ ctx[1]) {
    				set_input_value(input0, /*answer01*/ ctx[1]);
    			}

    			if (dirty & /*answer02*/ 4 && input1.value !== /*answer02*/ ctx[2]) {
    				set_input_value(input1, /*answer02*/ ctx[2]);
    			}

    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*task01*/ 1 && t11_value !== (t11_value = /*task01*/ ctx[0].option + "")) set_data_dev(t11, t11_value);
    			if (dirty & /*showPopUp*/ 16) set_data_dev(t14, /*showPopUp*/ ctx[4]);

    			if (dirty & /*showNext*/ 8) {
    				set_style(h5, "display", /*showNext*/ ctx[3]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1G($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GIV_MA_B7", slots, []);
    	let task01 = taskOne$1p();
    	let answer01, answer02;
    	let showNext = "none";
    	let showPopUp;

    	let CheckAnswer = function () {
    		if (answer01 == task01.option[0] && answer02 == task01.option[1]) {
    			$$invalidate(4, showPopUp = randomCorrect());
    			$$invalidate(3, showNext = "inline-block");
    		} else if (answer01 == task01.option[1] && answer02 == task01.option[0]) {
    			$$invalidate(4, showPopUp = randomCorrect());
    			$$invalidate(3, showNext = "inline-block");
    		} else {
    			$$invalidate(4, showPopUp = randomWrong());
    			$$invalidate(3, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer01 = null);
    		$$invalidate(2, answer02 = null);
    		$$invalidate(0, task01 = taskOne$1p());
    		$$invalidate(3, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GIV_MA_B7> was created with unknown prop '${key}'`);
    	});

    	function input0_input_handler() {
    		answer01 = this.value;
    		$$invalidate(1, answer01);
    	}

    	function input1_input_handler() {
    		answer02 = this.value;
    		$$invalidate(2, answer02);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1p,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer01,
    		answer02,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer01" in $$props) $$invalidate(1, answer01 = $$props.answer01);
    		if ("answer02" in $$props) $$invalidate(2, answer02 = $$props.answer02);
    		if ("showNext" in $$props) $$invalidate(3, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(4, showPopUp = $$props.showPopUp);
    		if ("CheckAnswer" in $$props) $$invalidate(5, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(6, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer01,
    		answer02,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input0_input_handler,
    		input1_input_handler
    	];
    }

    class GIV_MA_B7 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1G, create_fragment$1G, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GIV_MA_B7",
    			options,
    			id: create_fragment$1G.name
    		});
    	}
    }

    let task01$1o = {
      question: "Estimate the sum by rounding each number to the nearest thousand and then adding.",
      displayValue: 0,
      displayValueTwo: 0,
      answer: 0,
      randomAnswer: 0,
      options: [1000, 10, 100],
      Disoptions: ["thousand", "ten", "hundred"],
      variation : 0,
      operatorNum : 0,
      qstOpt : "",
      displayOptions : []

    };

    const maxNumber$6 = 10000;
    const minNumber$6 = 100;

    function taskOne$1o() {
        task01$1o.randomAnswer = Math.floor(Math.random() * (task01$1o.options.length));
        task01$1o.variation = Math.floor(Math.random() * 2);
        task01$1o.displayValue = Math.floor(Math.random() * (maxNumber$6 - minNumber$6)) + minNumber$6;
        task01$1o.displayValueTwo = Math.floor(Math.random() * (maxNumber$6 - minNumber$6)) + minNumber$6;
        task01$1o.answer = roundUp(task01$1o.displayValue,task01$1o.options[task01$1o.randomAnswer]) + roundUp(task01$1o.displayValueTwo,task01$1o.options[task01$1o.randomAnswer]);
        task01$1o.qstOpt = task01$1o.displayValue + " + " + task01$1o.displayValueTwo; 
        task01$1o.question = "Estimate the sum by rounding each number to the nearest "+ task01$1o.Disoptions[task01$1o.randomAnswer] ;

        return task01$1o;
    }

    /* src/components/taskComponents/GIV_MA_B8.svelte generated by Svelte v3.37.0 */
    const file$1E = "src/components/taskComponents/GIV_MA_B8.svelte";

    function create_fragment$1F(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h20;
    	let t1;
    	let div5;
    	let div2;
    	let h21;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let h40;
    	let t4_value = /*task01*/ ctx[0].qstOpt + "";
    	let t4;
    	let t5;
    	let h41;
    	let t7;
    	let input;
    	let t8;
    	let h6;
    	let t9;
    	let t10_value = /*task01*/ ctx[0].answer + "";
    	let t10;
    	let t11;
    	let div3;
    	let h5;
    	let t12;
    	let t13;
    	let div4;
    	let button0;
    	let t15;
    	let button1;
    	let t17;
    	let button2;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h20 = element("h2");
    			h20.textContent = "Estimate sums and differences of whole numbers";
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h21 = element("h2");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			h40 = element("h4");
    			t4 = text(t4_value);
    			t5 = space();
    			h41 = element("h4");
    			h41.textContent = "The sum is approximately";
    			t7 = space();
    			input = element("input");
    			t8 = space();
    			h6 = element("h6");
    			t9 = text("answer");
    			t10 = text(t10_value);
    			t11 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t12 = text(/*showPopUp*/ ctx[3]);
    			t13 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t15 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t17 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h20, "class", "text-center display-4 mb-0");
    			add_location(h20, file$1E, 51, 10, 932);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1E, 50, 6, 882);
    			add_location(h21, file$1E, 57, 12, 1140);
    			add_location(h40, file$1E, 59, 16, 1205);
    			add_location(h41, file$1E, 61, 16, 1265);
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$1E, 62, 16, 1317);
    			add_location(h6, file$1E, 64, 16, 1435);
    			add_location(div1, file$1E, 58, 12, 1179);
    			add_location(div2, file$1E, 56, 8, 1121);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1E, 70, 12, 1535);
    			add_location(div3, file$1E, 69, 8, 1517);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1E, 74, 12, 1669);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1E, 75, 12, 1765);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1E, 76, 12, 1861);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$1E, 73, 8, 1638);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$1E, 54, 6, 1047);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$1E, 49, 5, 834);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$1E, 48, 1, 800);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h20);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h21);
    			append_dev(h21, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, h40);
    			append_dev(h40, t4);
    			append_dev(div1, t5);
    			append_dev(div1, h41);
    			append_dev(div1, t7);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t8);
    			append_dev(div1, h6);
    			append_dev(h6, t9);
    			append_dev(h6, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t12);
    			append_dev(div5, t13);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t15);
    			append_dev(div4, button1);
    			append_dev(div4, t17);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*task01*/ 1 && t4_value !== (t4_value = /*task01*/ ctx[0].qstOpt + "")) set_data_dev(t4, t4_value);

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t10_value !== (t10_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t10, t10_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t12, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1F($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GIV_MA_B8", slots, []);
    	let task01 = taskOne$1o();
    	let answer;
    	let showNext = "none";
    	let showPopUp;

    	let CheckAnswer = function () {
    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			$$invalidate(2, showNext = "inline-block");
    			return;
    		} else {
    			$$invalidate(3, showPopUp = randomWrong());
    			$$invalidate(2, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$1o());
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GIV_MA_B8> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1o,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class GIV_MA_B8 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1F, create_fragment$1F, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GIV_MA_B8",
    			options,
    			id: create_fragment$1F.name
    		});
    	}
    }

    let task01$1n = {
      question: "There were originally 987 houses in Columbia County. During a housing boom, developers built 820 more. About how many houses are there now in Columbia County? Choose the better estimate.",
      displayValue: 0,
      displayValueTwo: 0,
      answer: 0,
      randomAnswer: 0,
      options: [10, 100],
      Disoptions: [ "ten", "hundred"],

      operatorNum : [0,0],
      qstOpt : ""
        
    };
    const maxNumber$5 = 1000;
    const minNumber$5 = 10;

    function taskOne$1n() {
        task01$1n.randomAnswer = Math.floor(Math.random() * (task01$1n.options.length));
      
        task01$1n.displayValue = Math.floor(Math.random() * (maxNumber$5 - minNumber$5)) + minNumber$5;   
        
        task01$1n.displayValueTwo = Math.floor(Math.random() *(maxNumber$5 - minNumber$5)) + minNumber$5;
        task01$1n.operatorNum[0] = roundUp(task01$1n.displayValue,task01$1n.options[task01$1n.randomAnswer]) + roundUp(task01$1n.displayValueTwo,task01$1n.options[task01$1n.randomAnswer]);
        task01$1n.operatorNum[1] = Math.abs(roundUp(task01$1n.displayValue,task01$1n.options[task01$1n.randomAnswer]) - roundUp(task01$1n.displayValueTwo,task01$1n.options[task01$1n.randomAnswer]));  
        task01$1n.answer = roundUp(task01$1n.displayValue,task01$1n.options[task01$1n.randomAnswer]) + roundUp(task01$1n.displayValueTwo,task01$1n.options[task01$1n.randomAnswer]);
        

        task01$1n.question = "There were originally "+ task01$1n.displayValue + " houses in Columbia County. During a housing boom, developers built " + task01$1n.displayValueTwo +" more. About how many houses are there now in Columbia County? Choose the better estimate.";
        return task01$1n;
    }

    /* src/components/taskComponents/GIV_MA_B9.svelte generated by Svelte v3.37.0 */
    const file$1D = "src/components/taskComponents/GIV_MA_B9.svelte";

    function create_fragment$1E(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h20;
    	let t1;
    	let div5;
    	let div2;
    	let h21;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let h4;
    	let t5;
    	let button0;
    	let t6_value = /*task01*/ ctx[0].operatorNum[0] + "";
    	let t6;
    	let t7;
    	let button1;
    	let t8_value = /*task01*/ ctx[0].operatorNum[1] + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button2;
    	let t13;
    	let button3;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h20 = element("h2");
    			h20.textContent = "Estimate sums : word problems";
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h21 = element("h2");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			h4 = element("h4");
    			h4.textContent = "The sum is approximately";
    			t5 = space();
    			button0 = element("button");
    			t6 = text(t6_value);
    			t7 = space();
    			button1 = element("button");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[2]);
    			t11 = space();
    			div4 = element("div");
    			button2 = element("button");
    			button2.textContent = "Rerun";
    			t13 = space();
    			button3 = element("button");
    			button3.textContent = "Exit This Skill";
    			attr_dev(h20, "class", "text-center display-4 mb-0");
    			add_location(h20, file$1D, 55, 10, 1034);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1D, 54, 6, 984);
    			add_location(h21, file$1D, 60, 12, 1223);
    			add_location(h4, file$1D, 64, 16, 1321);
    			attr_dev(button0, "class", "btn btn-outline-success");
    			add_location(button0, file$1D, 65, 16, 1373);
    			attr_dev(button1, "class", "btn btn-outline-success");
    			add_location(button1, file$1D, 66, 16, 1510);
    			add_location(div1, file$1D, 61, 12, 1262);
    			add_location(div2, file$1D, 59, 8, 1204);
    			set_style(h5, "display", /*showNext*/ ctx[1]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1D, 72, 12, 1714);
    			add_location(div3, file$1D, 71, 8, 1696);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1D, 76, 12, 1848);
    			attr_dev(button3, "type", "button");
    			attr_dev(button3, "class", "btn toggle-btn");
    			add_location(button3, file$1D, 77, 12, 1944);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$1D, 75, 8, 1817);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$1D, 58, 6, 1132);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$1D, 53, 5, 936);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$1D, 52, 1, 902);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h20);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h21);
    			append_dev(h21, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, h4);
    			append_dev(div1, t5);
    			append_dev(div1, button0);
    			append_dev(button0, t6);
    			append_dev(div1, t7);
    			append_dev(div1, button1);
    			append_dev(button1, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button2);
    			append_dev(div4, t13);
    			append_dev(div4, button3);

    			if (!mounted) {
    				dispose = [
    					listen_dev(
    						button0,
    						"click",
    						function () {
    							if (is_function(/*handleClick*/ ctx[4](/*task01*/ ctx[0].operatorNum[0]))) /*handleClick*/ ctx[4](/*task01*/ ctx[0].operatorNum[0]).apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						button1,
    						"click",
    						function () {
    							if (is_function(/*handleClick*/ ctx[4](/*task01*/ ctx[0].operatorNum[1]))) /*handleClick*/ ctx[4](/*task01*/ ctx[0].operatorNum[1]).apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(button2, "click", /*NextQuestion*/ ctx[3], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*task01*/ 1 && t6_value !== (t6_value = /*task01*/ ctx[0].operatorNum[0] + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].operatorNum[1] + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 4) set_data_dev(t10, /*showPopUp*/ ctx[2]);

    			if (dirty & /*showNext*/ 2) {
    				set_style(h5, "display", /*showNext*/ ctx[1]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1E($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GIV_MA_B9", slots, []);
    	let task01 = taskOne$1n();
    	let answer;
    	let showNext = "none";
    	let showPopUp;

    	let CheckAnswer = function () {
    		if (answer == task01.answer) {
    			$$invalidate(2, showPopUp = randomCorrect());
    			$$invalidate(1, showNext = "inline-block");
    			return;
    		} else {
    			$$invalidate(2, showPopUp = randomWrong());
    			$$invalidate(1, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		answer = null;
    		$$invalidate(0, task01 = taskOne$1n());
    		$$invalidate(1, showNext = "none");
    	};

    	const handleClick = parameter => () => {
    		answer = parameter;
    		CheckAnswer();
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GIV_MA_B9> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1n,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		handleClick
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) answer = $$props.answer;
    		if ("showNext" in $$props) $$invalidate(1, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(2, showPopUp = $$props.showPopUp);
    		if ("CheckAnswer" in $$props) CheckAnswer = $$props.CheckAnswer;
    		if ("NextQuestion" in $$props) $$invalidate(3, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [task01, showNext, showPopUp, NextQuestion, handleClick];
    }

    class GIV_MA_B9 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1E, create_fragment$1E, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GIV_MA_B9",
    			options,
    			id: create_fragment$1E.name
    		});
    	}
    }

    let task01$1m = {
      heading : "Addition input/output tables - up to three digits",
      question: "Complete the table.",
      qstNum : 0,
      valueArray: [], 
      answer: [], 
      operator: "+",
      columns: 4,
      input : 0
    };

    const maxValue$16 = 999;
    const minValue$16 = 100;
    const tablesize$3 = 4;

    function taskOne$1m() {

      task01$1m.valueArray = [];
      task01$1m.answer = []; 

       let displayBtn = randomNumbers$3(tablesize$3,maxValue$16,minValue$16);
       task01$1m.qstNum =  Math.floor(Math.random() * minValue$16);
       for(let i = 0 ; i < displayBtn.length;i++){
          task01$1m.valueArray[i] = [displayBtn[i], displayBtn[i]+task01$1m.qstNum];
          task01$1m.answer[i] = [displayBtn[i]+task01$1m.qstNum];
       }
       task01$1m.input = Math.floor(Math.random() * task01$1m.valueArray.length);
       for(let i = 0 ; i < displayBtn.length;i++){
         if(i != task01$1m.input){
          task01$1m.valueArray[i] = [displayBtn[i], ['i']];
         }
     }
      
      return task01$1m;
    }

    /* src/components/taskComponents/GIII_MA_C2.svelte generated by Svelte v3.37.0 */
    const file$1C = "src/components/taskComponents/GIII_MA_C2.svelte";

    function get_each_context$1m(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[9] = list;
    	child_ctx[10] = i;
    	return child_ctx;
    }

    function get_each_context_1$m(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	return child_ctx;
    }

    // (72:32) {:else}
    function create_else_block$12(ctx) {
    	let td;
    	let t_value = /*a*/ ctx[11] + "";
    	let t;

    	const block = {
    		c: function create() {
    			td = element("td");
    			t = text(t_value);
    			attr_dev(td, "align", "right");
    			add_location(td, file$1C, 72, 32, 2002);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*a*/ ctx[11] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$12.name,
    		type: "else",
    		source: "(72:32) {:else}",
    		ctx
    	});

    	return block;
    }

    // (70:32) {#if a == 'i'}
    function create_if_block$17(ctx) {
    	let td;
    	let input;
    	let mounted;
    	let dispose;

    	function input_input_handler() {
    		/*input_input_handler*/ ctx[6].call(input, /*i*/ ctx[10]);
    	}

    	const block = {
    		c: function create() {
    			td = element("td");
    			input = element("input");
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "style", " width : 60px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$1C, 70, 50, 1825);
    			attr_dev(td, "align", "right");
    			add_location(td, file$1C, 70, 32, 1807);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, input);
    			set_input_value(input, /*answer*/ ctx[1][/*i*/ ctx[10]]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1][/*i*/ ctx[10]]) {
    				set_input_value(input, /*answer*/ ctx[1][/*i*/ ctx[10]]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$17.name,
    		type: "if",
    		source: "(70:32) {#if a == 'i'}",
    		ctx
    	});

    	return block;
    }

    // (69:28) {#each col as a}
    function create_each_block_1$m(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*a*/ ctx[11] == "i") return create_if_block$17;
    		return create_else_block$12;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$m.name,
    		type: "each",
    		source: "(69:28) {#each col as a}",
    		ctx
    	});

    	return block;
    }

    // (67:24) {#each task01.valueArray as col, i }
    function create_each_block$1m(ctx) {
    	let tr;
    	let t;
    	let each_value_1 = /*col*/ ctx[8];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$m(get_each_context_1$m(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			add_location(tr, file$1C, 67, 24, 1652);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			append_dev(tr, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*answer, task01*/ 3) {
    				each_value_1 = /*col*/ ctx[8];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$m(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$m(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, t);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1m.name,
    		type: "each",
    		source: "(67:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1D(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h40;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let h41;
    	let t4;
    	let t5_value = /*task01*/ ctx[0].qstNum + "";
    	let t5;
    	let t6;
    	let table;
    	let t7;
    	let h6;
    	let t8;
    	let t9_value = /*task01*/ ctx[0].answer + "";
    	let t9;
    	let t10;
    	let div3;
    	let h5;
    	let t11;
    	let t12;
    	let div4;
    	let button0;
    	let t14;
    	let button1;
    	let t16;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1m(get_each_context$1m(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h40 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			h41 = element("h4");
    			t4 = text("Rule: add ");
    			t5 = text(t5_value);
    			t6 = space();
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t7 = space();
    			h6 = element("h6");
    			t8 = text("answer ");
    			t9 = text(t9_value);
    			t10 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t11 = text(/*showPopUp*/ ctx[3]);
    			t12 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t14 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t16 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$1C, 53, 10, 1202);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1C, 52, 6, 1152);
    			add_location(h40, file$1C, 60, 12, 1380);
    			add_location(h41, file$1C, 63, 16, 1451);
    			attr_dev(table, "width", "100");
    			add_location(table, file$1C, 64, 16, 1502);
    			add_location(h6, file$1C, 80, 20, 2296);
    			add_location(div1, file$1C, 62, 12, 1425);
    			add_location(div2, file$1C, 57, 8, 1359);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1C, 85, 12, 2404);
    			add_location(div3, file$1C, 84, 8, 2386);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1C, 89, 12, 2542);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1C, 90, 12, 2638);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1C, 91, 12, 2734);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$1C, 88, 8, 2511);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$1C, 56, 6, 1287);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$1C, 51, 5, 1104);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$1C, 50, 1, 1070);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h40);
    			append_dev(h40, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, h41);
    			append_dev(h41, t4);
    			append_dev(h41, t5);
    			append_dev(div1, t6);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t7);
    			append_dev(div1, h6);
    			append_dev(h6, t8);
    			append_dev(h6, t9);
    			append_dev(div5, t10);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t11);
    			append_dev(div5, t12);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t14);
    			append_dev(div4, button1);
    			append_dev(div4, t16);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*task01*/ 1 && t5_value !== (t5_value = /*task01*/ ctx[0].qstNum + "")) set_data_dev(t5, t5_value);

    			if (dirty & /*task01, answer*/ 3) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1m(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1m(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*task01*/ 1 && t9_value !== (t9_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t9, t9_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t11, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1D($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GIII_MA_C2", slots, []);
    	let task01 = taskOne$1m();
    	let answer = [];
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		for (let index = 0; index < answer.length; index++) {
    			if (task01.input != index) {
    				if (answer[index] != task01.answer[index]) {
    					$$invalidate(3, showPopUp = randomWrong());
    					showSolution = true;
    					return;
    				} else {
    					$$invalidate(3, showPopUp = randomCorrect());
    				}
    			}
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = []);
    		$$invalidate(1, answer.length = task01.answer.length, answer);
    		$$invalidate(0, task01 = taskOne$1m());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GIII_MA_C2> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler(i) {
    		answer[i] = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1m,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class GIII_MA_C2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1D, create_fragment$1D, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GIII_MA_C2",
    			options,
    			id: create_fragment$1D.name
    		});
    	}
    }

    let task01$1l = {
      heading: "Balance addition equations - one digit",
      question:
        "Here are the ways to make 4. Find the pattern and type the missing addition number sentence.",
      questionValue: 0,
      valueArray: [],
      answer: 0,
      randomAnswer: 0,
      solutionArray: [],
      columns: 0,
    };

    const maxValue$15 = 999;
    const minValue$15 = 100;
    const findInMaxNumber$p = 1000;


    function taskOne$1l() {
      task01$1l.questionValue =
        Math.floor(Math.random() * (maxValue$15 - minValue$15 + 1)) + minValue$15;
      task01$1l.question = "How do you make true?";
      task01$1l.valueArray = [];
      task01$1l.solutionArray = [];
      task01$1l.columns = 2;
      let ans = [];
      for (let i = 0; i < findInMaxNumber$p; i++) {
        for (let j = 0; j < findInMaxNumber$p; j++) {
          let a = i + "+" + j;
          if (task01$1l.questionValue == i + j) {
            ans.push(a);
          }
        }
      }

      let temparray = randomArrayNumbers(2, ans.length, 0, ans);
      for (let i = 0; i < temparray.length; i++) {
        task01$1l.valueArray[i] = temparray[i].split("+").map(function (item) {
          return parseInt(item, 10);
        });
      }
      let RandomValue = Math.floor(Math.random() *  task01$1l.valueArray.length);
      let randomINput = Math.floor(Math.random() *  task01$1l.valueArray[RandomValue].length);
      task01$1l.solutionArray = [...task01$1l.valueArray[RandomValue]];
      task01$1l.answer = task01$1l.valueArray[RandomValue][randomINput];
     
      console.log(task01$1l.answer);
      task01$1l.valueArray[RandomValue][randomINput] = 'i';
      return task01$1l;
    }

    /* src/components/taskComponents/GIII_MA_C5.svelte generated by Svelte v3.37.0 */
    const file$1B = "src/components/taskComponents/GIII_MA_C5.svelte";

    function get_each_context$1l(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	child_ctx[13] = i;
    	return child_ctx;
    }

    function get_each_context_1$l(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[14] = list[i];
    	child_ctx[13] = i;
    	return child_ctx;
    }

    // (74:36) {:else}
    function create_else_block$11(ctx) {
    	let t_value = /*a*/ ctx[14] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*a*/ ctx[14] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$11.name,
    		type: "else",
    		source: "(74:36) {:else}",
    		ctx
    	});

    	return block;
    }

    // (72:34) {#if a == 'i'}
    function create_if_block_2$c(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "style", " width : 30px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$1B, 72, 34, 1812);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*answer*/ ctx[1]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[7]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$c.name,
    		type: "if",
    		source: "(72:34) {#if a == 'i'}",
    		ctx
    	});

    	return block;
    }

    // (77:34) {#if i < col.length-1}
    function create_if_block_1$c(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("+");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$c.name,
    		type: "if",
    		source: "(77:34) {#if i < col.length-1}",
    		ctx
    	});

    	return block;
    }

    // (71:32) {#each col as a, i}
    function create_each_block_1$l(ctx) {
    	let t;
    	let if_block1_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*a*/ ctx[14] == "i") return create_if_block_2$c;
    		return create_else_block$11;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);
    	let if_block1 = /*i*/ ctx[13] < /*col*/ ctx[11].length - 1 && create_if_block_1$c(ctx);

    	const block = {
    		c: function create() {
    			if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(t.parentNode, t);
    				}
    			}

    			if (/*i*/ ctx[13] < /*col*/ ctx[11].length - 1) {
    				if (if_block1) ; else {
    					if_block1 = create_if_block_1$c(ctx);
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$l.name,
    		type: "each",
    		source: "(71:32) {#each col as a, i}",
    		ctx
    	});

    	return block;
    }

    // (81:32) {#if i < task01.valueArray.length-1}
    function create_if_block$16(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("=");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$16.name,
    		type: "if",
    		source: "(81:32) {#if i < task01.valueArray.length-1}",
    		ctx
    	});

    	return block;
    }

    // (69:20) {#each task01.valueArray as col, i }
    function create_each_block$1l(ctx) {
    	let t;
    	let if_block_anchor;
    	let each_value_1 = /*col*/ ctx[11];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$l(get_each_context_1$l(ctx, each_value_1, i));
    	}

    	let if_block = /*i*/ ctx[13] < /*task01*/ ctx[0].valueArray.length - 1 && create_if_block$16(ctx);

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01, answer*/ 3) {
    				each_value_1 = /*col*/ ctx[11];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$l(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$l(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(t.parentNode, t);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}

    			if (/*i*/ ctx[13] < /*task01*/ ctx[0].valueArray.length - 1) {
    				if (if_block) ; else {
    					if_block = create_if_block$16(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1l.name,
    		type: "each",
    		source: "(69:20) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1C(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let tr;
    	let td;
    	let span;
    	let t4;
    	let h6;
    	let t5;
    	let t6_value = /*task01*/ ctx[0].answer + "";
    	let t6;
    	let t7;
    	let div3;
    	let h5;
    	let t8;
    	let t9;
    	let solution;
    	let t10;
    	let div4;
    	let button0;
    	let t12;
    	let button1;
    	let t14;
    	let button2;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1l(get_each_context$1l(ctx, each_value, i));
    	}

    	solution = new AdditionSolution({
    			props: {
    				num_qnty: /*task01*/ ctx[0].columns,
    				usr_resp: /*answer*/ ctx[1],
    				num: /*task01*/ ctx[0].solutionArray,
    				ans_submit: /*showSolution*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");
    			tr = element("tr");
    			td = element("td");
    			span = element("span");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			h6 = element("h6");
    			t5 = text("answer ");
    			t6 = text(t6_value);
    			t7 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t8 = text(/*showPopUp*/ ctx[3]);
    			t9 = space();
    			create_component(solution.$$.fragment);
    			t10 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t12 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t14 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$1B, 53, 8, 1228);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1B, 52, 4, 1180);
    			add_location(h4, file$1B, 60, 10, 1396);
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$1B, 66, 36, 1539);
    			attr_dev(td, "align", "right");
    			add_location(td, file$1B, 66, 18, 1521);
    			add_location(tr, file$1B, 65, 16, 1498);
    			attr_dev(table, "width", "200");
    			add_location(table, file$1B, 64, 14, 1462);
    			add_location(h6, file$1B, 89, 18, 2634);
    			add_location(div1, file$1B, 62, 10, 1437);
    			add_location(div2, file$1B, 57, 6, 1377);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1B, 94, 10, 2732);
    			add_location(div3, file$1B, 93, 6, 2716);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1B, 98, 10, 2971);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1B, 99, 10, 3065);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1B, 100, 10, 3159);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$1B, 97, 6, 2942);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$1B, 56, 4, 1307);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$1B, 51, 3, 1134);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$1B, 50, 0, 1102);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);
    			append_dev(table, tr);
    			append_dev(tr, td);
    			append_dev(td, span);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(span, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, h6);
    			append_dev(h6, t5);
    			append_dev(h6, t6);
    			append_dev(div5, t7);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t8);
    			append_dev(div5, t9);
    			mount_component(solution, div5, null);
    			append_dev(div5, t10);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t12);
    			append_dev(div4, button1);
    			append_dev(div4, t14);
    			append_dev(div4, button2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*task01*/ 1) && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*task01*/ 1) && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01, answer*/ 3) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1l(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1l(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(span, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if ((!current || dirty & /*task01*/ 1) && t6_value !== (t6_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t6, t6_value);
    			if (!current || dirty & /*showPopUp*/ 8) set_data_dev(t8, /*showPopUp*/ ctx[3]);

    			if (!current || dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}

    			const solution_changes = {};
    			if (dirty & /*task01*/ 1) solution_changes.num_qnty = /*task01*/ ctx[0].columns;
    			if (dirty & /*answer*/ 2) solution_changes.usr_resp = /*answer*/ ctx[1];
    			if (dirty & /*task01*/ 1) solution_changes.num = /*task01*/ ctx[0].solutionArray;
    			if (dirty & /*showSolution*/ 16) solution_changes.ans_submit = /*showSolution*/ ctx[4];
    			solution.$set(solution_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			destroy_component(solution);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const max$q = 10;
    const min$q = 0;
    const numberofColumn$p = 2;

    function instance$1C($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GIII_MA_C5", slots, []);
    	let heading = "Addition facts - sums up to 10";
    	let question = "Add :";
    	let maxandmin = MaxandMin$5(max$q, min$q, numberofColumn$p, heading, question);
    	let task01 = taskOne$1l();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			$$invalidate(4, showSolution = true);
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$1l());
    		$$invalidate(4, showSolution = false);
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GIII_MA_C5> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1l,
    		randomCorrect,
    		randomWrong,
    		MaxandMin: MaxandMin$5,
    		Solution: AdditionSolution,
    		heading,
    		question,
    		max: max$q,
    		min: min$q,
    		numberofColumn: numberofColumn$p,
    		maxandmin,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("heading" in $$props) heading = $$props.heading;
    		if ("question" in $$props) question = $$props.question;
    		if ("maxandmin" in $$props) maxandmin = $$props.maxandmin;
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) $$invalidate(4, showSolution = $$props.showSolution);
    		if ("CheckAnswer" in $$props) $$invalidate(5, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(6, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class GIII_MA_C5 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1C, create_fragment$1C, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GIII_MA_C5",
    			options,
    			id: create_fragment$1C.name
    		});
    	}
    }

    /* src/components/taskComponents/GIII_MA_C6.svelte generated by Svelte v3.37.0 */
    const file$1A = "src/components/taskComponents/GIII_MA_C6.svelte";

    function get_each_context$1k(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	child_ctx[12] = i;
    	return child_ctx;
    }

    // (74:28) {:else}
    function create_else_block$10(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[10] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$1A, 75, 32, 2120);
    			add_location(tr, file$1A, 74, 28, 2083);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[10] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$10.name,
    		type: "else",
    		source: "(74:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (70:28) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$15(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[10] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$1A, 71, 50, 1916);
    			attr_dev(td, "align", "right");
    			add_location(td, file$1A, 71, 32, 1898);
    			add_location(tr, file$1A, 70, 28, 1861);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[10] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$15.name,
    		type: "if",
    		source: "(70:28) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (69:24) {#each task01.valueArray as col, i }
    function create_each_block$1k(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[12] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$15;
    		return create_else_block$10;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1k.name,
    		type: "each",
    		source: "(69:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1B(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let solution;
    	let t12;
    	let div4;
    	let button0;
    	let t14;
    	let button1;
    	let t16;
    	let button2;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1k(get_each_context$1k(ctx, each_value, i));
    	}

    	solution = new AdditionSolution({
    			props: {
    				num_qnty: /*task01*/ ctx[0].columns,
    				usr_resp: /*answer*/ ctx[1],
    				num: /*task01*/ ctx[0].valueArray,
    				ans_submit: /*showSolution*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			create_component(solution.$$.fragment);
    			t12 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t14 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t16 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$1A, 55, 10, 1386);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1A, 54, 6, 1336);
    			add_location(h4, file$1A, 62, 12, 1564);
    			attr_dev(table, "width", "100");
    			add_location(table, file$1A, 66, 16, 1636);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$1A, 80, 20, 2313);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$1A, 81, 20, 2408);
    			add_location(h6, file$1A, 82, 20, 2530);
    			add_location(div1, file$1A, 64, 12, 1609);
    			add_location(div2, file$1A, 59, 8, 1543);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1A, 87, 12, 2638);
    			add_location(div3, file$1A, 86, 8, 2620);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1A, 91, 12, 2882);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1A, 92, 12, 2978);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1A, 93, 12, 3074);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$1A, 90, 8, 2851);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$1A, 58, 6, 1471);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$1A, 53, 5, 1288);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$1A, 52, 1, 1254);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			mount_component(solution, div5, null);
    			append_dev(div5, t12);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t14);
    			append_dev(div4, button1);
    			append_dev(div4, t16);
    			append_dev(div4, button2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[7]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*task01*/ 1) && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*task01*/ 1) && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1k(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1k(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if ((!current || dirty & /*task01*/ 1) && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (!current || dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (!current || dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}

    			const solution_changes = {};
    			if (dirty & /*task01*/ 1) solution_changes.num_qnty = /*task01*/ ctx[0].columns;
    			if (dirty & /*answer*/ 2) solution_changes.usr_resp = /*answer*/ ctx[1];
    			if (dirty & /*task01*/ 1) solution_changes.num = /*task01*/ ctx[0].valueArray;
    			if (dirty & /*showSolution*/ 16) solution_changes.ans_submit = /*showSolution*/ ctx[4];
    			solution.$set(solution_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			destroy_component(solution);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const max$p = 999;
    const min$p = 1;

    function instance$1B($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GIII_MA_C6", slots, []);
    	let heading = "Add two numbers up to three digits";
    	let question = "Add :";
    	let task01 = taskOne$1C();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			$$invalidate(4, showSolution = true);
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		let numberofColumn = Math.floor(Math.random() * (5 - 3)) + 3;
    		MaxandMin$5(max$p, min$p, numberofColumn, heading, question);
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$1C());
    		$$invalidate(4, showSolution = false);
    		$$invalidate(2, showNext = "none");
    	};

    	NextQuestion();
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GIII_MA_C6> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1C,
    		randomCorrect,
    		randomWrong,
    		MaxandMin: MaxandMin$5,
    		Solution: AdditionSolution,
    		heading,
    		question,
    		max: max$p,
    		min: min$p,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("heading" in $$props) heading = $$props.heading;
    		if ("question" in $$props) question = $$props.question;
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) $$invalidate(4, showSolution = $$props.showSolution);
    		if ("CheckAnswer" in $$props) $$invalidate(5, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(6, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class GIII_MA_C6 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1B, create_fragment$1B, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GIII_MA_C6",
    			options,
    			id: create_fragment$1B.name
    		});
    	}
    }

    let task01$1k = {
      heading : "",
      question: "",
      valueArray: [], 
      answer: 0, 
      operator: "+",
      columns: 0
    };

    let columns$e = 3;
    let maxValue$14 = 999;
    let minValue$14 = 1;


    function taskOne$1k() {
      task01$1k.heading = "Add three or more numbers up to three digits - word problems";
      task01$1k.answer = 0;
      task01$1k.columns = columns$e;
      task01$1k.valueArray = [];
          for (let i = 0; i < columns$e; i++) {
            task01$1k.valueArray[i] = Math.floor(Math.random() * (maxValue$14 - minValue$14 + 1) ) + minValue$14; 
            task01$1k.answer += task01$1k.valueArray[i];        
          }
            while(task01$1k.answer > maxValue$14){
                task01$1k.answer = 0;
            for (let i = 0; i < columns$e; i++) {
                task01$1k.valueArray[i] = Math.floor(Math.random() * (maxValue$14 - minValue$14 + 1) ) + minValue$14; 
                task01$1k.answer += task01$1k.valueArray[i];        
            }
            }
      task01$1k.question = "Pizzeria Italiana sold "+ task01$1k.valueArray[0]+" pepperoni pizzas, "+task01$1k.valueArray[1]+" veggie pizzas, and "+task01$1k.valueArray[2]+" cheese pizzas. How many pizzas did they sell in all?";
      return task01$1k;
    }

    /* src/components/taskComponents/GIII_MA_C7.svelte generated by Svelte v3.37.0 */
    const file$1z = "src/components/taskComponents/GIII_MA_C7.svelte";

    function create_fragment$1A(ctx) {
    	let div6;
    	let div5;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div4;
    	let div1;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let input;
    	let t4;
    	let div2;
    	let h5;
    	let t5;
    	let t6;
    	let solution;
    	let t7;
    	let div3;
    	let button0;
    	let t9;
    	let button1;
    	let t11;
    	let button2;
    	let current;
    	let mounted;
    	let dispose;

    	solution = new AdditionSolution({
    			props: {
    				num_qnty: /*task01*/ ctx[0].columns,
    				usr_resp: /*answer*/ ctx[1],
    				num: /*task01*/ ctx[0].valueArray,
    				ans_submit: /*showSolution*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div6 = element("div");
    			div5 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div4 = element("div");
    			div1 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			input = element("input");
    			t4 = space();
    			div2 = element("div");
    			h5 = element("h5");
    			t5 = text(/*showPopUp*/ ctx[3]);
    			t6 = space();
    			create_component(solution.$$.fragment);
    			t7 = space();
    			div3 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t9 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t11 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$1z, 51, 9, 1075);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1z, 50, 5, 1026);
    			add_location(h4, file$1z, 57, 11, 1247);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$1z, 58, 11, 1285);
    			add_location(div1, file$1z, 55, 7, 1228);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1z, 62, 11, 1427);
    			add_location(div2, file$1z, 61, 7, 1410);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1z, 66, 11, 1667);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1z, 67, 11, 1762);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1z, 68, 11, 1857);
    			attr_dev(div3, "class", "mt-3");
    			add_location(div3, file$1z, 65, 7, 1637);
    			attr_dev(div4, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div4, file$1z, 54, 5, 1157);
    			attr_dev(div5, "class", "shadow-sm  bg-white rounded");
    			add_location(div5, file$1z, 49, 4, 979);
    			attr_dev(div6, "class", "container mt-5");
    			add_location(div6, file$1z, 48, 1, 946);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div5);
    			append_dev(div5, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div5, t1);
    			append_dev(div5, div4);
    			append_dev(div4, div1);
    			append_dev(div1, h4);
    			append_dev(h4, t2);
    			append_dev(div1, t3);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div4, t4);
    			append_dev(div4, div2);
    			append_dev(div2, h5);
    			append_dev(h5, t5);
    			append_dev(div4, t6);
    			mount_component(solution, div4, null);
    			append_dev(div4, t7);
    			append_dev(div4, div3);
    			append_dev(div3, button0);
    			append_dev(div3, t9);
    			append_dev(div3, button1);
    			append_dev(div3, t11);
    			append_dev(div3, button2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[7]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*task01*/ 1) && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*task01*/ 1) && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (!current || dirty & /*showPopUp*/ 8) set_data_dev(t5, /*showPopUp*/ ctx[3]);

    			if (!current || dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}

    			const solution_changes = {};
    			if (dirty & /*task01*/ 1) solution_changes.num_qnty = /*task01*/ ctx[0].columns;
    			if (dirty & /*answer*/ 2) solution_changes.usr_resp = /*answer*/ ctx[1];
    			if (dirty & /*task01*/ 1) solution_changes.num = /*task01*/ ctx[0].valueArray;
    			if (dirty & /*showSolution*/ 16) solution_changes.ans_submit = /*showSolution*/ ctx[4];
    			solution.$set(solution_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div6);
    			destroy_component(solution);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1A($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GIII_MA_C7", slots, []);
    	let task01 = taskOne$1k();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			$$invalidate(2, showNext = "inline-block");
    			return;
    		} else {
    			$$invalidate(4, showSolution = true);
    			$$invalidate(3, showPopUp = randomWrong());
    			$$invalidate(2, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(4, showSolution = false);
    		$$invalidate(0, task01 = taskOne$1k());
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GIII_MA_C7> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1k,
    		randomCorrect,
    		randomWrong,
    		Solution: AdditionSolution,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) $$invalidate(4, showSolution = $$props.showSolution);
    		if ("CheckAnswer" in $$props) $$invalidate(5, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(6, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class GIII_MA_C7 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1A, create_fragment$1A, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GIII_MA_C7",
    			options,
    			id: create_fragment$1A.name
    		});
    	}
    }

    let task01$1j = {
      question: "",
      displayValue: 0,
      displayValueTwo: 0,
      displayValueThree: 0,
      Options: [1, 10, 100],
      variations: 0,
      randomAnswer: 0,
    };
        const maxNumber$4 = 10;
        const minNumber$4 = 1;
        
    function taskOne$1j() {

        task01$1j.variations =  Math.floor(Math.random() * 3 - 1) + 1;
      task01$1j.displayValueOne = Math.floor(Math.random() * maxNumber$4 - minNumber$4) + minNumber$4;
      task01$1j.displayValueTwo = Math.floor(Math.random() * maxNumber$4 - minNumber$4) + minNumber$4; 
      console.log(task01$1j.displayValueTwo);
      task01$1j.question = "Complete the pattern:";  
      return task01$1j;
    }

    /* src/components/taskComponents/GIII_MA_C8.svelte generated by Svelte v3.37.0 */
    const file$1y = "src/components/taskComponents/GIII_MA_C8.svelte";

    function get_each_context$1j(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	child_ctx[10] = list;
    	child_ctx[11] = i;
    	return child_ctx;
    }

    function get_each_context_1$k(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	child_ctx[12] = list;
    	child_ctx[11] = i;
    	return child_ctx;
    }

    function get_each_context_2$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	child_ctx[13] = list;
    	child_ctx[11] = i;
    	return child_ctx;
    }

    // (96:16) {#if 0 == task01.variations}
    function create_if_block_2$b(ctx) {
    	let each_1_anchor;
    	let each_value_2 = /*task01*/ ctx[2].Options;
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$7(get_each_context_2$7(ctx, each_value_2, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01, answer*/ 12) {
    				each_value_2 = /*task01*/ ctx[2].Options;
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$7(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_2$7(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_2.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$b.name,
    		type: "if",
    		source: "(96:16) {#if 0 == task01.variations}",
    		ctx
    	});

    	return block;
    }

    // (97:20) {#each  task01.Options as optionValue,i }
    function create_each_block_2$7(ctx) {
    	let div;
    	let t0_value = /*task01*/ ctx[2].displayValueOne * /*optionValue*/ ctx[9] + "";
    	let t0;
    	let t1;
    	let input;
    	let t2;
    	let t3_value = (/*task01*/ ctx[2].displayValueOne + /*task01*/ ctx[2].displayValueTwo) * /*optionValue*/ ctx[9] + "";
    	let t3;
    	let mounted;
    	let dispose;

    	function input_input_handler() {
    		/*input_input_handler*/ ctx[6].call(input, /*i*/ ctx[11]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = text(" + ");
    			input = element("input");
    			t2 = text(" = ");
    			t3 = text(t3_value);
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			add_location(input, file$1y, 97, 65, 2667);
    			add_location(div, file$1y, 97, 20, 2622);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, input);
    			set_input_value(input, /*answer*/ ctx[3][/*i*/ ctx[11]]);
    			append_dev(div, t2);
    			append_dev(div, t3);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*task01*/ 4 && t0_value !== (t0_value = /*task01*/ ctx[2].displayValueOne * /*optionValue*/ ctx[9] + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*answer*/ 8 && input.value !== /*answer*/ ctx[3][/*i*/ ctx[11]]) {
    				set_input_value(input, /*answer*/ ctx[3][/*i*/ ctx[11]]);
    			}

    			if (dirty & /*task01*/ 4 && t3_value !== (t3_value = (/*task01*/ ctx[2].displayValueOne + /*task01*/ ctx[2].displayValueTwo) * /*optionValue*/ ctx[9] + "")) set_data_dev(t3, t3_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$7.name,
    		type: "each",
    		source: "(97:20) {#each  task01.Options as optionValue,i }",
    		ctx
    	});

    	return block;
    }

    // (102:15) {#if 1 == task01.variations}
    function create_if_block_1$b(ctx) {
    	let each_1_anchor;
    	let each_value_1 = /*task01*/ ctx[2].Options;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$k(get_each_context_1$k(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*answer, task01*/ 12) {
    				each_value_1 = /*task01*/ ctx[2].Options;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$k(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$k(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$b.name,
    		type: "if",
    		source: "(102:15) {#if 1 == task01.variations}",
    		ctx
    	});

    	return block;
    }

    // (103:15) {#each  task01.Options as optionValue,i }
    function create_each_block_1$k(ctx) {
    	let div;
    	let t0_value = /*task01*/ ctx[2].displayValueOne * /*optionValue*/ ctx[9] + "";
    	let t0;
    	let t1;
    	let t2_value = /*task01*/ ctx[2].displayValueTwo * /*optionValue*/ ctx[9] + "";
    	let t2;
    	let t3;
    	let input;
    	let t4;
    	let mounted;
    	let dispose;

    	function input_input_handler_1() {
    		/*input_input_handler_1*/ ctx[7].call(input, /*i*/ ctx[11]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = text(" + ");
    			t2 = text(t2_value);
    			t3 = text(" = ");
    			input = element("input");
    			t4 = space();
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			add_location(input, file$1y, 103, 100, 3121);
    			add_location(div, file$1y, 103, 15, 3036);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);
    			append_dev(div, t3);
    			append_dev(div, input);
    			set_input_value(input, /*answer*/ ctx[3][/*i*/ ctx[11]]);
    			append_dev(div, t4);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler_1);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*task01*/ 4 && t0_value !== (t0_value = /*task01*/ ctx[2].displayValueOne * /*optionValue*/ ctx[9] + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 4 && t2_value !== (t2_value = /*task01*/ ctx[2].displayValueTwo * /*optionValue*/ ctx[9] + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*answer*/ 8 && input.value !== /*answer*/ ctx[3][/*i*/ ctx[11]]) {
    				set_input_value(input, /*answer*/ ctx[3][/*i*/ ctx[11]]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$k.name,
    		type: "each",
    		source: "(103:15) {#each  task01.Options as optionValue,i }",
    		ctx
    	});

    	return block;
    }

    // (107:10) {#if 2 == task01.variations}
    function create_if_block$14(ctx) {
    	let each_1_anchor;
    	let each_value = /*task01*/ ctx[2].Options;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1j(get_each_context$1j(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01, answer*/ 12) {
    				each_value = /*task01*/ ctx[2].Options;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1j(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1j(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$14.name,
    		type: "if",
    		source: "(107:10) {#if 2 == task01.variations}",
    		ctx
    	});

    	return block;
    }

    // (108:20) {#each  task01.Options as optionValue,i }
    function create_each_block$1j(ctx) {
    	let div;
    	let input;
    	let t0;
    	let t1_value = /*task01*/ ctx[2].displayValueTwo * /*optionValue*/ ctx[9] + "";
    	let t1;
    	let t2;
    	let t3_value = (/*task01*/ ctx[2].displayValueOne + /*task01*/ ctx[2].displayValueTwo) * /*optionValue*/ ctx[9] + "";
    	let t3;
    	let mounted;
    	let dispose;

    	function input_input_handler_2() {
    		/*input_input_handler_2*/ ctx[8].call(input, /*i*/ ctx[11]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			input = element("input");
    			t0 = text("+ ");
    			t1 = text(t1_value);
    			t2 = text(" = ");
    			t3 = text(t3_value);
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			add_location(input, file$1y, 108, 25, 3400);
    			add_location(div, file$1y, 108, 20, 3395);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, input);
    			set_input_value(input, /*answer*/ ctx[3][/*i*/ ctx[11]]);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);
    			append_dev(div, t3);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler_2);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*answer*/ 8 && input.value !== /*answer*/ ctx[3][/*i*/ ctx[11]]) {
    				set_input_value(input, /*answer*/ ctx[3][/*i*/ ctx[11]]);
    			}

    			if (dirty & /*task01*/ 4 && t1_value !== (t1_value = /*task01*/ ctx[2].displayValueTwo * /*optionValue*/ ctx[9] + "")) set_data_dev(t1, t1_value);
    			if (dirty & /*task01*/ 4 && t3_value !== (t3_value = (/*task01*/ ctx[2].displayValueOne + /*task01*/ ctx[2].displayValueTwo) * /*optionValue*/ ctx[9] + "")) set_data_dev(t3, t3_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1j.name,
    		type: "each",
    		source: "(108:20) {#each  task01.Options as optionValue,i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1z(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h20;
    	let t1;
    	let div5;
    	let div2;
    	let h21;
    	let t2_value = /*task01*/ ctx[2].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let t4;
    	let t5;
    	let t6;
    	let div3;
    	let h5;
    	let t7;
    	let t8;
    	let div4;
    	let button0;
    	let t10;
    	let button1;
    	let t12;
    	let button2;
    	let mounted;
    	let dispose;
    	let if_block0 = 0 == /*task01*/ ctx[2].variations && create_if_block_2$b(ctx);
    	let if_block1 = 1 == /*task01*/ ctx[2].variations && create_if_block_1$b(ctx);
    	let if_block2 = 2 == /*task01*/ ctx[2].variations && create_if_block$14(ctx);

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h20 = element("h2");
    			h20.textContent = "Multiplication patterns over increasing place values";
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h21 = element("h2");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			if (if_block0) if_block0.c();
    			t4 = space();
    			if (if_block1) if_block1.c();
    			t5 = space();
    			if (if_block2) if_block2.c();
    			t6 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t7 = text(/*showPopUp*/ ctx[1]);
    			t8 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t10 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t12 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h20, "class", "text-center display-4 mb-0");
    			add_location(h20, file$1y, 85, 10, 2203);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1y, 84, 6, 2153);
    			add_location(h21, file$1y, 92, 12, 2417);
    			attr_dev(div1, "class", " p-2");
    			add_location(div1, file$1y, 93, 12, 2457);
    			add_location(div2, file$1y, 91, 8, 2398);
    			set_style(h5, "display", /*showNext*/ ctx[0]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1y, 115, 13, 3744);
    			add_location(div3, file$1y, 114, 10, 3725);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1y, 118, 12, 3876);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1y, 119, 12, 3972);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1y, 120, 12, 4068);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$1y, 117, 10, 3845);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$1y, 89, 6, 2325);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$1y, 83, 5, 2105);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$1y, 82, 1, 2071);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h20);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h21);
    			append_dev(h21, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			if (if_block0) if_block0.m(div1, null);
    			append_dev(div1, t4);
    			if (if_block1) if_block1.m(div1, null);
    			append_dev(div1, t5);
    			if (if_block2) if_block2.m(div1, null);
    			append_dev(div5, t6);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t7);
    			append_dev(div5, t8);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t10);
    			append_dev(div4, button1);
    			append_dev(div4, t12);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 4 && t2_value !== (t2_value = /*task01*/ ctx[2].question + "")) set_data_dev(t2, t2_value);

    			if (0 == /*task01*/ ctx[2].variations) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_2$b(ctx);
    					if_block0.c();
    					if_block0.m(div1, t4);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (1 == /*task01*/ ctx[2].variations) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_1$b(ctx);
    					if_block1.c();
    					if_block1.m(div1, t5);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (2 == /*task01*/ ctx[2].variations) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block$14(ctx);
    					if_block2.c();
    					if_block2.m(div1, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (dirty & /*showPopUp*/ 2) set_data_dev(t7, /*showPopUp*/ ctx[1]);

    			if (dirty & /*showNext*/ 1) {
    				set_style(h5, "display", /*showNext*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GIII_MA_C8", slots, []);
    	let showNext = "none";
    	let showPopUp;
    	let task01 = taskOne$1j();
    	let answer = new Array(task01.Options.length);

    	let CheckAnswer = function () {
    		if (task01.variations == 0) {
    			for (let index = 0; index < answer.length; index++) {
    				if (answer[index] != task01.displayValueTwo * task01.Options[index]) {
    					$$invalidate(1, showPopUp = randomWrong());
    					$$invalidate(0, showNext = "inline-block");
    					break;
    				}

    				if (index == answer.length - 1) {
    					$$invalidate(1, showPopUp = randomCorrect());
    					$$invalidate(0, showNext = "inline-block");
    				}
    			}
    		} else if (task01.variations == 1) {
    			for (let index = 0; index < answer.length; index++) {
    				if (answer[index] != (task01.displayValueOne + task01.displayValueTwo) * task01.Options[index]) {
    					$$invalidate(1, showPopUp = randomWrong());
    					$$invalidate(0, showNext = "inline-block");
    					break;
    				}

    				if (index == answer.length - 1) {
    					$$invalidate(1, showPopUp = randomCorrect());
    					$$invalidate(0, showNext = "inline-block");
    				}
    			}
    		} else {
    			for (let index = 0; index < answer.length; index++) {
    				if (answer[index] != task01.displayValueOne * task01.Options[index]) {
    					$$invalidate(1, showPopUp = randomWrong());
    					$$invalidate(0, showNext = "inline-block");
    					break;
    				}

    				if (index == answer.length - 1) {
    					$$invalidate(1, showPopUp = randomCorrect());
    					$$invalidate(0, showNext = "inline-block");
    				}
    			}
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(3, answer = []);
    		$$invalidate(2, task01 = taskOne$1j());
    		$$invalidate(3, answer = new Array(task01.Options.length));
    		$$invalidate(0, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GIII_MA_C8> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler(i) {
    		answer[i] = this.value;
    		$$invalidate(3, answer);
    	}

    	function input_input_handler_1(i) {
    		answer[i] = this.value;
    		$$invalidate(3, answer);
    	}

    	function input_input_handler_2(i) {
    		answer[i] = this.value;
    		$$invalidate(3, answer);
    	}

    	$$self.$capture_state = () => ({
    		randomCorrect,
    		randomWrong,
    		taskOne: taskOne$1j,
    		showNext,
    		showPopUp,
    		task01,
    		answer,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("showNext" in $$props) $$invalidate(0, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(1, showPopUp = $$props.showPopUp);
    		if ("task01" in $$props) $$invalidate(2, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(3, answer = $$props.answer);
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		showNext,
    		showPopUp,
    		task01,
    		answer,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler,
    		input_input_handler_1,
    		input_input_handler_2
    	];
    }

    class GIII_MA_C8 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1z, create_fragment$1z, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GIII_MA_C8",
    			options,
    			id: create_fragment$1z.name
    		});
    	}
    }

    let task01$1i = {
      heading : "",
      question: "",
      valueArray: [], 
      answer: 0, 
      operator: "+",
      columns: 0
    };

    let columns$d = 2;
    let maxValue$13 = 10;
    let minValue$13 = 1;


    function taskOne$1i() {
      task01$1i.heading = "Addition facts - sums up to 10";
      task01$1i.question = "Add : ";
      task01$1i.answer = 0;
      task01$1i.columns = columns$d;
      task01$1i.valueArray = [];

          for (let i = 0; i < columns$d; i++) {
            task01$1i.valueArray[i] = Math.floor(Math.random() * (maxValue$13 - minValue$13 + 1) ) + minValue$13; 
            task01$1i.answer += task01$1i.valueArray[i];        
          }
        while(task01$1i.answer > maxValue$13){
          console.log('enter');
            task01$1i.answer = 0;
          for (let i = 0; i < columns$d; i++) {
            task01$1i.valueArray[i] = Math.floor(Math.random() * (maxValue$13 - minValue$13 + 1) ) + minValue$13; 
            task01$1i.answer += task01$1i.valueArray[i];        
          }
        }

      return task01$1i;
    }

    /* src/components/taskComponents/GII_MA_E1.svelte generated by Svelte v3.37.0 */
    const file$1x = "src/components/taskComponents/GII_MA_E1.svelte";

    function get_each_context$1i(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	child_ctx[13] = i;
    	return child_ctx;
    }

    function get_each_context_1$j(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[14] = list[i];
    	return child_ctx;
    }

    // (68:24) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$13(ctx) {
    	let t_value = /*task01*/ ctx[0].operator + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$13.name,
    		type: "if",
    		source: "(68:24) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (73:32) {#each Array(col) as val}
    function create_each_block_1$j(ctx) {
    	let td;
    	let svg;
    	let rect;

    	const block = {
    		c: function create() {
    			td = element("td");
    			svg = svg_element("svg");
    			rect = svg_element("rect");
    			attr_dev(rect, "x", "3");
    			attr_dev(rect, "y", "3");
    			attr_dev(rect, "width", "50");
    			attr_dev(rect, "height", "50");
    			set_style(rect, "fill", "blue");
    			set_style(rect, "stroke", "pink");
    			set_style(rect, "stroke-width", "5");
    			set_style(rect, "fill-opacity", "0.1");
    			set_style(rect, "stroke-opacity", "0.9");
    			add_location(rect, file$1x, 74, 36, 2085);
    			attr_dev(svg, "width", "60");
    			attr_dev(svg, "height", "60");
    			add_location(svg, file$1x, 73, 51, 2020);
    			attr_dev(td, "align", "right");
    			add_location(td, file$1x, 73, 32, 2001);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, svg);
    			append_dev(svg, rect);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$j.name,
    		type: "each",
    		source: "(73:32) {#each Array(col) as val}",
    		ctx
    	});

    	return block;
    }

    // (67:24) {#each task01.valueArray as col, i }
    function create_each_block$1i(ctx) {
    	let t0;
    	let tr;
    	let t1;
    	let if_block = /*i*/ ctx[13] == /*task01*/ ctx[0].valueArray.length - 1 && create_if_block$13(ctx);
    	let each_value_1 = Array(/*col*/ ctx[11]);
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$j(get_each_context_1$j(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t0 = space();
    			tr = element("tr");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			add_location(tr, file$1x, 71, 28, 1906);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, tr, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (/*i*/ ctx[13] == /*task01*/ ctx[0].valueArray.length - 1) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$13(ctx);
    					if_block.c();
    					if_block.m(t0.parentNode, t0);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*task01*/ 1) {
    				const old_length = each_value_1.length;
    				each_value_1 = Array(/*col*/ ctx[11]);
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = old_length; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$j(ctx, each_value_1, i);

    					if (!each_blocks[i]) {
    						each_blocks[i] = create_each_block_1$j(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, t1);
    					}
    				}

    				for (i = each_value_1.length; i < old_length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(tr);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1i.name,
    		type: "each",
    		source: "(67:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1y(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let solution;
    	let t12;
    	let div4;
    	let button0;
    	let t14;
    	let button1;
    	let t16;
    	let button2;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1i(get_each_context$1i(ctx, each_value, i));
    	}

    	solution = new AdditionSolution({
    			props: {
    				num_qnty: /*task01*/ ctx[0].columns,
    				usr_resp: /*answer*/ ctx[1],
    				num: /*task01*/ ctx[0].valueArray,
    				ans_submit: /*showSolution*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			create_component(solution.$$.fragment);
    			t12 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t14 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t16 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$1x, 53, 10, 1328);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1x, 52, 6, 1278);
    			add_location(h4, file$1x, 60, 12, 1506);
    			attr_dev(table, "width", "100");
    			add_location(table, file$1x, 64, 16, 1578);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$1x, 81, 20, 2458);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$1x, 82, 20, 2553);
    			add_location(h6, file$1x, 83, 20, 2675);
    			add_location(div1, file$1x, 62, 12, 1551);
    			add_location(div2, file$1x, 57, 8, 1485);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1x, 88, 12, 2783);
    			add_location(div3, file$1x, 87, 8, 2765);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1x, 92, 12, 3027);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1x, 93, 12, 3123);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1x, 94, 12, 3219);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$1x, 91, 8, 2996);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$1x, 56, 6, 1413);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$1x, 51, 5, 1230);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$1x, 50, 1, 1196);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			mount_component(solution, div5, null);
    			append_dev(div5, t12);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t14);
    			append_dev(div4, button1);
    			append_dev(div4, t16);
    			append_dev(div4, button2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[7]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*task01*/ 1) && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*task01*/ 1) && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*Array, task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1i(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1i(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if ((!current || dirty & /*task01*/ 1) && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (!current || dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (!current || dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}

    			const solution_changes = {};
    			if (dirty & /*task01*/ 1) solution_changes.num_qnty = /*task01*/ ctx[0].columns;
    			if (dirty & /*answer*/ 2) solution_changes.usr_resp = /*answer*/ ctx[1];
    			if (dirty & /*task01*/ 1) solution_changes.num = /*task01*/ ctx[0].valueArray;
    			if (dirty & /*showSolution*/ 16) solution_changes.ans_submit = /*showSolution*/ ctx[4];
    			solution.$set(solution_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			destroy_component(solution);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const max$o = 10;
    const min$o = 1;
    const numberofColumn$o = 2;

    function instance$1y($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GII_MA_E1", slots, []);
    	let heading = "Review - add one-digit numbers - sums to 10";
    	let question = "Add :";
    	let maxandmin = MaxandMin$5(max$o, min$o, numberofColumn$o, heading, question);
    	let task01 = taskOne$1i();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			$$invalidate(4, showSolution = true);
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$1i());
    		$$invalidate(4, showSolution = false);
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GII_MA_E1> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1i,
    		randomCorrect,
    		randomWrong,
    		MaxandMin: MaxandMin$5,
    		Solution: AdditionSolution,
    		heading,
    		question,
    		max: max$o,
    		min: min$o,
    		numberofColumn: numberofColumn$o,
    		maxandmin,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("heading" in $$props) heading = $$props.heading;
    		if ("question" in $$props) question = $$props.question;
    		if ("maxandmin" in $$props) maxandmin = $$props.maxandmin;
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) $$invalidate(4, showSolution = $$props.showSolution);
    		if ("CheckAnswer" in $$props) $$invalidate(5, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(6, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class GII_MA_E1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1y, create_fragment$1y, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GII_MA_E1",
    			options,
    			id: create_fragment$1y.name
    		});
    	}
    }

    let task01$1h = {
      heading: "Make a number using addition - sums up to 10",
      question: "Here are the ways to make 4. Find the pattern and type the missing addition number sentence.",
      questionValue : 0,
      valueArray: [],
      answer: 0,
      randomAnswer: 0,
      solutionArray : [],
      columns: 0,
    };

    const maxValue$12 = 10;
    const minValue$12 = 1;
    const findInMaxNumber$o = 10;
    const showbtn$9 = 4;

    function taskOne$1h() {
      task01$1h.questionValue = Math.floor(Math.random() * (maxValue$12 - minValue$12 + 1)) + minValue$12;
      task01$1h.question = "Which is not a way to make "+task01$1h.questionValue+" ?";
      task01$1h.valueArray = [];
      task01$1h.columns = 2;
      
      let opts = [];
      let ans = [];
      for (let i = 0; i < findInMaxNumber$o; i++) {
        for (let j = 0; j < findInMaxNumber$o; j++) {
          let a = i+"+"+j;
          if (task01$1h.questionValue == (i + j)) {          
              ans.push(a);
          }else {
            opts.push(a);
          }
        }    
      }

      task01$1h.valueArray = randomArrayNumbers(showbtn$9,ans.length,0,ans);
      task01$1h.answer = opts[Math.floor(Math.random() * opts.length)];
      let tempNum = Math.floor(Math.random() * task01$1h.valueArray.length);
      task01$1h.valueArray[tempNum] = task01$1h.answer; 
      task01$1h.solutionArray =  task01$1h.answer.split('+');  
      task01$1h.randomAnswer = Math.floor(Math.random() * task01$1h.valueArray.length);
      task01$1h.answer = tempNum;
      console.log(task01$1h.solutionArray);
      return task01$1h;

    }

    /* src/components/taskComponents/GII_MA_E2.svelte generated by Svelte v3.37.0 */
    const file$1w = "src/components/taskComponents/GII_MA_E2.svelte";

    function get_each_context$1h(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (65:15) {#each task01.valueArray as value,i}
    function create_each_block$1h(ctx) {
    	let button;
    	let t_value = /*value*/ ctx[8] + "";
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "class", "btn toggle-btn ");
    			add_location(button, file$1w, 65, 15, 1479);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleClick*/ ctx[6](/*i*/ ctx[10]), false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*value*/ ctx[8] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1h.name,
    		type: "each",
    		source: "(65:15) {#each task01.valueArray as value,i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1x(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let t4;
    	let div3;
    	let h5;
    	let t5;
    	let t6;
    	let solution;
    	let t7;
    	let div4;
    	let button0;
    	let t9;
    	let button1;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1h(get_each_context$1h(ctx, each_value, i));
    	}

    	solution = new AdditionSolution({
    			props: {
    				num_qnty: /*task01*/ ctx[0].columns,
    				usr_resp: /*answer*/ ctx[1] + 1,
    				num: /*task01*/ ctx[0].solutionArray,
    				ans_submit: /*showSolution*/ ctx[4],
    				answerchange: /*task01*/ ctx[0].answer + 1
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t5 = text(/*showPopUp*/ ctx[3]);
    			t6 = space();
    			create_component(solution.$$.fragment);
    			t7 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Rerun";
    			t9 = space();
    			button1 = element("button");
    			button1.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$1w, 57, 10, 1190);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1w, 56, 6, 1140);
    			add_location(h4, file$1w, 62, 12, 1366);
    			add_location(div1, file$1w, 63, 12, 1405);
    			add_location(div2, file$1w, 61, 8, 1347);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1w, 73, 12, 1695);
    			add_location(div3, file$1w, 72, 8, 1677);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1w, 79, 12, 1987);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1w, 80, 12, 2083);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$1w, 77, 8, 1955);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$1w, 60, 6, 1275);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$1w, 55, 5, 1092);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$1w, 54, 1, 1058);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			append_dev(div5, t4);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t5);
    			append_dev(div5, t6);
    			mount_component(solution, div5, null);
    			append_dev(div5, t7);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t9);
    			append_dev(div4, button1);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button0, "click", /*NextQuestion*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*task01*/ 1) && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*task01*/ 1) && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*handleClick, task01*/ 65) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1h(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1h(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (!current || dirty & /*showPopUp*/ 8) set_data_dev(t5, /*showPopUp*/ ctx[3]);

    			if (!current || dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}

    			const solution_changes = {};
    			if (dirty & /*task01*/ 1) solution_changes.num_qnty = /*task01*/ ctx[0].columns;
    			if (dirty & /*answer*/ 2) solution_changes.usr_resp = /*answer*/ ctx[1] + 1;
    			if (dirty & /*task01*/ 1) solution_changes.num = /*task01*/ ctx[0].solutionArray;
    			if (dirty & /*showSolution*/ 16) solution_changes.ans_submit = /*showSolution*/ ctx[4];
    			if (dirty & /*task01*/ 1) solution_changes.answerchange = /*task01*/ ctx[0].answer + 1;
    			solution.$set(solution_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			destroy_component(solution);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1x($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GII_MA_E2", slots, []);
    	let task01 = taskOne$1h();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			$$invalidate(2, showNext = "inline-block");
    			return;
    		} else {
    			$$invalidate(4, showSolution = true);
    			$$invalidate(3, showPopUp = randomWrong());
    			$$invalidate(2, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(4, showSolution = false);
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$1h());
    		$$invalidate(2, showNext = "none");
    	};

    	const handleClick = parameter => () => {
    		$$invalidate(1, answer = parameter);
    		CheckAnswer();
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GII_MA_E2> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1h,
    		randomCorrect,
    		randomWrong,
    		Solution: AdditionSolution,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		handleClick
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) $$invalidate(4, showSolution = $$props.showSolution);
    		if ("CheckAnswer" in $$props) CheckAnswer = $$props.CheckAnswer;
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [task01, answer, showNext, showPopUp, showSolution, NextQuestion, handleClick];
    }

    class GII_MA_E2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1x, create_fragment$1x, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GII_MA_E2",
    			options,
    			id: create_fragment$1x.name
    		});
    	}
    }

    let task01$1g = {
      heading: "Make a number using addition - sums up to 10",
      question: "Here are the ways to make 4. Find the pattern and type the missing addition number sentence.",
      questionValue : 0,
      valueArray: [],
      answer: 0,
      randomAnswer: 0,
      solutionArray : [],
      columns: 0,
    };

    const maxValue$11 = 10;
    const minValue$11 = 1;
    const findInMaxNumber$n = 10;
    const showbtn$8 = 4;

    function taskOne$1g() {
      task01$1g.questionValue = Math.floor(Math.random() * (maxValue$11 - minValue$11 + 1)) + minValue$11;
      task01$1g.question = "How do you make "+task01$1g.questionValue+" ?";
      task01$1g.valueArray = [];
      task01$1g.columns = 2;
      
      let opts = [];
      let ans = [];
      for (let i = 0; i < findInMaxNumber$n; i++) {
        for (let j = 0; j < findInMaxNumber$n; j++) {
          let a = i+"+"+j;
          if (task01$1g.questionValue == (i + j)) {          
              ans.push(a);
          }else {
            opts.push(a);
          }
        }    
      }

      task01$1g.valueArray = randomArrayNumbers(showbtn$8,opts.length,0,opts);
      task01$1g.answer = ans[Math.floor(Math.random() * ans.length)];
      let tempNum = Math.floor(Math.random() * task01$1g.valueArray.length);
      task01$1g.valueArray[tempNum] = task01$1g.answer; 
      task01$1g.solutionArray =  task01$1g.answer.split('+');  
      task01$1g.randomAnswer = Math.floor(Math.random() * task01$1g.valueArray.length);
      task01$1g.answer = tempNum;
      console.log(task01$1g.solutionArray);
      return task01$1g;

    }

    /* src/components/taskComponents/GI_MA_E3.svelte generated by Svelte v3.37.0 */
    const file$1v = "src/components/taskComponents/GI_MA_E3.svelte";

    function get_each_context$1g(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (65:15) {#each task01.valueArray as value,i}
    function create_each_block$1g(ctx) {
    	let button;
    	let t_value = /*value*/ ctx[8] + "";
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "class", "btn toggle-btn ");
    			add_location(button, file$1v, 65, 15, 1478);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleClick*/ ctx[6](/*i*/ ctx[10]), false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*value*/ ctx[8] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1g.name,
    		type: "each",
    		source: "(65:15) {#each task01.valueArray as value,i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1w(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let t4;
    	let div3;
    	let h5;
    	let t5;
    	let t6;
    	let solution;
    	let t7;
    	let div4;
    	let button0;
    	let t9;
    	let button1;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1g(get_each_context$1g(ctx, each_value, i));
    	}

    	solution = new AdditionSolution({
    			props: {
    				num_qnty: /*task01*/ ctx[0].columns,
    				usr_resp: /*answer*/ ctx[1] + 1,
    				num: /*task01*/ ctx[0].solutionArray,
    				ans_submit: /*showSolution*/ ctx[4],
    				answerchange: /*task01*/ ctx[0].answer + 1
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t5 = text(/*showPopUp*/ ctx[3]);
    			t6 = space();
    			create_component(solution.$$.fragment);
    			t7 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Rerun";
    			t9 = space();
    			button1 = element("button");
    			button1.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$1v, 57, 10, 1189);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1v, 56, 6, 1139);
    			add_location(h4, file$1v, 62, 12, 1365);
    			add_location(div1, file$1v, 63, 12, 1404);
    			add_location(div2, file$1v, 61, 8, 1346);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1v, 73, 12, 1694);
    			add_location(div3, file$1v, 72, 8, 1676);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1v, 79, 12, 1986);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1v, 80, 12, 2082);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$1v, 77, 8, 1954);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$1v, 60, 6, 1274);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$1v, 55, 5, 1091);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$1v, 54, 1, 1057);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			append_dev(div5, t4);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t5);
    			append_dev(div5, t6);
    			mount_component(solution, div5, null);
    			append_dev(div5, t7);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t9);
    			append_dev(div4, button1);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button0, "click", /*NextQuestion*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*task01*/ 1) && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*task01*/ 1) && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*handleClick, task01*/ 65) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1g(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1g(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (!current || dirty & /*showPopUp*/ 8) set_data_dev(t5, /*showPopUp*/ ctx[3]);

    			if (!current || dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}

    			const solution_changes = {};
    			if (dirty & /*task01*/ 1) solution_changes.num_qnty = /*task01*/ ctx[0].columns;
    			if (dirty & /*answer*/ 2) solution_changes.usr_resp = /*answer*/ ctx[1] + 1;
    			if (dirty & /*task01*/ 1) solution_changes.num = /*task01*/ ctx[0].solutionArray;
    			if (dirty & /*showSolution*/ 16) solution_changes.ans_submit = /*showSolution*/ ctx[4];
    			if (dirty & /*task01*/ 1) solution_changes.answerchange = /*task01*/ ctx[0].answer + 1;
    			solution.$set(solution_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			destroy_component(solution);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1w($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GI_MA_E3", slots, []);
    	let task01 = taskOne$1g();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			$$invalidate(2, showNext = "inline-block");
    			return;
    		} else {
    			$$invalidate(4, showSolution = true);
    			$$invalidate(3, showPopUp = randomWrong());
    			$$invalidate(2, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(4, showSolution = false);
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$1g());
    		$$invalidate(2, showNext = "none");
    	};

    	const handleClick = parameter => () => {
    		$$invalidate(1, answer = parameter);
    		CheckAnswer();
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GI_MA_E3> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1g,
    		randomCorrect,
    		randomWrong,
    		Solution: AdditionSolution,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		handleClick
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) $$invalidate(4, showSolution = $$props.showSolution);
    		if ("CheckAnswer" in $$props) CheckAnswer = $$props.CheckAnswer;
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [task01, answer, showNext, showPopUp, showSolution, NextQuestion, handleClick];
    }

    class GI_MA_E3 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1w, create_fragment$1w, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GI_MA_E3",
    			options,
    			id: create_fragment$1w.name
    		});
    	}
    }

    let task01$1f = {
      heading: "Review - writing addition sentences - sums to 10",
      question: "Which picture shows 1+2=3?",
      questionValue : 0,
      valueArray: [],
      answer: 0,
      randomAnswer: 0,
      solutionArray : [],
      columns: 0,
      displayArray :[]
    };

    const maxValue$10 = 10;
    const minValue$10 = 1;
    const findInMaxNumber$m = 10;
    const showbtn$7 = 4;

    function taskOne$1f() {
      task01$1f.questionValue = Math.floor(Math.random() * (maxValue$10 - minValue$10 + 1)) + minValue$10;
      task01$1f.displayArray = [];
      task01$1f.valueArray = [];
      task01$1f.columns = 2;
      
      let opts = [];
      let ans = [];
      for (let i = 1; i < findInMaxNumber$m; i++) {
        for (let j = 1; j < findInMaxNumber$m; j++) {
          let a = i+"+"+j;
          if (task01$1f.questionValue == (i + j)) {          
              ans.push(a);
          }else {
            opts.push(a);
          }
        }    
      }

      task01$1f.valueArray = randomArrayNumbers(showbtn$7,opts.length,0,opts);
      task01$1f.answer = ans[Math.floor(Math.random() * ans.length)];
      
      task01$1f.question = "Which picture shows "+task01$1f.answer+"?";
      let tempNum = Math.floor(Math.random() * task01$1f.valueArray.length);
      task01$1f.valueArray[tempNum] = task01$1f.answer; 
      task01$1f.solutionArray =  task01$1f.answer.split('+');  
      task01$1f.randomAnswer = Math.floor(Math.random() * task01$1f.valueArray.length);
      task01$1f.answer = tempNum;
      for (let index = 0; index < task01$1f.valueArray.length; index++) {
        task01$1f.displayArray[index] = task01$1f.valueArray[index].split('+').map(function(item) {
          return parseInt(item, 10);
      });
        
      }
      console.log( task01$1f.displayArray);
      
      return task01$1f;

    }

    /* src/components/taskComponents/GII_MA_E3.svelte generated by Svelte v3.37.0 */
    const file$1u = "src/components/taskComponents/GII_MA_E3.svelte";

    function get_each_context$1f(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    function get_each_context_1$i(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	return child_ctx;
    }

    function get_each_context_2$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	child_ctx[15] = i;
    	return child_ctx;
    }

    // (71:24) {#each Array(i) as _,a }
    function create_each_block_2$6(ctx) {
    	let svg;
    	let rect;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			rect = svg_element("rect");
    			attr_dev(rect, "x", "3");
    			attr_dev(rect, "y", "3");
    			attr_dev(rect, "width", "50");
    			attr_dev(rect, "height", "50");
    			set_style(rect, "fill", "blue");
    			set_style(rect, "stroke", "blue");
    			set_style(rect, "stroke-width", "5");
    			set_style(rect, "fill-opacity", "0.1");
    			set_style(rect, "stroke-opacity", "0.9");
    			add_location(rect, file$1u, 73, 32, 1800);
    			attr_dev(svg, "width", "60");
    			attr_dev(svg, "height", "60");
    			add_location(svg, file$1u, 72, 28, 1739);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, rect);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$6.name,
    		type: "each",
    		source: "(71:24) {#each Array(i) as _,a }",
    		ctx
    	});

    	return block;
    }

    // (70:16) {#each value as i}
    function create_each_block_1$i(ctx) {
    	let each_1_anchor;
    	let each_value_2 = Array(/*i*/ ctx[10]);
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$6(get_each_context_2$6(ctx, each_value_2, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1) {
    				const old_length = each_value_2.length;
    				each_value_2 = Array(/*i*/ ctx[10]);
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = old_length; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$6(ctx, each_value_2, i);

    					if (!each_blocks[i]) {
    						each_blocks[i] = create_each_block_2$6(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (i = each_value_2.length; i < old_length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_2.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$i.name,
    		type: "each",
    		source: "(70:16) {#each value as i}",
    		ctx
    	});

    	return block;
    }

    // (67:15) {#each task01.displayArray as value,i}
    function create_each_block$1f(ctx) {
    	let button;
    	let t;
    	let mounted;
    	let dispose;
    	let each_value_1 = /*value*/ ctx[8];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$i(get_each_context_1$i(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			button = element("button");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			attr_dev(button, "class", "btn toggle-btn ");
    			add_location(button, file$1u, 67, 15, 1522);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(button, null);
    			}

    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleClick*/ ctx[6](/*i*/ ctx[10]), false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*Array, task01*/ 1) {
    				each_value_1 = /*value*/ ctx[8];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$i(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$i(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(button, t);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1f.name,
    		type: "each",
    		source: "(67:15) {#each task01.displayArray as value,i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1v(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let t4;
    	let div3;
    	let h5;
    	let t5;
    	let t6;
    	let solution;
    	let t7;
    	let div4;
    	let button0;
    	let t9;
    	let button1;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].displayArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1f(get_each_context$1f(ctx, each_value, i));
    	}

    	solution = new AdditionSolution({
    			props: {
    				num_qnty: /*task01*/ ctx[0].columns,
    				usr_resp: /*answer*/ ctx[1] + 1,
    				num: /*task01*/ ctx[0].solutionArray,
    				ans_submit: /*showSolution*/ ctx[4],
    				answerchange: /*task01*/ ctx[0].answer + 1
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t5 = text(/*showPopUp*/ ctx[3]);
    			t6 = space();
    			create_component(solution.$$.fragment);
    			t7 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Rerun";
    			t9 = space();
    			button1 = element("button");
    			button1.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$1u, 59, 10, 1231);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1u, 58, 6, 1181);
    			add_location(h4, file$1u, 64, 12, 1407);
    			add_location(div1, file$1u, 65, 12, 1446);
    			add_location(div2, file$1u, 63, 8, 1388);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1u, 85, 12, 2232);
    			add_location(div3, file$1u, 84, 8, 2214);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1u, 91, 12, 2524);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1u, 92, 12, 2620);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$1u, 89, 8, 2492);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$1u, 62, 6, 1316);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$1u, 57, 5, 1133);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$1u, 56, 1, 1099);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			append_dev(div5, t4);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t5);
    			append_dev(div5, t6);
    			mount_component(solution, div5, null);
    			append_dev(div5, t7);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t9);
    			append_dev(div4, button1);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button0, "click", /*NextQuestion*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*task01*/ 1) && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*task01*/ 1) && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*handleClick, task01, Array*/ 65) {
    				each_value = /*task01*/ ctx[0].displayArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1f(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1f(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (!current || dirty & /*showPopUp*/ 8) set_data_dev(t5, /*showPopUp*/ ctx[3]);

    			if (!current || dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}

    			const solution_changes = {};
    			if (dirty & /*task01*/ 1) solution_changes.num_qnty = /*task01*/ ctx[0].columns;
    			if (dirty & /*answer*/ 2) solution_changes.usr_resp = /*answer*/ ctx[1] + 1;
    			if (dirty & /*task01*/ 1) solution_changes.num = /*task01*/ ctx[0].solutionArray;
    			if (dirty & /*showSolution*/ 16) solution_changes.ans_submit = /*showSolution*/ ctx[4];
    			if (dirty & /*task01*/ 1) solution_changes.answerchange = /*task01*/ ctx[0].answer + 1;
    			solution.$set(solution_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			destroy_component(solution);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1v($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GII_MA_E3", slots, []);
    	let task01 = taskOne$1f();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			$$invalidate(2, showNext = "inline-block");
    			return;
    		} else {
    			$$invalidate(4, showSolution = true);
    			$$invalidate(3, showPopUp = randomWrong());
    			$$invalidate(2, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(4, showSolution = false);
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$1f());
    		$$invalidate(2, showNext = "none");
    	};

    	const handleClick = parameter => () => {
    		$$invalidate(1, answer = parameter);
    		CheckAnswer();
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GII_MA_E3> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		each,
    		taskOne: taskOne$1f,
    		randomCorrect,
    		randomWrong,
    		Solution: AdditionSolution,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		handleClick
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) $$invalidate(4, showSolution = $$props.showSolution);
    		if ("CheckAnswer" in $$props) CheckAnswer = $$props.CheckAnswer;
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [task01, answer, showNext, showPopUp, showSolution, NextQuestion, handleClick];
    }

    class GII_MA_E3 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1v, create_fragment$1v, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GII_MA_E3",
    			options,
    			id: create_fragment$1v.name
    		});
    	}
    }

    let task01$1e = {
        heading : "",
        question: "",
        valueArray: [], 
        answer: 0, 
        operator: "+",
        columns: 2
      };
      
      
      let maxValue$$ = 10;
      let minValue$$ = 1;

      
      
     
      
      function taskOne$1e() {
        task01$1e.heading = "Add doubles";
        task01$1e.question = "Add the doubles.";
        task01$1e.answer = 0;
        
        task01$1e.valueArray = [];
        let temp = Math.floor(Math.random() * (maxValue$$ - minValue$$ + 1) ) + minValue$$; 
        for (let i = 0; i < task01$1e.columns; i++) {
          task01$1e.valueArray[i] = temp;
          task01$1e.answer += task01$1e.valueArray[i];   
        }
        return task01$1e;
      }

    /* src/components/taskComponents/GII_MA_E4.svelte generated by Svelte v3.37.0 */
    const file$1t = "src/components/taskComponents/GII_MA_E4.svelte";

    function get_each_context$1e(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	child_ctx[13] = i;
    	return child_ctx;
    }

    // (72:28) {:else}
    function create_else_block$$(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[11] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$1t, 73, 32, 2049);
    			add_location(tr, file$1t, 72, 28, 2012);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[11] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$$.name,
    		type: "else",
    		source: "(72:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (68:28) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$12(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[11] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$1t, 69, 50, 1845);
    			attr_dev(td, "align", "right");
    			add_location(td, file$1t, 69, 32, 1827);
    			add_location(tr, file$1t, 68, 28, 1790);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[11] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$12.name,
    		type: "if",
    		source: "(68:28) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (67:24) {#each task01.valueArray as col, i }
    function create_each_block$1e(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[13] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$12;
    		return create_else_block$$;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1e.name,
    		type: "each",
    		source: "(67:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1u(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let solution;
    	let t12;
    	let div4;
    	let button0;
    	let t14;
    	let button1;
    	let t16;
    	let button2;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1e(get_each_context$1e(ctx, each_value, i));
    	}

    	solution = new AdditionSolution({
    			props: {
    				num_qnty: /*task01*/ ctx[0].columns,
    				usr_resp: /*answer*/ ctx[1],
    				num: /*task01*/ ctx[0].valueArray,
    				ans_submit: /*showSolution*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			create_component(solution.$$.fragment);
    			t12 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t14 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t16 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$1t, 53, 10, 1315);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1t, 52, 6, 1265);
    			add_location(h4, file$1t, 60, 12, 1493);
    			attr_dev(table, "width", "100");
    			add_location(table, file$1t, 64, 16, 1565);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$1t, 78, 20, 2242);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$1t, 79, 20, 2337);
    			add_location(h6, file$1t, 80, 20, 2459);
    			add_location(div1, file$1t, 62, 12, 1538);
    			add_location(div2, file$1t, 57, 8, 1472);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1t, 85, 12, 2567);
    			add_location(div3, file$1t, 84, 8, 2549);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1t, 89, 12, 2811);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1t, 90, 12, 2907);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1t, 91, 12, 3003);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$1t, 88, 8, 2780);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$1t, 56, 6, 1400);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$1t, 51, 5, 1217);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$1t, 50, 1, 1183);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			mount_component(solution, div5, null);
    			append_dev(div5, t12);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t14);
    			append_dev(div4, button1);
    			append_dev(div4, t16);
    			append_dev(div4, button2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[7]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*task01*/ 1) && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*task01*/ 1) && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1e(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1e(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if ((!current || dirty & /*task01*/ 1) && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (!current || dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (!current || dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}

    			const solution_changes = {};
    			if (dirty & /*task01*/ 1) solution_changes.num_qnty = /*task01*/ ctx[0].columns;
    			if (dirty & /*answer*/ 2) solution_changes.usr_resp = /*answer*/ ctx[1];
    			if (dirty & /*task01*/ 1) solution_changes.num = /*task01*/ ctx[0].valueArray;
    			if (dirty & /*showSolution*/ 16) solution_changes.ans_submit = /*showSolution*/ ctx[4];
    			solution.$set(solution_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			destroy_component(solution);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const max$n = 10;
    const min$n = 0;
    const numberofColumn$n = 2;

    function instance$1u($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GII_MA_E4", slots, []);
    	let heading = "Addition facts - sums up to 10";
    	let question = "Add :";
    	let maxandmin = MaxandMin$5(max$n, min$n, numberofColumn$n, heading, question);
    	let task01 = taskOne$1e();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			$$invalidate(4, showSolution = true);
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$1e());
    		$$invalidate(4, showSolution = false);
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GII_MA_E4> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1e,
    		randomCorrect,
    		randomWrong,
    		MaxandMin: MaxandMin$5,
    		Solution: AdditionSolution,
    		heading,
    		question,
    		max: max$n,
    		min: min$n,
    		numberofColumn: numberofColumn$n,
    		maxandmin,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("heading" in $$props) heading = $$props.heading;
    		if ("question" in $$props) question = $$props.question;
    		if ("maxandmin" in $$props) maxandmin = $$props.maxandmin;
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) $$invalidate(4, showSolution = $$props.showSolution);
    		if ("CheckAnswer" in $$props) $$invalidate(5, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(6, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class GII_MA_E4 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1u, create_fragment$1u, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GII_MA_E4",
    			options,
    			id: create_fragment$1u.name
    		});
    	}
    }

    let task01$1d = {
      heading : "",
      question: "",
      valueArray: [], 
      answer: 0, 
      operator: "+",
      columns: 0
    };

    let columns$c = 2;
    let maxValue$_ = 20;
    let minValue$_ = 1;


    function taskOne$1d() {
      task01$1d.heading = "Addition facts - sums up to 20";
      task01$1d.question = "Add : ";
      task01$1d.answer = 0;
      task01$1d.columns = columns$c;
      task01$1d.valueArray = [];

          for (let i = 0; i < columns$c; i++) {
            task01$1d.valueArray[i] = Math.floor(Math.random() * (maxValue$_ - minValue$_ + 1) ) + minValue$_; 
            task01$1d.answer += task01$1d.valueArray[i];        
          }
        while(task01$1d.answer > maxValue$_){
          console.log('enter');
            task01$1d.answer = 0;
          for (let i = 0; i < columns$c; i++) {
            task01$1d.valueArray[i] = Math.floor(Math.random() * (maxValue$_ - minValue$_ + 1) ) + minValue$_; 
            task01$1d.answer += task01$1d.valueArray[i];        
          }
        }

      return task01$1d;
    }

    /* src/components/taskComponents/GII_MA_E6.svelte generated by Svelte v3.37.0 */
    const file$1s = "src/components/taskComponents/GII_MA_E6.svelte";

    function get_each_context$1d(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    function get_each_context_1$h(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	return child_ctx;
    }

    // (64:24) {:else}
    function create_else_block$_(ctx) {
    	const block = { c: noop, m: noop, p: noop, d: noop };

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$_.name,
    		type: "else",
    		source: "(64:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (62:24) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$11(ctx) {
    	let t_value = /*task01*/ ctx[0].operator + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$11.name,
    		type: "if",
    		source: "(62:24) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (67:32) {#each Array(col) as val}
    function create_each_block_1$h(ctx) {
    	let td;
    	let svg;
    	let rect;

    	const block = {
    		c: function create() {
    			td = element("td");
    			svg = svg_element("svg");
    			rect = svg_element("rect");
    			attr_dev(rect, "x", "3");
    			attr_dev(rect, "y", "3");
    			attr_dev(rect, "width", "50");
    			attr_dev(rect, "height", "50");
    			set_style(rect, "fill", "blue");
    			set_style(rect, "stroke", "pink");
    			set_style(rect, "stroke-width", "5");
    			set_style(rect, "fill-opacity", "0.1");
    			set_style(rect, "stroke-opacity", "0.9");
    			add_location(rect, file$1s, 68, 36, 1813);
    			attr_dev(svg, "width", "60");
    			attr_dev(svg, "height", "60");
    			add_location(svg, file$1s, 67, 51, 1748);
    			attr_dev(td, "align", "right");
    			add_location(td, file$1s, 67, 32, 1729);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, svg);
    			append_dev(svg, rect);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$h.name,
    		type: "each",
    		source: "(67:32) {#each Array(col) as val}",
    		ctx
    	});

    	return block;
    }

    // (61:24) {#each task01.valueArray as col, i }
    function create_each_block$1d(ctx) {
    	let t0;
    	let tr;
    	let t1;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[10] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$11;
    		return create_else_block$_;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);
    	let each_value_1 = Array(/*col*/ ctx[8]);
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$h(get_each_context_1$h(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			if_block.c();
    			t0 = space();
    			tr = element("tr");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			add_location(tr, file$1s, 65, 28, 1634);
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, tr, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(t0.parentNode, t0);
    				}
    			}

    			if (dirty & /*task01*/ 1) {
    				const old_length = each_value_1.length;
    				each_value_1 = Array(/*col*/ ctx[8]);
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = old_length; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$h(ctx, each_value_1, i);

    					if (!each_blocks[i]) {
    						each_blocks[i] = create_each_block_1$h(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, t1);
    					}
    				}

    				for (i = each_value_1.length; i < old_length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(tr);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1d.name,
    		type: "each",
    		source: "(61:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1t(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let solution;
    	let t12;
    	let div4;
    	let button0;
    	let t14;
    	let button1;
    	let t16;
    	let button2;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1d(get_each_context$1d(ctx, each_value, i));
    	}

    	solution = new AdditionSolution({
    			props: {
    				num_qnty: /*task01*/ ctx[0].columns,
    				usr_resp: /*answer*/ ctx[1],
    				num: /*task01*/ ctx[0].valueArray,
    				ans_submit: /*showSolution*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			create_component(solution.$$.fragment);
    			t12 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t14 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t16 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$1s, 47, 10, 1047);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1s, 46, 6, 997);
    			add_location(h4, file$1s, 54, 12, 1225);
    			attr_dev(table, "width", "100");
    			add_location(table, file$1s, 58, 16, 1297);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$1s, 75, 20, 2186);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$1s, 76, 20, 2281);
    			add_location(h6, file$1s, 77, 20, 2403);
    			add_location(div1, file$1s, 56, 12, 1270);
    			add_location(div2, file$1s, 51, 8, 1204);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1s, 82, 12, 2511);
    			add_location(div3, file$1s, 81, 8, 2493);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1s, 86, 12, 2755);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1s, 87, 12, 2851);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1s, 88, 12, 2947);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$1s, 85, 8, 2724);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$1s, 50, 6, 1132);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$1s, 45, 5, 949);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$1s, 44, 1, 915);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			mount_component(solution, div5, null);
    			append_dev(div5, t12);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t14);
    			append_dev(div4, button1);
    			append_dev(div4, t16);
    			append_dev(div4, button2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[7]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*task01*/ 1) && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*task01*/ 1) && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*Array, task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1d(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1d(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if ((!current || dirty & /*task01*/ 1) && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (!current || dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (!current || dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}

    			const solution_changes = {};
    			if (dirty & /*task01*/ 1) solution_changes.num_qnty = /*task01*/ ctx[0].columns;
    			if (dirty & /*answer*/ 2) solution_changes.usr_resp = /*answer*/ ctx[1];
    			if (dirty & /*task01*/ 1) solution_changes.num = /*task01*/ ctx[0].valueArray;
    			if (dirty & /*showSolution*/ 16) solution_changes.ans_submit = /*showSolution*/ ctx[4];
    			solution.$set(solution_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			destroy_component(solution);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1t($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GII_MA_E6", slots, []);
    	let task01 = taskOne$1d();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			$$invalidate(4, showSolution = true);
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$1d());
    		$$invalidate(4, showSolution = false);
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GII_MA_E6> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1d,
    		randomCorrect,
    		randomWrong,
    		Solution: AdditionSolution,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) $$invalidate(4, showSolution = $$props.showSolution);
    		if ("CheckAnswer" in $$props) $$invalidate(5, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(6, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class GII_MA_E6 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1t, create_fragment$1t, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GII_MA_E6",
    			options,
    			id: create_fragment$1t.name
    		});
    	}
    }

    let task01$1c = {
      heading: "Write addition sentences to describe pictures - sums to 20",
      question: "Write an addition number sentence based on the picture (for example, 2 + 1 = 3).",
      questionValue : 0,
      valueArray: [],
      answer: 0,
      randomAnswer: 0,
      columns: 2,
      solutionArray : [],
      operator : '+'
    };

    const maxValue$Z = 20;
    const minValue$Z = 1;
    const findInMaxNumber$l = 10;


    function taskOne$1c() {
      task01$1c.questionValue = Math.floor(Math.random() * (maxValue$Z - minValue$Z + 1)) + minValue$Z;  
      task01$1c.valueArray = [];
      for (let i = 1; i < findInMaxNumber$l; i++) {
        for (let j = 1; j < findInMaxNumber$l; j++) {
          if (task01$1c.questionValue == (i + j)) {
            let a = i+"+"+j+"="+(i+j);
              task01$1c.valueArray.push(a);
          }
        }
      }
      task01$1c.randomAnswer = Math.floor(Math.random() * task01$1c.valueArray.length);
      task01$1c.answer =  task01$1c.valueArray[task01$1c.randomAnswer];
      
      console.log(task01$1c.answer);
      let tempnum = task01$1c.answer.split('=');
      task01$1c.solutionArray =  tempnum[0].split('+');  
      console.log(task01$1c.solutionArray );
      return task01$1c;  
    }

    /* src/components/taskComponents/GII_MA_E7.svelte generated by Svelte v3.37.0 */
    const file$1r = "src/components/taskComponents/GII_MA_E7.svelte";

    function get_each_context$1c(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    function get_each_context_1$g(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	return child_ctx;
    }

    // (52:24) {#if i == (task01.solutionArray.length - 1) }
    function create_if_block$10(ctx) {
    	let t_value = /*task01*/ ctx[0].operator + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$10.name,
    		type: "if",
    		source: "(52:24) {#if i == (task01.solutionArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (56:32) {#each Array(parseInt(col)) as val}
    function create_each_block_1$g(ctx) {
    	let td;
    	let svg;
    	let rect;

    	const block = {
    		c: function create() {
    			td = element("td");
    			svg = svg_element("svg");
    			rect = svg_element("rect");
    			attr_dev(rect, "x", "3");
    			attr_dev(rect, "y", "3");
    			attr_dev(rect, "width", "50");
    			attr_dev(rect, "height", "50");
    			set_style(rect, "fill", "blue");
    			set_style(rect, "stroke", "pink");
    			set_style(rect, "stroke-width", "5");
    			set_style(rect, "fill-opacity", "0.1");
    			set_style(rect, "stroke-opacity", "0.9");
    			add_location(rect, file$1r, 57, 36, 1719);
    			attr_dev(svg, "width", "60");
    			attr_dev(svg, "height", "60");
    			add_location(svg, file$1r, 56, 51, 1654);
    			attr_dev(td, "align", "right");
    			add_location(td, file$1r, 56, 32, 1635);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, svg);
    			append_dev(svg, rect);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$g.name,
    		type: "each",
    		source: "(56:32) {#each Array(parseInt(col)) as val}",
    		ctx
    	});

    	return block;
    }

    // (51:12) {#each task01.solutionArray as col, i }
    function create_each_block$1c(ctx) {
    	let t;
    	let tr;
    	let if_block = /*i*/ ctx[10] == /*task01*/ ctx[0].solutionArray.length - 1 && create_if_block$10(ctx);
    	let each_value_1 = Array(parseInt(/*col*/ ctx[8]));
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$g(get_each_context_1$g(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    			tr = element("tr");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(tr, file$1r, 54, 28, 1530);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, tr, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*i*/ ctx[10] == /*task01*/ ctx[0].solutionArray.length - 1) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$10(ctx);
    					if_block.c();
    					if_block.m(t.parentNode, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*task01*/ 1) {
    				const old_length = each_value_1.length;
    				each_value_1 = Array(parseInt(/*col*/ ctx[8]));
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = old_length; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$g(ctx, each_value_1, i);

    					if (!each_blocks[i]) {
    						each_blocks[i] = create_each_block_1$g(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, null);
    					}
    				}

    				for (i = each_value_1.length; i < old_length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(tr);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1c.name,
    		type: "each",
    		source: "(51:12) {#each task01.solutionArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1s(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let t4;
    	let div1;
    	let input;
    	let t5;
    	let h6;
    	let t6;
    	let t7_value = /*task01*/ ctx[0].answer + "";
    	let t7;
    	let t8;
    	let div3;
    	let h5;
    	let t9;
    	let t10;
    	let solution;
    	let t11;
    	let div4;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let button2;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].solutionArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1c(get_each_context$1c(ctx, each_value, i));
    	}

    	solution = new AdditionSolution({
    			props: {
    				num_qnty: /*task01*/ ctx[0].columns,
    				usr_resp: /*answer*/ ctx[1],
    				num: /*task01*/ ctx[0].solutionArray,
    				ans_submit: /*showSolution*/ ctx[4],
    				answerchange: /*task01*/ ctx[0].answer
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			div1 = element("div");
    			input = element("input");
    			t5 = space();
    			h6 = element("h6");
    			t6 = text("answer ");
    			t7 = text(t7_value);
    			t8 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t9 = text(/*showPopUp*/ ctx[3]);
    			t10 = space();
    			create_component(solution.$$.fragment);
    			t11 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$1r, 44, 10, 1076);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1r, 43, 6, 1026);
    			add_location(h4, file$1r, 49, 12, 1252);
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "15");
    			add_location(input, file$1r, 64, 16, 2068);
    			add_location(h6, file$1r, 65, 16, 2172);
    			add_location(div1, file$1r, 63, 12, 2044);
    			add_location(div2, file$1r, 48, 8, 1233);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1r, 70, 12, 2286);
    			add_location(div3, file$1r, 69, 8, 2268);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1r, 75, 12, 2564);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1r, 76, 12, 2660);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1r, 77, 12, 2756);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$1r, 74, 8, 2533);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$1r, 47, 6, 1161);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$1r, 42, 5, 978);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$1r, 41, 1, 944);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div2, null);
    			}

    			append_dev(div2, t4);
    			append_dev(div2, div1);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t5);
    			append_dev(div1, h6);
    			append_dev(h6, t6);
    			append_dev(h6, t7);
    			append_dev(div5, t8);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t9);
    			append_dev(div5, t10);
    			mount_component(solution, div5, null);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t13);
    			append_dev(div4, button1);
    			append_dev(div4, t15);
    			append_dev(div4, button2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[7]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*task01*/ 1) && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*task01*/ 1) && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*Array, parseInt, task01*/ 1) {
    				each_value = /*task01*/ ctx[0].solutionArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1c(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1c(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div2, t4);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if ((!current || dirty & /*task01*/ 1) && t7_value !== (t7_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t7, t7_value);
    			if (!current || dirty & /*showPopUp*/ 8) set_data_dev(t9, /*showPopUp*/ ctx[3]);

    			if (!current || dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}

    			const solution_changes = {};
    			if (dirty & /*task01*/ 1) solution_changes.num_qnty = /*task01*/ ctx[0].columns;
    			if (dirty & /*answer*/ 2) solution_changes.usr_resp = /*answer*/ ctx[1];
    			if (dirty & /*task01*/ 1) solution_changes.num = /*task01*/ ctx[0].solutionArray;
    			if (dirty & /*showSolution*/ 16) solution_changes.ans_submit = /*showSolution*/ ctx[4];
    			if (dirty & /*task01*/ 1) solution_changes.answerchange = /*task01*/ ctx[0].answer;
    			solution.$set(solution_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			destroy_component(solution);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1s($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GII_MA_E7", slots, []);
    	let task01 = taskOne$1c();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		if (answer.replaceAll(" ", "") == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			$$invalidate(2, showNext = "inline-block");
    			return;
    		} else {
    			$$invalidate(4, showSolution = true);
    			$$invalidate(3, showPopUp = randomWrong());
    			$$invalidate(2, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(4, showSolution = false);
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$1c());
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GII_MA_E7> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1c,
    		randomCorrect,
    		randomWrong,
    		Solution: AdditionSolution,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) $$invalidate(4, showSolution = $$props.showSolution);
    		if ("CheckAnswer" in $$props) $$invalidate(5, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(6, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class GII_MA_E7 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1s, create_fragment$1s, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GII_MA_E7",
    			options,
    			id: create_fragment$1s.name
    		});
    	}
    }

    let task01$1b = {
      heading : "Addition input/output tables - sums to 20",
      question: "Complete the table.",
      qstNum : 0,
      valueArray: [], 
      answer: [], 
      operator: "+",
      columns: 4,
      input : 0
    };

    const maxValue$Y = 20;
    const minValue$Y = 1;
    const tablesize$2 = 4;
    function taskOne$1b() {

      task01$1b.valueArray = [];
      task01$1b.answer = []; 

       let displayBtn = randomNumbers$3(tablesize$2,maxValue$Y,minValue$Y);
       task01$1b.qstNum =  Math.floor(Math.random() * maxValue$Y);
       for(let i = 0 ; i < displayBtn.length;i++){
          task01$1b.valueArray[i] = [displayBtn[i], displayBtn[i]+task01$1b.qstNum];
          task01$1b.answer[i] = [displayBtn[i]+task01$1b.qstNum];
       }
       task01$1b.input = Math.floor(Math.random() * task01$1b.valueArray.length);
       for(let i = 0 ; i < displayBtn.length;i++){
         if(i != task01$1b.input){
          task01$1b.valueArray[i] = [displayBtn[i], ['i']];
         }
     }
      
      return task01$1b;
    }

    /* src/components/taskComponents/GII_MA_E8.svelte generated by Svelte v3.37.0 */
    const file$1q = "src/components/taskComponents/GII_MA_E8.svelte";

    function get_each_context$1b(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[9] = list;
    	child_ctx[10] = i;
    	return child_ctx;
    }

    function get_each_context_1$f(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	return child_ctx;
    }

    // (72:32) {:else}
    function create_else_block$Z(ctx) {
    	let td;
    	let t_value = /*a*/ ctx[11] + "";
    	let t;

    	const block = {
    		c: function create() {
    			td = element("td");
    			t = text(t_value);
    			attr_dev(td, "align", "right");
    			add_location(td, file$1q, 72, 32, 2001);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*a*/ ctx[11] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$Z.name,
    		type: "else",
    		source: "(72:32) {:else}",
    		ctx
    	});

    	return block;
    }

    // (70:32) {#if a == 'i'}
    function create_if_block$$(ctx) {
    	let td;
    	let input;
    	let mounted;
    	let dispose;

    	function input_input_handler() {
    		/*input_input_handler*/ ctx[6].call(input, /*i*/ ctx[10]);
    	}

    	const block = {
    		c: function create() {
    			td = element("td");
    			input = element("input");
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "style", " width : 30px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$1q, 70, 50, 1824);
    			attr_dev(td, "align", "right");
    			add_location(td, file$1q, 70, 32, 1806);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, input);
    			set_input_value(input, /*answer*/ ctx[1][/*i*/ ctx[10]]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1][/*i*/ ctx[10]]) {
    				set_input_value(input, /*answer*/ ctx[1][/*i*/ ctx[10]]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$$.name,
    		type: "if",
    		source: "(70:32) {#if a == 'i'}",
    		ctx
    	});

    	return block;
    }

    // (69:28) {#each col as a}
    function create_each_block_1$f(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*a*/ ctx[11] == "i") return create_if_block$$;
    		return create_else_block$Z;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$f.name,
    		type: "each",
    		source: "(69:28) {#each col as a}",
    		ctx
    	});

    	return block;
    }

    // (67:24) {#each task01.valueArray as col, i }
    function create_each_block$1b(ctx) {
    	let tr;
    	let t;
    	let each_value_1 = /*col*/ ctx[8];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$f(get_each_context_1$f(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			add_location(tr, file$1q, 67, 24, 1651);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			append_dev(tr, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*answer, task01*/ 3) {
    				each_value_1 = /*col*/ ctx[8];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$f(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$f(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, t);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1b.name,
    		type: "each",
    		source: "(67:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1r(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h40;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let h41;
    	let t4;
    	let t5_value = /*task01*/ ctx[0].qstNum + "";
    	let t5;
    	let t6;
    	let table;
    	let t7;
    	let h6;
    	let t8;
    	let t9_value = /*task01*/ ctx[0].answer + "";
    	let t9;
    	let t10;
    	let div3;
    	let h5;
    	let t11;
    	let t12;
    	let div4;
    	let button0;
    	let t14;
    	let button1;
    	let t16;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1b(get_each_context$1b(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h40 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			h41 = element("h4");
    			t4 = text("Rule: add ");
    			t5 = text(t5_value);
    			t6 = space();
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t7 = space();
    			h6 = element("h6");
    			t8 = text("answer ");
    			t9 = text(t9_value);
    			t10 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t11 = text(/*showPopUp*/ ctx[3]);
    			t12 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t14 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t16 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$1q, 53, 10, 1201);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1q, 52, 6, 1151);
    			add_location(h40, file$1q, 60, 12, 1379);
    			add_location(h41, file$1q, 63, 16, 1450);
    			attr_dev(table, "width", "100");
    			add_location(table, file$1q, 64, 16, 1501);
    			add_location(h6, file$1q, 80, 20, 2295);
    			add_location(div1, file$1q, 62, 12, 1424);
    			add_location(div2, file$1q, 57, 8, 1358);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1q, 85, 12, 2403);
    			add_location(div3, file$1q, 84, 8, 2385);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1q, 89, 12, 2541);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1q, 90, 12, 2637);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1q, 91, 12, 2733);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$1q, 88, 8, 2510);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$1q, 56, 6, 1286);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$1q, 51, 5, 1103);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$1q, 50, 1, 1069);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h40);
    			append_dev(h40, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, h41);
    			append_dev(h41, t4);
    			append_dev(h41, t5);
    			append_dev(div1, t6);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t7);
    			append_dev(div1, h6);
    			append_dev(h6, t8);
    			append_dev(h6, t9);
    			append_dev(div5, t10);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t11);
    			append_dev(div5, t12);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t14);
    			append_dev(div4, button1);
    			append_dev(div4, t16);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*task01*/ 1 && t5_value !== (t5_value = /*task01*/ ctx[0].qstNum + "")) set_data_dev(t5, t5_value);

    			if (dirty & /*task01, answer*/ 3) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1b(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1b(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*task01*/ 1 && t9_value !== (t9_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t9, t9_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t11, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1r($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GII_MA_E8", slots, []);
    	let task01 = taskOne$1b();
    	let answer = [];
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		for (let index = 0; index < answer.length; index++) {
    			if (task01.input != index) {
    				if (answer[index] != task01.answer[index]) {
    					$$invalidate(3, showPopUp = randomWrong());
    					showSolution = true;
    					return;
    				} else {
    					$$invalidate(3, showPopUp = randomCorrect());
    				}
    			}
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = []);
    		$$invalidate(1, answer.length = task01.answer.length, answer);
    		$$invalidate(0, task01 = taskOne$1b());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GII_MA_E8> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler(i) {
    		answer[i] = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1b,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class GII_MA_E8 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1r, create_fragment$1r, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GII_MA_E8",
    			options,
    			id: create_fragment$1r.name
    		});
    	}
    }

    let task01$1a = {
        heading : "",
        question: "",
        valueArray: [], 
        answer: 0, 
        operator: "+",
        columns: 2
      };
      
      
      let maxValue$X = 20;
      let minValue$X = 1;

      
      
     
      
      function taskOne$1a() {
        task01$1a.heading = "Add zero";
        task01$1a.question = "Add :";
        task01$1a.answer = 0;
        
        task01$1a.valueArray = [];
        task01$1a.valueArray[0] = Math.floor(Math.random() * (maxValue$X - minValue$X + 1) ) + minValue$X; 
        task01$1a.valueArray[1] = 0; 
        task01$1a.answer = task01$1a.valueArray[0];   
        return task01$1a;
      }

    /* src/components/taskComponents/GII_MA_E9.svelte generated by Svelte v3.37.0 */
    const file$1p = "src/components/taskComponents/GII_MA_E9.svelte";

    function get_each_context$1a(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	child_ctx[13] = i;
    	return child_ctx;
    }

    // (72:28) {:else}
    function create_else_block$Y(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[11] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$1p, 73, 32, 2049);
    			add_location(tr, file$1p, 72, 28, 2012);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[11] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$Y.name,
    		type: "else",
    		source: "(72:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (68:28) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$_(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[11] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$1p, 69, 50, 1845);
    			attr_dev(td, "align", "right");
    			add_location(td, file$1p, 69, 32, 1827);
    			add_location(tr, file$1p, 68, 28, 1790);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[11] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$_.name,
    		type: "if",
    		source: "(68:28) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (67:24) {#each task01.valueArray as col, i }
    function create_each_block$1a(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[13] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$_;
    		return create_else_block$Y;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1a.name,
    		type: "each",
    		source: "(67:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1q(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let solution;
    	let t12;
    	let div4;
    	let button0;
    	let t14;
    	let button1;
    	let t16;
    	let button2;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1a(get_each_context$1a(ctx, each_value, i));
    	}

    	solution = new AdditionSolution({
    			props: {
    				num_qnty: /*task01*/ ctx[0].columns,
    				usr_resp: /*answer*/ ctx[1],
    				num: /*task01*/ ctx[0].valueArray,
    				ans_submit: /*showSolution*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			create_component(solution.$$.fragment);
    			t12 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t14 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t16 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$1p, 53, 10, 1315);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1p, 52, 6, 1265);
    			add_location(h4, file$1p, 60, 12, 1493);
    			attr_dev(table, "width", "100");
    			add_location(table, file$1p, 64, 16, 1565);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$1p, 78, 20, 2242);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$1p, 79, 20, 2337);
    			add_location(h6, file$1p, 80, 20, 2459);
    			add_location(div1, file$1p, 62, 12, 1538);
    			add_location(div2, file$1p, 57, 8, 1472);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1p, 85, 12, 2567);
    			add_location(div3, file$1p, 84, 8, 2549);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1p, 89, 12, 2811);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1p, 90, 12, 2907);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1p, 91, 12, 3003);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$1p, 88, 8, 2780);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$1p, 56, 6, 1400);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$1p, 51, 5, 1217);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$1p, 50, 1, 1183);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			mount_component(solution, div5, null);
    			append_dev(div5, t12);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t14);
    			append_dev(div4, button1);
    			append_dev(div4, t16);
    			append_dev(div4, button2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[7]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*task01*/ 1) && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*task01*/ 1) && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1a(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1a(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if ((!current || dirty & /*task01*/ 1) && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (!current || dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (!current || dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}

    			const solution_changes = {};
    			if (dirty & /*task01*/ 1) solution_changes.num_qnty = /*task01*/ ctx[0].columns;
    			if (dirty & /*answer*/ 2) solution_changes.usr_resp = /*answer*/ ctx[1];
    			if (dirty & /*task01*/ 1) solution_changes.num = /*task01*/ ctx[0].valueArray;
    			if (dirty & /*showSolution*/ 16) solution_changes.ans_submit = /*showSolution*/ ctx[4];
    			solution.$set(solution_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			destroy_component(solution);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const max$m = 10;
    const min$m = 0;
    const numberofColumn$m = 2;

    function instance$1q($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GII_MA_E9", slots, []);
    	let heading = "Addition facts - sums up to 10";
    	let question = "Add :";
    	let maxandmin = MaxandMin$5(max$m, min$m, numberofColumn$m, heading, question);
    	let task01 = taskOne$1a();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			$$invalidate(4, showSolution = true);
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$1a());
    		$$invalidate(4, showSolution = false);
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GII_MA_E9> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1a,
    		randomCorrect,
    		randomWrong,
    		MaxandMin: MaxandMin$5,
    		Solution: AdditionSolution,
    		heading,
    		question,
    		max: max$m,
    		min: min$m,
    		numberofColumn: numberofColumn$m,
    		maxandmin,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("heading" in $$props) heading = $$props.heading;
    		if ("question" in $$props) question = $$props.question;
    		if ("maxandmin" in $$props) maxandmin = $$props.maxandmin;
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) $$invalidate(4, showSolution = $$props.showSolution);
    		if ("CheckAnswer" in $$props) $$invalidate(5, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(6, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class GII_MA_E9 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1q, create_fragment$1q, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GII_MA_E9",
    			options,
    			id: create_fragment$1q.name
    		});
    	}
    }

    let task01$19 = {
      heading : "",
      question: "",
      valueArray: [], 
      answer: 0, 
      operator: "+",
      columns: 0
    };

    let columns$b = 2;
    let maxValue$W = 9;
    let minValue$W = 1;


    function taskOne$19() {
      task01$19.heading = "Write the addition sentence - one digit";
      task01$19.question = "When Jill first moved into her house, there were no flowers in her back garden. Since then, Jill has planted 6 roses and 5 daisies. How many flowers are in her back garden now?";
      task01$19.answer = 0;
      task01$19.columns = columns$b;
      task01$19.valueArray = [];
          for (let i = 0; i < columns$b; i++) {
            task01$19.valueArray[i] = Math.floor(Math.random() * (maxValue$W - minValue$W + 1) ) + minValue$W; 
            task01$19.answer += task01$19.valueArray[i];        
          }
            while(task01$19.answer > maxValue$W){
                task01$19.answer = 0;
            for (let i = 0; i < columns$b; i++) {
                task01$19.valueArray[i] = Math.floor(Math.random() * (maxValue$W - minValue$W + 1) ) + minValue$W; 
                task01$19.answer += task01$19.valueArray[i];        
            }
            }
        task01$19.question = "When Jill first moved into her house, there were no flowers in her back garden. Since then, Jill has planted "+task01$19.valueArray[0]+" roses and "+task01$19.valueArray[1]+" daisies. How many flowers are in her back garden now?";
      return task01$19;
    }

    /* src/components/taskComponents/GII_MA_E12.svelte generated by Svelte v3.37.0 */
    const file$1o = "src/components/taskComponents/GII_MA_E12.svelte";

    function create_fragment$1p(ctx) {
    	let div6;
    	let div5;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div4;
    	let div1;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let input;
    	let t4;
    	let div2;
    	let h5;
    	let t5;
    	let t6;
    	let solution;
    	let t7;
    	let div3;
    	let button0;
    	let t9;
    	let button1;
    	let t11;
    	let button2;
    	let current;
    	let mounted;
    	let dispose;

    	solution = new AdditionSolution({
    			props: {
    				num_qnty: /*task01*/ ctx[0].columns,
    				usr_resp: /*answer*/ ctx[1],
    				num: /*task01*/ ctx[0].valueArray,
    				ans_submit: /*showSolution*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div6 = element("div");
    			div5 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div4 = element("div");
    			div1 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			input = element("input");
    			t4 = space();
    			div2 = element("div");
    			h5 = element("h5");
    			t5 = text(/*showPopUp*/ ctx[3]);
    			t6 = space();
    			create_component(solution.$$.fragment);
    			t7 = space();
    			div3 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t9 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t11 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$1o, 51, 9, 1075);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1o, 50, 5, 1026);
    			add_location(h4, file$1o, 57, 11, 1247);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$1o, 58, 11, 1285);
    			add_location(div1, file$1o, 55, 7, 1228);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1o, 62, 11, 1427);
    			add_location(div2, file$1o, 61, 7, 1410);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1o, 66, 11, 1667);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1o, 67, 11, 1762);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1o, 68, 11, 1857);
    			attr_dev(div3, "class", "mt-3");
    			add_location(div3, file$1o, 65, 7, 1637);
    			attr_dev(div4, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div4, file$1o, 54, 5, 1157);
    			attr_dev(div5, "class", "shadow-sm  bg-white rounded");
    			add_location(div5, file$1o, 49, 4, 979);
    			attr_dev(div6, "class", "container mt-5");
    			add_location(div6, file$1o, 48, 1, 946);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div5);
    			append_dev(div5, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div5, t1);
    			append_dev(div5, div4);
    			append_dev(div4, div1);
    			append_dev(div1, h4);
    			append_dev(h4, t2);
    			append_dev(div1, t3);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div4, t4);
    			append_dev(div4, div2);
    			append_dev(div2, h5);
    			append_dev(h5, t5);
    			append_dev(div4, t6);
    			mount_component(solution, div4, null);
    			append_dev(div4, t7);
    			append_dev(div4, div3);
    			append_dev(div3, button0);
    			append_dev(div3, t9);
    			append_dev(div3, button1);
    			append_dev(div3, t11);
    			append_dev(div3, button2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[7]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*task01*/ 1) && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*task01*/ 1) && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (!current || dirty & /*showPopUp*/ 8) set_data_dev(t5, /*showPopUp*/ ctx[3]);

    			if (!current || dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}

    			const solution_changes = {};
    			if (dirty & /*task01*/ 1) solution_changes.num_qnty = /*task01*/ ctx[0].columns;
    			if (dirty & /*answer*/ 2) solution_changes.usr_resp = /*answer*/ ctx[1];
    			if (dirty & /*task01*/ 1) solution_changes.num = /*task01*/ ctx[0].valueArray;
    			if (dirty & /*showSolution*/ 16) solution_changes.ans_submit = /*showSolution*/ ctx[4];
    			solution.$set(solution_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div6);
    			destroy_component(solution);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1p($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GII_MA_E12", slots, []);
    	let task01 = taskOne$19();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			$$invalidate(2, showNext = "inline-block");
    			return;
    		} else {
    			$$invalidate(4, showSolution = true);
    			$$invalidate(3, showPopUp = randomWrong());
    			$$invalidate(2, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(4, showSolution = false);
    		$$invalidate(0, task01 = taskOne$19());
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GII_MA_E12> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$19,
    		randomCorrect,
    		randomWrong,
    		Solution: AdditionSolution,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) $$invalidate(4, showSolution = $$props.showSolution);
    		if ("CheckAnswer" in $$props) $$invalidate(5, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(6, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class GII_MA_E12 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1p, create_fragment$1p, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GII_MA_E12",
    			options,
    			id: create_fragment$1p.name
    		});
    	}
    }

    let task01$18 = {
      heading: "Balance addition equations - one digit",
      question:
        "Here are the ways to make 4. Find the pattern and type the missing addition number sentence.",
      questionValue: 0,
      valueArray: [],
      answer: 0,
      randomAnswer: 0,
      solutionArray: [],
      columns: 0,
    };

    const maxValue$V = 20;
    const minValue$V = 1;
    const findInMaxNumber$k = 10;


    function taskOne$18() {
      task01$18.questionValue =
        Math.floor(Math.random() * (maxValue$V - minValue$V + 1)) + minValue$V;
      task01$18.question = "How do you make " + task01$18.questionValue + " ?";
      task01$18.valueArray = [];
      task01$18.solutionArray = [];
      task01$18.columns = 2;
      let ans = [];
      for (let i = 0; i < findInMaxNumber$k; i++) {
        for (let j = 0; j < findInMaxNumber$k; j++) {
          let a = i + "+" + j;
          if (task01$18.questionValue == i + j) {
            ans.push(a);
          }
        }
      }

      let temparray = randomArrayNumbers(2, ans.length, 0, ans);
      for (let i = 0; i < temparray.length; i++) {
        task01$18.valueArray[i] = temparray[i].split("+").map(function (item) {
          return parseInt(item, 10);
        });
      }
      let RandomValue = Math.floor(Math.random() *  task01$18.valueArray.length);
      let randomINput = Math.floor(Math.random() *  task01$18.valueArray[RandomValue].length);
      task01$18.solutionArray = [...task01$18.valueArray[RandomValue]];
      task01$18.answer = task01$18.valueArray[RandomValue][randomINput];
     
      console.log(task01$18.answer);
      task01$18.valueArray[RandomValue][randomINput] = 'i';
      return task01$18;
    }

    /* src/components/taskComponents/GII_MA_E13.svelte generated by Svelte v3.37.0 */
    const file$1n = "src/components/taskComponents/GII_MA_E13.svelte";

    function get_each_context$19(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	child_ctx[13] = i;
    	return child_ctx;
    }

    function get_each_context_1$e(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[14] = list[i];
    	child_ctx[13] = i;
    	return child_ctx;
    }

    // (74:36) {:else}
    function create_else_block$X(ctx) {
    	let t_value = /*a*/ ctx[14] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*a*/ ctx[14] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$X.name,
    		type: "else",
    		source: "(74:36) {:else}",
    		ctx
    	});

    	return block;
    }

    // (72:34) {#if a == 'i'}
    function create_if_block_2$a(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "style", " width : 30px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$1n, 72, 34, 1812);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*answer*/ ctx[1]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[7]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$a.name,
    		type: "if",
    		source: "(72:34) {#if a == 'i'}",
    		ctx
    	});

    	return block;
    }

    // (77:34) {#if i < col.length-1}
    function create_if_block_1$a(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("+");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$a.name,
    		type: "if",
    		source: "(77:34) {#if i < col.length-1}",
    		ctx
    	});

    	return block;
    }

    // (71:32) {#each col as a, i}
    function create_each_block_1$e(ctx) {
    	let t;
    	let if_block1_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*a*/ ctx[14] == "i") return create_if_block_2$a;
    		return create_else_block$X;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);
    	let if_block1 = /*i*/ ctx[13] < /*col*/ ctx[11].length - 1 && create_if_block_1$a(ctx);

    	const block = {
    		c: function create() {
    			if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(t.parentNode, t);
    				}
    			}

    			if (/*i*/ ctx[13] < /*col*/ ctx[11].length - 1) {
    				if (if_block1) ; else {
    					if_block1 = create_if_block_1$a(ctx);
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$e.name,
    		type: "each",
    		source: "(71:32) {#each col as a, i}",
    		ctx
    	});

    	return block;
    }

    // (81:32) {#if i < task01.valueArray.length-1}
    function create_if_block$Z(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("=");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$Z.name,
    		type: "if",
    		source: "(81:32) {#if i < task01.valueArray.length-1}",
    		ctx
    	});

    	return block;
    }

    // (69:20) {#each task01.valueArray as col, i }
    function create_each_block$19(ctx) {
    	let t;
    	let if_block_anchor;
    	let each_value_1 = /*col*/ ctx[11];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$e(get_each_context_1$e(ctx, each_value_1, i));
    	}

    	let if_block = /*i*/ ctx[13] < /*task01*/ ctx[0].valueArray.length - 1 && create_if_block$Z(ctx);

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01, answer*/ 3) {
    				each_value_1 = /*col*/ ctx[11];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$e(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$e(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(t.parentNode, t);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}

    			if (/*i*/ ctx[13] < /*task01*/ ctx[0].valueArray.length - 1) {
    				if (if_block) ; else {
    					if_block = create_if_block$Z(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$19.name,
    		type: "each",
    		source: "(69:20) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1o(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let tr;
    	let td;
    	let span;
    	let t4;
    	let h6;
    	let t5;
    	let t6_value = /*task01*/ ctx[0].answer + "";
    	let t6;
    	let t7;
    	let div3;
    	let h5;
    	let t8;
    	let t9;
    	let solution;
    	let t10;
    	let div4;
    	let button0;
    	let t12;
    	let button1;
    	let t14;
    	let button2;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$19(get_each_context$19(ctx, each_value, i));
    	}

    	solution = new AdditionSolution({
    			props: {
    				num_qnty: /*task01*/ ctx[0].columns,
    				usr_resp: /*answer*/ ctx[1],
    				num: /*task01*/ ctx[0].solutionArray,
    				ans_submit: /*showSolution*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");
    			tr = element("tr");
    			td = element("td");
    			span = element("span");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			h6 = element("h6");
    			t5 = text("answer ");
    			t6 = text(t6_value);
    			t7 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t8 = text(/*showPopUp*/ ctx[3]);
    			t9 = space();
    			create_component(solution.$$.fragment);
    			t10 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t12 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t14 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$1n, 53, 8, 1228);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1n, 52, 4, 1180);
    			add_location(h4, file$1n, 60, 10, 1396);
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$1n, 66, 36, 1539);
    			attr_dev(td, "align", "right");
    			add_location(td, file$1n, 66, 18, 1521);
    			add_location(tr, file$1n, 65, 16, 1498);
    			attr_dev(table, "width", "150");
    			add_location(table, file$1n, 64, 14, 1462);
    			add_location(h6, file$1n, 89, 18, 2634);
    			add_location(div1, file$1n, 62, 10, 1437);
    			add_location(div2, file$1n, 57, 6, 1377);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1n, 94, 10, 2732);
    			add_location(div3, file$1n, 93, 6, 2716);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1n, 98, 10, 2971);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1n, 99, 10, 3065);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1n, 100, 10, 3159);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$1n, 97, 6, 2942);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$1n, 56, 4, 1307);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$1n, 51, 3, 1134);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$1n, 50, 0, 1102);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);
    			append_dev(table, tr);
    			append_dev(tr, td);
    			append_dev(td, span);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(span, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, h6);
    			append_dev(h6, t5);
    			append_dev(h6, t6);
    			append_dev(div5, t7);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t8);
    			append_dev(div5, t9);
    			mount_component(solution, div5, null);
    			append_dev(div5, t10);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t12);
    			append_dev(div4, button1);
    			append_dev(div4, t14);
    			append_dev(div4, button2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*task01*/ 1) && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*task01*/ 1) && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01, answer*/ 3) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$19(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$19(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(span, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if ((!current || dirty & /*task01*/ 1) && t6_value !== (t6_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t6, t6_value);
    			if (!current || dirty & /*showPopUp*/ 8) set_data_dev(t8, /*showPopUp*/ ctx[3]);

    			if (!current || dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}

    			const solution_changes = {};
    			if (dirty & /*task01*/ 1) solution_changes.num_qnty = /*task01*/ ctx[0].columns;
    			if (dirty & /*answer*/ 2) solution_changes.usr_resp = /*answer*/ ctx[1];
    			if (dirty & /*task01*/ 1) solution_changes.num = /*task01*/ ctx[0].solutionArray;
    			if (dirty & /*showSolution*/ 16) solution_changes.ans_submit = /*showSolution*/ ctx[4];
    			solution.$set(solution_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			destroy_component(solution);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const max$l = 10;
    const min$l = 0;
    const numberofColumn$l = 2;

    function instance$1o($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GII_MA_E13", slots, []);
    	let heading = "Addition facts - sums up to 10";
    	let question = "Add :";
    	let maxandmin = MaxandMin$5(max$l, min$l, numberofColumn$l, heading, question);
    	let task01 = taskOne$18();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			$$invalidate(4, showSolution = true);
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$18());
    		$$invalidate(4, showSolution = false);
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GII_MA_E13> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$18,
    		randomCorrect,
    		randomWrong,
    		MaxandMin: MaxandMin$5,
    		Solution: AdditionSolution,
    		heading,
    		question,
    		max: max$l,
    		min: min$l,
    		numberofColumn: numberofColumn$l,
    		maxandmin,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("heading" in $$props) heading = $$props.heading;
    		if ("question" in $$props) question = $$props.question;
    		if ("maxandmin" in $$props) maxandmin = $$props.maxandmin;
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) $$invalidate(4, showSolution = $$props.showSolution);
    		if ("CheckAnswer" in $$props) $$invalidate(5, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(6, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class GII_MA_E13 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1o, create_fragment$1o, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GII_MA_E13",
    			options,
    			id: create_fragment$1o.name
    		});
    	}
    }

    /* src/components/taskComponents/GII_MA_E14.svelte generated by Svelte v3.37.0 */
    const file$1m = "src/components/taskComponents/GII_MA_E14.svelte";

    function get_each_context$18(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	child_ctx[13] = i;
    	return child_ctx;
    }

    // (72:28) {:else}
    function create_else_block$W(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[11] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$1m, 73, 32, 2051);
    			add_location(tr, file$1m, 72, 28, 2014);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[11] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$W.name,
    		type: "else",
    		source: "(72:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (68:28) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$Y(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[11] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$1m, 69, 50, 1847);
    			attr_dev(td, "align", "right");
    			add_location(td, file$1m, 69, 32, 1829);
    			add_location(tr, file$1m, 68, 28, 1792);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[11] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$Y.name,
    		type: "if",
    		source: "(68:28) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (67:24) {#each task01.valueArray as col, i }
    function create_each_block$18(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[13] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$Y;
    		return create_else_block$W;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$18.name,
    		type: "each",
    		source: "(67:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1n(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let solution;
    	let t12;
    	let div4;
    	let button0;
    	let t14;
    	let button1;
    	let t16;
    	let button2;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$18(get_each_context$18(ctx, each_value, i));
    	}

    	solution = new AdditionSolution({
    			props: {
    				num_qnty: /*task01*/ ctx[0].columns,
    				usr_resp: /*answer*/ ctx[1],
    				num: /*task01*/ ctx[0].valueArray,
    				ans_submit: /*showSolution*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			create_component(solution.$$.fragment);
    			t12 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t14 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t16 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$1m, 53, 10, 1317);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1m, 52, 6, 1267);
    			add_location(h4, file$1m, 60, 12, 1495);
    			attr_dev(table, "width", "100");
    			add_location(table, file$1m, 64, 16, 1567);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$1m, 78, 20, 2244);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$1m, 79, 20, 2339);
    			add_location(h6, file$1m, 80, 20, 2461);
    			add_location(div1, file$1m, 62, 12, 1540);
    			add_location(div2, file$1m, 57, 8, 1474);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1m, 85, 12, 2569);
    			add_location(div3, file$1m, 84, 8, 2551);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1m, 89, 12, 2813);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1m, 90, 12, 2909);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1m, 91, 12, 3005);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$1m, 88, 8, 2782);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$1m, 56, 6, 1402);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$1m, 51, 5, 1219);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$1m, 50, 1, 1185);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			mount_component(solution, div5, null);
    			append_dev(div5, t12);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t14);
    			append_dev(div4, button1);
    			append_dev(div4, t16);
    			append_dev(div4, button2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[7]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*task01*/ 1) && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*task01*/ 1) && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$18(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$18(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if ((!current || dirty & /*task01*/ 1) && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (!current || dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (!current || dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}

    			const solution_changes = {};
    			if (dirty & /*task01*/ 1) solution_changes.num_qnty = /*task01*/ ctx[0].columns;
    			if (dirty & /*answer*/ 2) solution_changes.usr_resp = /*answer*/ ctx[1];
    			if (dirty & /*task01*/ 1) solution_changes.num = /*task01*/ ctx[0].valueArray;
    			if (dirty & /*showSolution*/ 16) solution_changes.ans_submit = /*showSolution*/ ctx[4];
    			solution.$set(solution_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			destroy_component(solution);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const max$k = 10;
    const min$k = 0;
    const numberofColumn$k = 3;

    function instance$1n($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GII_MA_E14", slots, []);
    	let heading = "Add three or more one-digit numbers";
    	let question = "Add :";
    	let maxandmin = MaxandMin$5(max$k, min$k, numberofColumn$k, heading, question);
    	let task01 = taskOne$1C();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			$$invalidate(4, showSolution = true);
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$1C());
    		$$invalidate(4, showSolution = false);
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GII_MA_E14> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1C,
    		randomCorrect,
    		randomWrong,
    		MaxandMin: MaxandMin$5,
    		Solution: AdditionSolution,
    		heading,
    		question,
    		max: max$k,
    		min: min$k,
    		numberofColumn: numberofColumn$k,
    		maxandmin,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("heading" in $$props) heading = $$props.heading;
    		if ("question" in $$props) question = $$props.question;
    		if ("maxandmin" in $$props) maxandmin = $$props.maxandmin;
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) $$invalidate(4, showSolution = $$props.showSolution);
    		if ("CheckAnswer" in $$props) $$invalidate(5, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(6, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class GII_MA_E14 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1n, create_fragment$1n, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GII_MA_E14",
    			options,
    			id: create_fragment$1n.name
    		});
    	}
    }

    let task01$17 = {
      heading : "",
      question: "",
      valueArray: [], 
      answer: 0, 
      operator: "+",
      columns: 0
    };

    let columns$a = 3;
    let maxValue$U = 9;
    let minValue$U = 1;


    function taskOne$17() {
      task01$17.heading = "Add three or more one-digit numbers - word problems";
      task01$17.answer = 0;
      task01$17.columns = columns$a;
      task01$17.valueArray = [];
          for (let i = 0; i < columns$a; i++) {
            task01$17.valueArray[i] = Math.floor(Math.random() * (maxValue$U - minValue$U + 1) ) + minValue$U; 
            task01$17.answer += task01$17.valueArray[i];        
          }
            while(task01$17.answer > maxValue$U){
                task01$17.answer = 0;
            for (let i = 0; i < columns$a; i++) {
                task01$17.valueArray[i] = Math.floor(Math.random() * (maxValue$U - minValue$U + 1) ) + minValue$U; 
                task01$17.answer += task01$17.valueArray[i];        
            }
            }
      task01$17.question = "In the equipment locker for gym class there are "+task01$17.valueArray[0]+" basketballs, "+task01$17.valueArray[1]+" soccer balls, and "+task01$17.valueArray[2]+" volleyballs. How many balls are in the equipment locker?";
      return task01$17;
    }

    /* src/components/taskComponents/GII_MA_E15.svelte generated by Svelte v3.37.0 */
    const file$1l = "src/components/taskComponents/GII_MA_E15.svelte";

    function create_fragment$1m(ctx) {
    	let div6;
    	let div5;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div4;
    	let div1;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let input;
    	let t4;
    	let div2;
    	let h5;
    	let t5;
    	let t6;
    	let solution;
    	let t7;
    	let div3;
    	let button0;
    	let t9;
    	let button1;
    	let t11;
    	let button2;
    	let current;
    	let mounted;
    	let dispose;

    	solution = new AdditionSolution({
    			props: {
    				num_qnty: /*task01*/ ctx[0].columns,
    				usr_resp: /*answer*/ ctx[1],
    				num: /*task01*/ ctx[0].valueArray,
    				ans_submit: /*showSolution*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div6 = element("div");
    			div5 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div4 = element("div");
    			div1 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			input = element("input");
    			t4 = space();
    			div2 = element("div");
    			h5 = element("h5");
    			t5 = text(/*showPopUp*/ ctx[3]);
    			t6 = space();
    			create_component(solution.$$.fragment);
    			t7 = space();
    			div3 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t9 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t11 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$1l, 51, 9, 1075);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1l, 50, 5, 1026);
    			add_location(h4, file$1l, 57, 11, 1247);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$1l, 58, 11, 1285);
    			add_location(div1, file$1l, 55, 7, 1228);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1l, 62, 11, 1427);
    			add_location(div2, file$1l, 61, 7, 1410);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1l, 66, 11, 1667);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1l, 67, 11, 1762);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1l, 68, 11, 1857);
    			attr_dev(div3, "class", "mt-3");
    			add_location(div3, file$1l, 65, 7, 1637);
    			attr_dev(div4, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div4, file$1l, 54, 5, 1157);
    			attr_dev(div5, "class", "shadow-sm  bg-white rounded");
    			add_location(div5, file$1l, 49, 4, 979);
    			attr_dev(div6, "class", "container mt-5");
    			add_location(div6, file$1l, 48, 1, 946);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div5);
    			append_dev(div5, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div5, t1);
    			append_dev(div5, div4);
    			append_dev(div4, div1);
    			append_dev(div1, h4);
    			append_dev(h4, t2);
    			append_dev(div1, t3);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div4, t4);
    			append_dev(div4, div2);
    			append_dev(div2, h5);
    			append_dev(h5, t5);
    			append_dev(div4, t6);
    			mount_component(solution, div4, null);
    			append_dev(div4, t7);
    			append_dev(div4, div3);
    			append_dev(div3, button0);
    			append_dev(div3, t9);
    			append_dev(div3, button1);
    			append_dev(div3, t11);
    			append_dev(div3, button2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[7]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*task01*/ 1) && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*task01*/ 1) && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (!current || dirty & /*showPopUp*/ 8) set_data_dev(t5, /*showPopUp*/ ctx[3]);

    			if (!current || dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}

    			const solution_changes = {};
    			if (dirty & /*task01*/ 1) solution_changes.num_qnty = /*task01*/ ctx[0].columns;
    			if (dirty & /*answer*/ 2) solution_changes.usr_resp = /*answer*/ ctx[1];
    			if (dirty & /*task01*/ 1) solution_changes.num = /*task01*/ ctx[0].valueArray;
    			if (dirty & /*showSolution*/ 16) solution_changes.ans_submit = /*showSolution*/ ctx[4];
    			solution.$set(solution_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div6);
    			destroy_component(solution);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1m($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GII_MA_E15", slots, []);
    	let task01 = taskOne$17();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			$$invalidate(2, showNext = "inline-block");
    			return;
    		} else {
    			$$invalidate(4, showSolution = true);
    			$$invalidate(3, showPopUp = randomWrong());
    			$$invalidate(2, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(4, showSolution = false);
    		$$invalidate(0, task01 = taskOne$17());
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GII_MA_E15> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$17,
    		randomCorrect,
    		randomWrong,
    		Solution: AdditionSolution,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) $$invalidate(4, showSolution = $$props.showSolution);
    		if ("CheckAnswer" in $$props) $$invalidate(5, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(6, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class GII_MA_E15 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1m, create_fragment$1m, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GII_MA_E15",
    			options,
    			id: create_fragment$1m.name
    		});
    	}
    }

    let task01$16 = {    
        question: "Which addition statement describes the array?",
        displayArray: [4,6,8,9,10],
        displayValue:[],
        answer: 0,
        randomQust: 0
      };
      





      function taskOne$16() {

        
        task01$16.randomQust = task01$16.displayArray[Math.floor(Math.random() * task01$16.displayArray.length)];
        task01$16.displayValue = [];
        if(task01$16.randomQust == 6 || task01$16.randomQust == 9){
            for (let index = 0; index < (task01$16.randomQust/3); index++) {
                task01$16.displayValue[index] = 3;            
            }
        }else {
            for (let index = 0; index < (task01$16.randomQust/2); index++) {
                task01$16.displayValue[index] = 2;            
            }
        }
        

          return task01$16;
      }

    /* src/components/taskComponents/GII_MA_E16.svelte generated by Svelte v3.37.0 */
    const file$1k = "src/components/taskComponents/GII_MA_E16.svelte";

    function get_each_context$17(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	child_ctx[9] = i;
    	return child_ctx;
    }

    function get_each_context_1$d(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    // (66:24) {#each Array(value) as i}
    function create_each_block_1$d(ctx) {
    	let svg;
    	let rect;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			rect = svg_element("rect");
    			attr_dev(rect, "x", "3");
    			attr_dev(rect, "y", "3");
    			attr_dev(rect, "width", "50");
    			attr_dev(rect, "height", "50");
    			set_style(rect, "fill", "blue");
    			set_style(rect, "stroke", "pink");
    			set_style(rect, "stroke-width", "5");
    			set_style(rect, "fill-opacity", "0.1");
    			set_style(rect, "stroke-opacity", "0.9");
    			add_location(rect, file$1k, 67, 28, 1474);
    			attr_dev(svg, "width", "60");
    			attr_dev(svg, "height", "60");
    			add_location(svg, file$1k, 66, 24, 1417);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, rect);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$d.name,
    		type: "each",
    		source: "(66:24) {#each Array(value) as i}",
    		ctx
    	});

    	return block;
    }

    // (65:20) {#each task01.displayValue as value,i}
    function create_each_block$17(ctx) {
    	let t;
    	let hr;
    	let each_value_1 = Array(/*value*/ ctx[7]);
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$d(get_each_context_1$d(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			hr = element("hr");
    			add_location(hr, file$1k, 70, 27, 1715);
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, t, anchor);
    			insert_dev(target, hr, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1) {
    				const old_length = each_value_1.length;
    				each_value_1 = Array(/*value*/ ctx[7]);
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = old_length; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$d(ctx, each_value_1, i);

    					if (!each_blocks[i]) {
    						each_blocks[i] = create_each_block_1$d(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(t.parentNode, t);
    					}
    				}

    				for (i = each_value_1.length; i < old_length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(hr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$17.name,
    		type: "each",
    		source: "(65:20) {#each task01.displayValue as value,i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1l(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t1;
    	let div5;
    	let div2;
    	let div1;
    	let h4;
    	let t2;
    	let h6;
    	let t3;
    	let t4_value = /*task01*/ ctx[0].answer + "";
    	let t4;
    	let t5;
    	let div3;
    	let h5;
    	let t6;
    	let t7;
    	let div4;
    	let button0;
    	let t9;
    	let button1;
    	let t11;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].displayValue;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$17(get_each_context$17(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			h2.textContent = "Identify repeated addition in arrays: sums to 10";
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			h4 = element("h4");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t2 = space();
    			h6 = element("h6");
    			t3 = text("answer ");
    			t4 = text(t4_value);
    			t5 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t6 = text(/*showPopUp*/ ctx[2]);
    			t7 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t9 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t11 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$1k, 55, 10, 1027);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1k, 54, 6, 977);
    			add_location(h4, file$1k, 63, 16, 1278);
    			add_location(h6, file$1k, 76, 16, 1810);
    			add_location(div1, file$1k, 61, 12, 1236);
    			add_location(div2, file$1k, 59, 8, 1216);
    			set_style(h5, "display", /*showNext*/ ctx[1]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1k, 81, 12, 1918);
    			add_location(div3, file$1k, 80, 8, 1900);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1k, 85, 12, 2049);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1k, 86, 12, 2145);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1k, 87, 12, 2241);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$1k, 84, 8, 2018);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$1k, 58, 6, 1144);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$1k, 53, 5, 929);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$1k, 52, 1, 895);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, div1);
    			append_dev(div1, h4);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(h4, null);
    			}

    			append_dev(div1, t2);
    			append_dev(div1, h6);
    			append_dev(h6, t3);
    			append_dev(h6, t4);
    			append_dev(div5, t5);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t6);
    			append_dev(div5, t7);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t9);
    			append_dev(div4, button1);
    			append_dev(div4, t11);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[3], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[4], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*Array, task01*/ 1) {
    				each_value = /*task01*/ ctx[0].displayValue;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$17(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$17(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(h4, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*task01*/ 1 && t4_value !== (t4_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*showPopUp*/ 4) set_data_dev(t6, /*showPopUp*/ ctx[2]);

    			if (dirty & /*showNext*/ 2) {
    				set_style(h5, "display", /*showNext*/ ctx[1]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1l($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GII_MA_E16", slots, []);
    	let task01 = taskOne$16();
    	let answer;
    	let showNext = "none";
    	let showPopUp;

    	let CheckAnswer = function () {
    		if (answer == task01.answer) {
    			$$invalidate(2, showPopUp = randomCorrect());
    			$$invalidate(1, showNext = "inline-block");
    			return;
    		} else {
    			$$invalidate(2, showPopUp = randomWrong());
    			$$invalidate(1, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		answer = null;
    		$$invalidate(0, task01 = taskOne$16());
    		$$invalidate(1, showNext = "none");
    	};

    	const handleClick = parameter => () => {
    		answer = parameter;
    		CheckAnswer();
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GII_MA_E16> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$16,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		handleClick
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) answer = $$props.answer;
    		if ("showNext" in $$props) $$invalidate(1, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(2, showPopUp = $$props.showPopUp);
    		if ("CheckAnswer" in $$props) $$invalidate(3, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(4, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [task01, showNext, showPopUp, CheckAnswer, NextQuestion];
    }

    class GII_MA_E16 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1l, create_fragment$1l, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GII_MA_E16",
    			options,
    			id: create_fragment$1l.name
    		});
    	}
    }

    /* src/components/taskComponents/GI_MA_E4.svelte generated by Svelte v3.37.0 */
    const file$1j = "src/components/taskComponents/GI_MA_E4.svelte";

    function get_each_context$16(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	child_ctx[15] = i;
    	return child_ctx;
    }

    function get_each_context_2$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	child_ctx[19] = list;
    	child_ctx[20] = i;
    	return child_ctx;
    }

    function get_each_context_1$c(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	child_ctx[17] = list;
    	child_ctx[18] = i;
    	return child_ctx;
    }

    // (87:27) {:else}
    function create_else_block_1$4(ctx) {
    	let tr;
    	let t;
    	let each_value_2 = /*value*/ ctx[13];
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$5(get_each_context_2$5(ctx, each_value_2, i));
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			attr_dev(tr, "class", "tablerow");
    			add_location(tr, file$1j, 87, 27, 2603);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			append_dev(tr, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*answer, task01*/ 3) {
    				each_value_2 = /*value*/ ctx[13];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$5(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_2$5(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, t);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_2.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$4.name,
    		type: "else",
    		source: "(87:27) {:else}",
    		ctx
    	});

    	return block;
    }

    // (75:23) {#if i == (task01.displayValues.length-1)}
    function create_if_block$X(ctx) {
    	let hr;
    	let t0;
    	let tr;
    	let t1;
    	let each_value_1 = /*value*/ ctx[13];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$c(get_each_context_1$c(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			hr = element("hr");
    			t0 = space();
    			tr = element("tr");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			add_location(hr, file$1j, 75, 23, 2022);
    			attr_dev(tr, "class", "tablerow");
    			add_location(tr, file$1j, 76, 23, 2050);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, hr, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, tr, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*answer, task01*/ 3) {
    				each_value_1 = /*value*/ ctx[13];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$c(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$c(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, t1);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(hr);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(tr);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$X.name,
    		type: "if",
    		source: "(75:23) {#if i == (task01.displayValues.length-1)}",
    		ctx
    	});

    	return block;
    }

    // (93:28) {:else}
    function create_else_block_2$4(ctx) {
    	let td;
    	let t_value = /*val*/ ctx[16] + "";
    	let t;

    	const block = {
    		c: function create() {
    			td = element("td");
    			t = text(t_value);
    			attr_dev(td, "align", "right");
    			add_location(td, file$1j, 93, 32, 2950);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*val*/ ctx[16] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$4.name,
    		type: "else",
    		source: "(93:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (91:28) {#if val[0] == 'i'}
    function create_if_block_2$9(ctx) {
    	let td;
    	let input;
    	let mounted;
    	let dispose;

    	function input_input_handler_1() {
    		/*input_input_handler_1*/ ctx[7].call(input, /*val*/ ctx[16]);
    	}

    	const block = {
    		c: function create() {
    			td = element("td");
    			input = element("input");
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "style", " width : 30px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$1j, 91, 46, 2769);
    			attr_dev(td, "align", "right");
    			add_location(td, file$1j, 91, 28, 2751);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, input);
    			set_input_value(input, /*answer*/ ctx[1][/*val*/ ctx[16][1]]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler_1);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*answer, task01*/ 3 && input.value !== /*answer*/ ctx[1][/*val*/ ctx[16][1]]) {
    				set_input_value(input, /*answer*/ ctx[1][/*val*/ ctx[16][1]]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$9.name,
    		type: "if",
    		source: "(91:28) {#if val[0] == 'i'}",
    		ctx
    	});

    	return block;
    }

    // (89:28) {#each value as val}
    function create_each_block_2$5(ctx) {
    	let if_block_anchor;

    	function select_block_type_2(ctx, dirty) {
    		if (/*val*/ ctx[16][0] == "i") return create_if_block_2$9;
    		return create_else_block_2$4;
    	}

    	let current_block_type = select_block_type_2(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$5.name,
    		type: "each",
    		source: "(89:28) {#each value as val}",
    		ctx
    	});

    	return block;
    }

    // (82:24) {:else}
    function create_else_block$V(ctx) {
    	let td;
    	let t_value = /*val*/ ctx[16] + "";
    	let t;

    	const block = {
    		c: function create() {
    			td = element("td");
    			t = text(t_value);
    			attr_dev(td, "align", "right");
    			add_location(td, file$1j, 82, 28, 2400);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*val*/ ctx[16] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$V.name,
    		type: "else",
    		source: "(82:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (80:24) {#if val[0] == 'i'}
    function create_if_block_1$9(ctx) {
    	let td;
    	let input;
    	let mounted;
    	let dispose;

    	function input_input_handler() {
    		/*input_input_handler*/ ctx[6].call(input, /*val*/ ctx[16]);
    	}

    	const block = {
    		c: function create() {
    			td = element("td");
    			input = element("input");
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "style", " width : 30px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$1j, 80, 42, 2227);
    			attr_dev(td, "align", "right");
    			add_location(td, file$1j, 80, 24, 2209);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, input);
    			set_input_value(input, /*answer*/ ctx[1][/*val*/ ctx[16][1]]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*answer, task01*/ 3 && input.value !== /*answer*/ ctx[1][/*val*/ ctx[16][1]]) {
    				set_input_value(input, /*answer*/ ctx[1][/*val*/ ctx[16][1]]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$9.name,
    		type: "if",
    		source: "(80:24) {#if val[0] == 'i'}",
    		ctx
    	});

    	return block;
    }

    // (78:24) {#each value as val}
    function create_each_block_1$c(ctx) {
    	let if_block_anchor;

    	function select_block_type_1(ctx, dirty) {
    		if (/*val*/ ctx[16][0] == "i") return create_if_block_1$9;
    		return create_else_block$V;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$c.name,
    		type: "each",
    		source: "(78:24) {#each value as val}",
    		ctx
    	});

    	return block;
    }

    // (73:20) {#each task01.displayValues as value , i}
    function create_each_block$16(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[15] == /*task01*/ ctx[0].displayValues.length - 1) return create_if_block$X;
    		return create_else_block_1$4;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$16.name,
    		type: "each",
    		source: "(73:20) {#each task01.displayValues as value , i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1k(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h20;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h21;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let div3;
    	let h5;
    	let t5;
    	let t6;
    	let div4;
    	let button0;
    	let t8;
    	let button1;
    	let t10;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].displayValues;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$16(get_each_context$16(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h20 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h21 = element("h2");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t5 = text(/*showPopUp*/ ctx[3]);
    			t6 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t8 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t10 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h20, "class", "text-center display-4 mb-0");
    			add_location(h20, file$1j, 62, 10, 1512);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1j, 61, 6, 1462);
    			add_location(h21, file$1j, 67, 12, 1688);
    			attr_dev(table, "width", "100");
    			add_location(table, file$1j, 70, 16, 1768);
    			add_location(div1, file$1j, 68, 12, 1727);
    			add_location(div2, file$1j, 66, 8, 1669);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1j, 105, 12, 3280);
    			add_location(div3, file$1j, 104, 8, 3262);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1j, 111, 12, 3419);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1j, 112, 12, 3515);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1j, 113, 12, 3611);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$1j, 110, 8, 3388);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$1j, 65, 6, 1597);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$1j, 60, 5, 1414);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$1j, 59, 1, 1380);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h20);
    			append_dev(h20, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h21);
    			append_dev(h21, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div5, t4);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t5);
    			append_dev(div5, t6);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t8);
    			append_dev(div4, button1);
    			append_dev(div4, t10);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01, answer*/ 3) {
    				each_value = /*task01*/ ctx[0].displayValues;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$16(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$16(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*showPopUp*/ 8) set_data_dev(t5, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const max$j = 10;
    const min$j = 0;
    const maxInputs$5 = 1;
    const numberofColumn$j = 2;

    function instance$1k($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GI_MA_E4", slots, []);
    	let question = "Add :";
    	let heading = "Complete the addition sentence - sums up to 10";
    	let showSolution = false;
    	let maxandmin = MaxandMin$4(max$j, min$j, numberofColumn$j, heading, question, maxInputs$5);
    	let task01 = taskOne$1x();
    	let answer = [];
    	let showNext = "none";
    	let showPopUp;
    	let tempString = "";

    	let CheckAnswer = function () {
    		for (let index = 0; index < task01.answer.length; index++) {
    			if (answer[index] != task01.answer[index]) {
    				$$invalidate(3, showPopUp = randomWrong());
    				$$invalidate(2, showNext = "inline-block");
    				showSolution = true;
    				return;
    			} else {
    				$$invalidate(3, showPopUp = randomCorrect());
    				$$invalidate(2, showNext = "inline-block");
    			}
    		}
    	};

    	let NextQuestion = function () {
    		showSolution = false;
    		$$invalidate(1, answer = []);
    		$$invalidate(0, task01 = taskOne$1x());
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GI_MA_E4> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler(val) {
    		answer[val[1]] = this.value;
    		$$invalidate(1, answer);
    		$$invalidate(0, task01);
    	}

    	function input_input_handler_1(val) {
    		answer[val[1]] = this.value;
    		$$invalidate(1, answer);
    		$$invalidate(0, task01);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1x,
    		randomCorrect,
    		randomWrong,
    		MaxandMin: MaxandMin$4,
    		question,
    		heading,
    		max: max$j,
    		min: min$j,
    		maxInputs: maxInputs$5,
    		numberofColumn: numberofColumn$j,
    		showSolution,
    		maxandmin,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		tempString,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("question" in $$props) question = $$props.question;
    		if ("heading" in $$props) heading = $$props.heading;
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("maxandmin" in $$props) maxandmin = $$props.maxandmin;
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("tempString" in $$props) tempString = $$props.tempString;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler,
    		input_input_handler_1
    	];
    }

    class GI_MA_E4 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1k, create_fragment$1k, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GI_MA_E4",
    			options,
    			id: create_fragment$1k.name
    		});
    	}
    }

    let task01$15 = {
      heading: "Make a number using addition - sums up to 10",
      question: "John is building a cabinet. He needs 2 one-inch bolts and 3 one-and-a-half inch bolts. How many bolts in all does John need?",
      questionValue : 0,
      valueArray: [],
      answer: 0,
      randomAnswer: 0,
      displayBtn : [],
      columns: 0
    };

    const maxValue$T = 10;
    const minValue$T = 1;
    const findInMaxNumber$j = 10;
    const showbtn$6 = 4;

    function taskOne$15() {
      task01$15.answer = Math.floor(Math.random() * (maxValue$T - minValue$T + 1)) + minValue$T;
      task01$15.valueArray = [];
      task01$15.columns = 2;
      let ans = [];
      for (let i = 0; i < findInMaxNumber$j; i++) {
        for (let j = 0; j < findInMaxNumber$j; j++) {
          let a = i+"+"+j;
          if (task01$15.answer == (i + j)) {          
              ans.push(a);
          }
        }    
      }  

      task01$15.valueArray = ans[Math.floor(Math.random() * ans.length)].split('+');
      task01$15.question = "John is building a cabinet. He needs "+task01$15.valueArray[0]+" one-inch bolts and "+task01$15.valueArray[1]+" one-and-a-half inch bolts. How many bolts in all does John need?";
      task01$15.displayBtn = randomNumbers$3(showbtn$6,maxValue$T,minValue$T);
      if(!task01$15.displayBtn.includes(task01$15.answer)){      
        let tempnum = Math.floor(Math.random() * task01$15.displayBtn.length);
        task01$15.displayBtn[tempnum] = task01$15.answer;
      }
      return task01$15;
    }

    /* src/components/taskComponents/GI_MA_E5.svelte generated by Svelte v3.37.0 */
    const file$1i = "src/components/taskComponents/GI_MA_E5.svelte";

    function get_each_context$15(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	return child_ctx;
    }

    // (56:20) {#each task01.displayBtn as value}
    function create_each_block$15(ctx) {
    	let button;
    	let t_value = /*value*/ ctx[8] + "";
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "class", "btn toggle-btn ");
    			add_location(button, file$1i, 56, 20, 1483);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(
    					button,
    					"click",
    					function () {
    						if (is_function(/*handleClick*/ ctx[7](/*value*/ ctx[8]))) /*handleClick*/ ctx[7](/*value*/ ctx[8]).apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*value*/ ctx[8] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$15.name,
    		type: "each",
    		source: "(56:20) {#each task01.displayBtn as value}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1j(ctx) {
    	let div8;
    	let div7;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div6;
    	let div3;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div2;
    	let div1;
    	let t4;
    	let h6;
    	let t5;
    	let t6_value = /*task01*/ ctx[0].answer + "";
    	let t6;
    	let t7;
    	let div4;
    	let h5;
    	let t8;
    	let t9;
    	let solution;
    	let t10;
    	let div5;
    	let button0;
    	let t12;
    	let button1;
    	let t14;
    	let button2;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].displayBtn;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$15(get_each_context$15(ctx, each_value, i));
    	}

    	solution = new AdditionSolution({
    			props: {
    				num_qnty: /*task01*/ ctx[0].columns,
    				usr_resp: /*answer*/ ctx[1],
    				num: /*task01*/ ctx[0].valueArray,
    				ans_submit: /*showSolution*/ ctx[4],
    				answerchange: /*task01*/ ctx[0].answer
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div8 = element("div");
    			div7 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div6 = element("div");
    			div3 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div2 = element("div");
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			h6 = element("h6");
    			t5 = text("answer ");
    			t6 = text(t6_value);
    			t7 = space();
    			div4 = element("div");
    			h5 = element("h5");
    			t8 = text(/*showPopUp*/ ctx[3]);
    			t9 = space();
    			create_component(solution.$$.fragment);
    			t10 = space();
    			div5 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t12 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t14 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$1i, 47, 10, 1162);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1i, 46, 6, 1112);
    			add_location(h4, file$1i, 52, 12, 1338);
    			add_location(div1, file$1i, 54, 16, 1401);
    			add_location(h6, file$1i, 61, 16, 1690);
    			add_location(div2, file$1i, 53, 12, 1377);
    			add_location(div3, file$1i, 51, 8, 1319);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1i, 67, 12, 1807);
    			add_location(div4, file$1i, 66, 8, 1789);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1i, 72, 12, 2082);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1i, 73, 12, 2178);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1i, 74, 12, 2274);
    			attr_dev(div5, "class", "mt-3");
    			add_location(div5, file$1i, 71, 8, 2051);
    			attr_dev(div6, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div6, file$1i, 50, 6, 1247);
    			attr_dev(div7, "class", "shadow-sm  bg-white rounded");
    			add_location(div7, file$1i, 45, 5, 1064);
    			attr_dev(div8, "class", "container mt-5");
    			add_location(div8, file$1i, 44, 1, 1030);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div8, anchor);
    			append_dev(div8, div7);
    			append_dev(div7, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div7, t1);
    			append_dev(div7, div6);
    			append_dev(div6, div3);
    			append_dev(div3, h4);
    			append_dev(h4, t2);
    			append_dev(div3, t3);
    			append_dev(div3, div2);
    			append_dev(div2, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			append_dev(div2, t4);
    			append_dev(div2, h6);
    			append_dev(h6, t5);
    			append_dev(h6, t6);
    			append_dev(div6, t7);
    			append_dev(div6, div4);
    			append_dev(div4, h5);
    			append_dev(h5, t8);
    			append_dev(div6, t9);
    			mount_component(solution, div6, null);
    			append_dev(div6, t10);
    			append_dev(div6, div5);
    			append_dev(div5, button0);
    			append_dev(div5, t12);
    			append_dev(div5, button1);
    			append_dev(div5, t14);
    			append_dev(div5, button2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*task01*/ 1) && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*task01*/ 1) && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*handleClick, task01*/ 129) {
    				each_value = /*task01*/ ctx[0].displayBtn;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$15(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$15(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if ((!current || dirty & /*task01*/ 1) && t6_value !== (t6_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t6, t6_value);
    			if (!current || dirty & /*showPopUp*/ 8) set_data_dev(t8, /*showPopUp*/ ctx[3]);

    			if (!current || dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}

    			const solution_changes = {};
    			if (dirty & /*task01*/ 1) solution_changes.num_qnty = /*task01*/ ctx[0].columns;
    			if (dirty & /*answer*/ 2) solution_changes.usr_resp = /*answer*/ ctx[1];
    			if (dirty & /*task01*/ 1) solution_changes.num = /*task01*/ ctx[0].valueArray;
    			if (dirty & /*showSolution*/ 16) solution_changes.ans_submit = /*showSolution*/ ctx[4];
    			if (dirty & /*task01*/ 1) solution_changes.answerchange = /*task01*/ ctx[0].answer;
    			solution.$set(solution_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div8);
    			destroy_each(each_blocks, detaching);
    			destroy_component(solution);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1j($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GI_MA_E5", slots, []);
    	let task01 = taskOne$15();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			$$invalidate(2, showNext = "inline-block");
    			return;
    		} else {
    			$$invalidate(4, showSolution = true);
    			$$invalidate(3, showPopUp = randomWrong());
    			$$invalidate(2, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(4, showSolution = false);
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$15());
    		$$invalidate(2, showNext = "none");
    	};

    	const handleClick = parameter => () => {
    		$$invalidate(1, answer = parameter);
    		CheckAnswer();
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GI_MA_E5> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$15,
    		randomCorrect,
    		randomWrong,
    		Solution: AdditionSolution,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		handleClick
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) $$invalidate(4, showSolution = $$props.showSolution);
    		if ("CheckAnswer" in $$props) $$invalidate(5, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(6, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		handleClick
    	];
    }

    class GI_MA_E5 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1j, create_fragment$1j, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GI_MA_E5",
    			options,
    			id: create_fragment$1j.name
    		});
    	}
    }

    let task01$14 = {
      heading: "Addition sentences for word problems - sums up to 10",
      question: "Anna has a chest of coins. Inside, there are 3 gold coins and 1 silver coin. How many coins are in the chest?",
      questionValue : 0,
      valueArray: [],
      answer: 0,
      randomAnswer: 0,
      columns: 2,
      solutionArray : []
    };

    const maxValue$S = 5;
    const minValue$S = 1;
    const findInMaxNumber$i = 10;


    function taskOne$14() {
      task01$14.questionValue = Math.floor(Math.random() * (maxValue$S - minValue$S + 1)) + minValue$S;  
      task01$14.valueArray = [];
      for (let i = 0; i < findInMaxNumber$i; i++) {
        for (let j = 0; j < findInMaxNumber$i; j++) {
          if (task01$14.questionValue == (i + j)) {
            let a = i+"+"+j+"="+(i+j);
              task01$14.valueArray.push(a);
          }
        }
      }
      task01$14.randomAnswer = Math.floor(Math.random() * task01$14.valueArray.length);
      task01$14.answer =  task01$14.valueArray[task01$14.randomAnswer];  
      let tempnum = task01$14.answer.split('=');
      task01$14.solutionArray =  tempnum[0].split('+');
      task01$14.question = "Anna has a chest of coins. Inside, there are "+task01$14.answer[0]+" gold coins and "+task01$14.answer[2]+" silver coin. How many coins are in the chest?";
      return task01$14;  
    }

    /* src/components/taskComponents/GI_MA_E6.svelte generated by Svelte v3.37.0 */
    const file$1h = "src/components/taskComponents/GI_MA_E6.svelte";

    function create_fragment$1i(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let input;
    	let t4;
    	let h6;
    	let t5;
    	let t6_value = /*task01*/ ctx[0].answer + "";
    	let t6;
    	let t7;
    	let div3;
    	let h5;
    	let t8;
    	let t9;
    	let solution;
    	let t10;
    	let div4;
    	let button0;
    	let t12;
    	let button1;
    	let t14;
    	let button2;
    	let current;
    	let mounted;
    	let dispose;

    	solution = new AdditionSolution({
    			props: {
    				num_qnty: /*task01*/ ctx[0].columns,
    				usr_resp: /*answer*/ ctx[1],
    				num: /*task01*/ ctx[0].solutionArray,
    				ans_submit: /*showSolution*/ ctx[4],
    				answerchange: /*task01*/ ctx[0].answer
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			input = element("input");
    			t4 = space();
    			h6 = element("h6");
    			t5 = text("answer ");
    			t6 = text(t6_value);
    			t7 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t8 = text(/*showPopUp*/ ctx[3]);
    			t9 = space();
    			create_component(solution.$$.fragment);
    			t10 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t12 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t14 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$1h, 44, 10, 1075);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1h, 43, 6, 1025);
    			add_location(h4, file$1h, 49, 12, 1251);
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "15");
    			add_location(input, file$1h, 51, 16, 1314);
    			add_location(h6, file$1h, 52, 16, 1418);
    			add_location(div1, file$1h, 50, 12, 1290);
    			add_location(div2, file$1h, 48, 8, 1232);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1h, 57, 12, 1532);
    			add_location(div3, file$1h, 56, 8, 1514);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1h, 62, 12, 1810);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1h, 63, 12, 1906);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1h, 64, 12, 2002);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$1h, 61, 8, 1779);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$1h, 47, 6, 1160);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$1h, 42, 5, 977);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$1h, 41, 1, 943);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t4);
    			append_dev(div1, h6);
    			append_dev(h6, t5);
    			append_dev(h6, t6);
    			append_dev(div5, t7);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t8);
    			append_dev(div5, t9);
    			mount_component(solution, div5, null);
    			append_dev(div5, t10);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t12);
    			append_dev(div4, button1);
    			append_dev(div4, t14);
    			append_dev(div4, button2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[7]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*task01*/ 1) && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*task01*/ 1) && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if ((!current || dirty & /*task01*/ 1) && t6_value !== (t6_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t6, t6_value);
    			if (!current || dirty & /*showPopUp*/ 8) set_data_dev(t8, /*showPopUp*/ ctx[3]);

    			if (!current || dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}

    			const solution_changes = {};
    			if (dirty & /*task01*/ 1) solution_changes.num_qnty = /*task01*/ ctx[0].columns;
    			if (dirty & /*answer*/ 2) solution_changes.usr_resp = /*answer*/ ctx[1];
    			if (dirty & /*task01*/ 1) solution_changes.num = /*task01*/ ctx[0].solutionArray;
    			if (dirty & /*showSolution*/ 16) solution_changes.ans_submit = /*showSolution*/ ctx[4];
    			if (dirty & /*task01*/ 1) solution_changes.answerchange = /*task01*/ ctx[0].answer;
    			solution.$set(solution_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_component(solution);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1i($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GI_MA_E6", slots, []);
    	let task01 = taskOne$14();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		if (answer.replaceAll(" ", "") == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			$$invalidate(2, showNext = "inline-block");
    			return;
    		} else {
    			$$invalidate(4, showSolution = true);
    			$$invalidate(3, showPopUp = randomWrong());
    			$$invalidate(2, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(4, showSolution = false);
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$14());
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GI_MA_E6> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$14,
    		randomCorrect,
    		randomWrong,
    		Solution: AdditionSolution,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) $$invalidate(4, showSolution = $$props.showSolution);
    		if ("CheckAnswer" in $$props) $$invalidate(5, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(6, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class GI_MA_E6 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1i, create_fragment$1i, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GI_MA_E6",
    			options,
    			id: create_fragment$1i.name
    		});
    	}
    }

    let task01$13 = {
      heading : "",
      question: "",
      valueArray: [], 
      answer: 0, 
      operator: "+",
      columns: 0
    };

    let columns$9 = 2;
    let maxValue$R = 18;
    let minValue$R = 0;


    function taskOne$13() {
      task01$13.heading = "Addition facts - sums up to 18";
      task01$13.question = "Add : ";
      task01$13.answer = 0;
      task01$13.columns = columns$9;
      task01$13.valueArray = [];

          for (let i = 0; i < columns$9; i++) {
            task01$13.valueArray[i] = Math.floor(Math.random() * (maxValue$R - minValue$R + 1) ) + minValue$R; 
            task01$13.answer += task01$13.valueArray[i];        
          }
        while(task01$13.answer > maxValue$R){
          console.log('enter');
            task01$13.answer = 0;
          for (let i = 0; i < columns$9; i++) {
            task01$13.valueArray[i] = Math.floor(Math.random() * (maxValue$R - minValue$R + 1) ) + minValue$R; 
            task01$13.answer += task01$13.valueArray[i];        
          }
        }

      return task01$13;
    }

    /* src/components/taskComponents/GI_MA_E7.svelte generated by Svelte v3.37.0 */
    const file$1g = "src/components/taskComponents/GI_MA_E7.svelte";

    function get_each_context$14(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (70:27) {:else}
    function create_else_block$U(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[8] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$1g, 71, 31, 1790);
    			add_location(tr, file$1g, 70, 27, 1754);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[8] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$U.name,
    		type: "else",
    		source: "(70:27) {:else}",
    		ctx
    	});

    	return block;
    }

    // (66:27) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$W(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[8] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$1g, 67, 49, 1590);
    			attr_dev(td, "align", "right");
    			add_location(td, file$1g, 67, 31, 1572);
    			add_location(tr, file$1g, 66, 27, 1536);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[8] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$W.name,
    		type: "if",
    		source: "(66:27) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (65:23) {#each task01.valueArray as col, i }
    function create_each_block$14(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[10] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$W;
    		return create_else_block$U;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$14.name,
    		type: "each",
    		source: "(65:23) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1h(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let solution;
    	let t12;
    	let div4;
    	let button0;
    	let t14;
    	let button1;
    	let t16;
    	let button2;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$14(get_each_context$14(ctx, each_value, i));
    	}

    	solution = new AdditionSolution({
    			props: {
    				num_qnty: /*task01*/ ctx[0].columns,
    				usr_resp: /*answer*/ ctx[1],
    				num: /*task01*/ ctx[0].valueArray,
    				ans_submit: /*showSolution*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			create_component(solution.$$.fragment);
    			t12 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t14 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t16 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$1g, 51, 9, 1073);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1g, 50, 5, 1024);
    			add_location(h4, file$1g, 58, 11, 1246);
    			attr_dev(table, "width", "100");
    			add_location(table, file$1g, 62, 15, 1315);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$1g, 76, 19, 1978);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$1g, 77, 19, 2072);
    			add_location(h6, file$1g, 78, 19, 2193);
    			add_location(div1, file$1g, 60, 11, 1289);
    			add_location(div2, file$1g, 55, 7, 1226);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1g, 83, 11, 2288);
    			add_location(div3, file$1g, 82, 7, 2271);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1g, 87, 11, 2528);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1g, 88, 11, 2623);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1g, 89, 11, 2718);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$1g, 86, 7, 2498);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$1g, 54, 5, 1155);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$1g, 49, 4, 977);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$1g, 48, 1, 944);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			mount_component(solution, div5, null);
    			append_dev(div5, t12);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t14);
    			append_dev(div4, button1);
    			append_dev(div4, t16);
    			append_dev(div4, button2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[7]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*task01*/ 1) && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*task01*/ 1) && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$14(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$14(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if ((!current || dirty & /*task01*/ 1) && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (!current || dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (!current || dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}

    			const solution_changes = {};
    			if (dirty & /*task01*/ 1) solution_changes.num_qnty = /*task01*/ ctx[0].columns;
    			if (dirty & /*answer*/ 2) solution_changes.usr_resp = /*answer*/ ctx[1];
    			if (dirty & /*task01*/ 1) solution_changes.num = /*task01*/ ctx[0].valueArray;
    			if (dirty & /*showSolution*/ 16) solution_changes.ans_submit = /*showSolution*/ ctx[4];
    			solution.$set(solution_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			destroy_component(solution);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1h($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GI_MA_E7", slots, []);
    	let task01 = taskOne$13();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			$$invalidate(2, showNext = "inline-block");
    			return;
    		} else {
    			$$invalidate(4, showSolution = true);
    			$$invalidate(3, showPopUp = randomWrong());
    			$$invalidate(2, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(4, showSolution = false);
    		$$invalidate(0, task01 = taskOne$13());
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GI_MA_E7> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$13,
    		randomCorrect,
    		randomWrong,
    		Solution: AdditionSolution,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) $$invalidate(4, showSolution = $$props.showSolution);
    		if ("CheckAnswer" in $$props) $$invalidate(5, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(6, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class GI_MA_E7 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1h, create_fragment$1h, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GI_MA_E7",
    			options,
    			id: create_fragment$1h.name
    		});
    	}
    }

    let task01$12 = {
      heading : "",
      question: "",
      valueArray: [], 
      answer: 0, 
      operator: "+",
      columns: 0
    };

    let columns$8 = 2;
    let maxValue$Q = 18;
    let minValue$Q = 1;


    function taskOne$12() {
      task01$12.heading = "Addition word problems - sums up to 18";
      task01$12.question = "A school book fair sold 2 chapter books and 9 picture books. How many books were sold in all?";
      task01$12.answer = 0;
      task01$12.columns = columns$8;
      task01$12.valueArray = [];
          for (let i = 0; i < columns$8; i++) {
            task01$12.valueArray[i] = Math.floor(Math.random() * (maxValue$Q - minValue$Q + 1) ) + minValue$Q; 
            task01$12.answer += task01$12.valueArray[i];        
          }
            while(task01$12.answer > maxValue$Q){
                task01$12.answer = 0;
            for (let i = 0; i < columns$8; i++) {
                task01$12.valueArray[i] = Math.floor(Math.random() * (maxValue$Q - minValue$Q + 1) ) + minValue$Q; 
                task01$12.answer += task01$12.valueArray[i];        
            }
            }
        task01$12.question = "A school book fair sold "+task01$12.valueArray[0]+" chapter books and "+task01$12.valueArray[1]+" picture books. How many books were sold in all?";
      return task01$12;
    }

    /* src/components/taskComponents/GI_MA_E9.svelte generated by Svelte v3.37.0 */
    const file$1f = "src/components/taskComponents/GI_MA_E9.svelte";

    function create_fragment$1g(ctx) {
    	let div6;
    	let div5;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div4;
    	let div1;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let input;
    	let t4;
    	let div2;
    	let h5;
    	let t5;
    	let t6;
    	let solution;
    	let t7;
    	let div3;
    	let button0;
    	let t9;
    	let button1;
    	let t11;
    	let button2;
    	let current;
    	let mounted;
    	let dispose;

    	solution = new AdditionSolution({
    			props: {
    				num_qnty: /*task01*/ ctx[0].columns,
    				usr_resp: /*answer*/ ctx[1],
    				num: /*task01*/ ctx[0].valueArray,
    				ans_submit: /*showSolution*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div6 = element("div");
    			div5 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div4 = element("div");
    			div1 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			input = element("input");
    			t4 = space();
    			div2 = element("div");
    			h5 = element("h5");
    			t5 = text(/*showPopUp*/ ctx[3]);
    			t6 = space();
    			create_component(solution.$$.fragment);
    			t7 = space();
    			div3 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t9 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t11 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$1f, 51, 9, 1073);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1f, 50, 5, 1024);
    			add_location(h4, file$1f, 57, 11, 1245);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$1f, 58, 11, 1283);
    			add_location(div1, file$1f, 55, 7, 1226);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1f, 62, 11, 1425);
    			add_location(div2, file$1f, 61, 7, 1408);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1f, 66, 11, 1665);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1f, 67, 11, 1760);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1f, 68, 11, 1855);
    			attr_dev(div3, "class", "mt-3");
    			add_location(div3, file$1f, 65, 7, 1635);
    			attr_dev(div4, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div4, file$1f, 54, 5, 1155);
    			attr_dev(div5, "class", "shadow-sm  bg-white rounded");
    			add_location(div5, file$1f, 49, 4, 977);
    			attr_dev(div6, "class", "container mt-5");
    			add_location(div6, file$1f, 48, 1, 944);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div5);
    			append_dev(div5, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div5, t1);
    			append_dev(div5, div4);
    			append_dev(div4, div1);
    			append_dev(div1, h4);
    			append_dev(h4, t2);
    			append_dev(div1, t3);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div4, t4);
    			append_dev(div4, div2);
    			append_dev(div2, h5);
    			append_dev(h5, t5);
    			append_dev(div4, t6);
    			mount_component(solution, div4, null);
    			append_dev(div4, t7);
    			append_dev(div4, div3);
    			append_dev(div3, button0);
    			append_dev(div3, t9);
    			append_dev(div3, button1);
    			append_dev(div3, t11);
    			append_dev(div3, button2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[7]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*task01*/ 1) && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*task01*/ 1) && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (!current || dirty & /*showPopUp*/ 8) set_data_dev(t5, /*showPopUp*/ ctx[3]);

    			if (!current || dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}

    			const solution_changes = {};
    			if (dirty & /*task01*/ 1) solution_changes.num_qnty = /*task01*/ ctx[0].columns;
    			if (dirty & /*answer*/ 2) solution_changes.usr_resp = /*answer*/ ctx[1];
    			if (dirty & /*task01*/ 1) solution_changes.num = /*task01*/ ctx[0].valueArray;
    			if (dirty & /*showSolution*/ 16) solution_changes.ans_submit = /*showSolution*/ ctx[4];
    			solution.$set(solution_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div6);
    			destroy_component(solution);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1g($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GI_MA_E9", slots, []);
    	let task01 = taskOne$12();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			$$invalidate(2, showNext = "inline-block");
    			return;
    		} else {
    			$$invalidate(4, showSolution = true);
    			$$invalidate(3, showPopUp = randomWrong());
    			$$invalidate(2, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(4, showSolution = false);
    		$$invalidate(0, task01 = taskOne$12());
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GI_MA_E9> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$12,
    		randomCorrect,
    		randomWrong,
    		Solution: AdditionSolution,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) $$invalidate(4, showSolution = $$props.showSolution);
    		if ("CheckAnswer" in $$props) $$invalidate(5, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(6, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class GI_MA_E9 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1g, create_fragment$1g, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GI_MA_E9",
    			options,
    			id: create_fragment$1g.name
    		});
    	}
    }

    let task01$11 = {
      heading : "",
      question: "",
      valueArray: [], 
      answer: 0, 
      operator: "+",
      columns: 0
    };

    let columns$7 = 2;
    let maxValue$P = 18;
    let minValue$P = 1;


    function taskOne$11() {
      task01$11.heading = "Addition word problems - sums up to 18";
      task01$11.question = "A school book fair sold 2 chapter books and 9 picture books. How many books were sold in all?";
      task01$11.answer = 0;
      task01$11.columns = columns$7;
      task01$11.valueArray = [];
      let tempans = 0;
          for (let i = 0; i < columns$7; i++) {
            task01$11.valueArray[i] = Math.floor(Math.random() * (maxValue$P - minValue$P + 1) ) + minValue$P; 
            task01$11.answer += task01$11.valueArray[i];        
          }
            while(task01$11.answer > maxValue$P){
                task01$11.answer = 0;
            for (let i = 0; i < columns$7; i++) {
                task01$11.valueArray[i] = Math.floor(Math.random() * (maxValue$P - minValue$P + 1) ) + minValue$P; 
                task01$11.answer += task01$11.valueArray[i];        
            }
            }
            tempans = task01$11.answer ;
            task01$11.answer = '';
            for (let index = 0; index < task01$11.valueArray.length; index++) {
                if(index == (task01$11.valueArray.length-1)){
                    task01$11.answer += task01$11.valueArray[index] ;  
                } else {
                    task01$11.answer += task01$11.valueArray[index] + "+";  
                }         
            }
            task01$11.answer += "="+tempans;
            console.log(task01$11.answer);
        task01$11.question = "A school book fair sold "+task01$11.valueArray[0]+" chapter books and "+task01$11.valueArray[1]+" picture books. How many books were sold in all?";
      return task01$11;
    }

    /* src/components/taskComponents/GI_MA_E10.svelte generated by Svelte v3.37.0 */
    const file$1e = "src/components/taskComponents/GI_MA_E10.svelte";

    function create_fragment$1f(ctx) {
    	let div6;
    	let div5;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div4;
    	let div1;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let h6;
    	let t5;
    	let input;
    	let t6;
    	let div2;
    	let h5;
    	let t7;
    	let t8;
    	let solution;
    	let t9;
    	let div3;
    	let button0;
    	let t11;
    	let button1;
    	let t13;
    	let button2;
    	let current;
    	let mounted;
    	let dispose;

    	solution = new AdditionSolution({
    			props: {
    				num_qnty: /*task01*/ ctx[0].columns,
    				usr_resp: /*answer*/ ctx[1],
    				num: /*task01*/ ctx[0].valueArray,
    				ans_submit: /*showSolution*/ ctx[4],
    				answerchange: /*task01*/ ctx[0].answer
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div6 = element("div");
    			div5 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div4 = element("div");
    			div1 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			h6 = element("h6");
    			h6.textContent = "Write an addition number sentence that fits the story.";
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			div2 = element("div");
    			h5 = element("h5");
    			t7 = text(/*showPopUp*/ ctx[3]);
    			t8 = space();
    			create_component(solution.$$.fragment);
    			t9 = space();
    			div3 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t11 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t13 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$1e, 51, 9, 1093);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1e, 50, 5, 1044);
    			add_location(h4, file$1e, 57, 11, 1265);
    			add_location(h6, file$1e, 59, 11, 1304);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "10");
    			add_location(input, file$1e, 60, 11, 1379);
    			add_location(div1, file$1e, 55, 7, 1246);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1e, 64, 11, 1522);
    			add_location(div2, file$1e, 63, 7, 1505);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1e, 68, 11, 1791);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1e, 69, 11, 1886);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1e, 70, 11, 1981);
    			attr_dev(div3, "class", "mt-3");
    			add_location(div3, file$1e, 67, 7, 1761);
    			attr_dev(div4, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div4, file$1e, 54, 5, 1175);
    			attr_dev(div5, "class", "shadow-sm  bg-white rounded");
    			add_location(div5, file$1e, 49, 4, 997);
    			attr_dev(div6, "class", "container mt-5");
    			add_location(div6, file$1e, 48, 1, 964);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div5);
    			append_dev(div5, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div5, t1);
    			append_dev(div5, div4);
    			append_dev(div4, div1);
    			append_dev(div1, h4);
    			append_dev(h4, t2);
    			append_dev(div1, t3);
    			append_dev(div1, h6);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div4, t6);
    			append_dev(div4, div2);
    			append_dev(div2, h5);
    			append_dev(h5, t7);
    			append_dev(div4, t8);
    			mount_component(solution, div4, null);
    			append_dev(div4, t9);
    			append_dev(div4, div3);
    			append_dev(div3, button0);
    			append_dev(div3, t11);
    			append_dev(div3, button1);
    			append_dev(div3, t13);
    			append_dev(div3, button2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[7]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*task01*/ 1) && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*task01*/ 1) && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (!current || dirty & /*showPopUp*/ 8) set_data_dev(t7, /*showPopUp*/ ctx[3]);

    			if (!current || dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}

    			const solution_changes = {};
    			if (dirty & /*task01*/ 1) solution_changes.num_qnty = /*task01*/ ctx[0].columns;
    			if (dirty & /*answer*/ 2) solution_changes.usr_resp = /*answer*/ ctx[1];
    			if (dirty & /*task01*/ 1) solution_changes.num = /*task01*/ ctx[0].valueArray;
    			if (dirty & /*showSolution*/ 16) solution_changes.ans_submit = /*showSolution*/ ctx[4];
    			if (dirty & /*task01*/ 1) solution_changes.answerchange = /*task01*/ ctx[0].answer;
    			solution.$set(solution_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div6);
    			destroy_component(solution);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1f($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GI_MA_E10", slots, []);
    	let task01 = taskOne$11();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		if (answer.replaceAll(" ", "") == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			$$invalidate(2, showNext = "inline-block");
    			return;
    		} else {
    			$$invalidate(4, showSolution = true);
    			$$invalidate(3, showPopUp = randomWrong());
    			$$invalidate(2, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(4, showSolution = false);
    		$$invalidate(0, task01 = taskOne$11());
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GI_MA_E10> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$11,
    		randomCorrect,
    		randomWrong,
    		Solution: AdditionSolution,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) $$invalidate(4, showSolution = $$props.showSolution);
    		if ("CheckAnswer" in $$props) $$invalidate(5, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(6, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class GI_MA_E10 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1f, create_fragment$1f, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GI_MA_E10",
    			options,
    			id: create_fragment$1f.name
    		});
    	}
    }

    let task01$10 = {
      heading : "",
      question: "",
      valueArray: [], 
      answer: 0, 
      operator: "+",
      columns: 0
    };

    let columns$6 = 2;
    let maxValue$O = 20;
    let minValue$O = 0;


    function taskOne$10() {
      task01$10.heading = "Addition facts - sums up to 20";
      task01$10.question = "Add : ";
      task01$10.answer = 0;
      task01$10.columns = columns$6;
      task01$10.valueArray = [];

          for (let i = 0; i < columns$6; i++) {
            task01$10.valueArray[i] = Math.floor(Math.random() * (maxValue$O - minValue$O + 1) ) + minValue$O; 
            task01$10.answer += task01$10.valueArray[i];        
          }
        while(task01$10.answer > maxValue$O){
          console.log('enter');
            task01$10.answer = 0;
          for (let i = 0; i < columns$6; i++) {
            task01$10.valueArray[i] = Math.floor(Math.random() * (maxValue$O - minValue$O + 1) ) + minValue$O; 
            task01$10.answer += task01$10.valueArray[i];        
          }
        }

      return task01$10;
    }

    /* src/components/taskComponents/GI_MA_E11.svelte generated by Svelte v3.37.0 */
    const file$1d = "src/components/taskComponents/GI_MA_E11.svelte";

    function get_each_context$13(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (70:27) {:else}
    function create_else_block$T(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[8] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$1d, 71, 31, 1791);
    			add_location(tr, file$1d, 70, 27, 1755);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[8] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$T.name,
    		type: "else",
    		source: "(70:27) {:else}",
    		ctx
    	});

    	return block;
    }

    // (66:27) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$V(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[8] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$1d, 67, 49, 1591);
    			attr_dev(td, "align", "right");
    			add_location(td, file$1d, 67, 31, 1573);
    			add_location(tr, file$1d, 66, 27, 1537);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[8] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$V.name,
    		type: "if",
    		source: "(66:27) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (65:23) {#each task01.valueArray as col, i }
    function create_each_block$13(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[10] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$V;
    		return create_else_block$T;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$13.name,
    		type: "each",
    		source: "(65:23) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1e(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let solution;
    	let t12;
    	let div4;
    	let button0;
    	let t14;
    	let button1;
    	let t16;
    	let button2;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$13(get_each_context$13(ctx, each_value, i));
    	}

    	solution = new AdditionSolution({
    			props: {
    				num_qnty: /*task01*/ ctx[0].columns,
    				usr_resp: /*answer*/ ctx[1],
    				num: /*task01*/ ctx[0].valueArray,
    				ans_submit: /*showSolution*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			create_component(solution.$$.fragment);
    			t12 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t14 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t16 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$1d, 51, 9, 1074);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1d, 50, 5, 1025);
    			add_location(h4, file$1d, 58, 11, 1247);
    			attr_dev(table, "width", "100");
    			add_location(table, file$1d, 62, 15, 1316);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$1d, 76, 19, 1979);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$1d, 77, 19, 2073);
    			add_location(h6, file$1d, 78, 19, 2194);
    			add_location(div1, file$1d, 60, 11, 1290);
    			add_location(div2, file$1d, 55, 7, 1227);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1d, 83, 11, 2289);
    			add_location(div3, file$1d, 82, 7, 2272);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1d, 87, 11, 2529);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1d, 88, 11, 2624);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1d, 89, 11, 2719);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$1d, 86, 7, 2499);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$1d, 54, 5, 1156);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$1d, 49, 4, 978);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$1d, 48, 1, 945);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			mount_component(solution, div5, null);
    			append_dev(div5, t12);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t14);
    			append_dev(div4, button1);
    			append_dev(div4, t16);
    			append_dev(div4, button2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[7]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*task01*/ 1) && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*task01*/ 1) && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$13(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$13(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if ((!current || dirty & /*task01*/ 1) && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (!current || dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (!current || dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}

    			const solution_changes = {};
    			if (dirty & /*task01*/ 1) solution_changes.num_qnty = /*task01*/ ctx[0].columns;
    			if (dirty & /*answer*/ 2) solution_changes.usr_resp = /*answer*/ ctx[1];
    			if (dirty & /*task01*/ 1) solution_changes.num = /*task01*/ ctx[0].valueArray;
    			if (dirty & /*showSolution*/ 16) solution_changes.ans_submit = /*showSolution*/ ctx[4];
    			solution.$set(solution_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			destroy_component(solution);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1e($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GI_MA_E11", slots, []);
    	let task01 = taskOne$10();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			$$invalidate(2, showNext = "inline-block");
    			return;
    		} else {
    			$$invalidate(4, showSolution = true);
    			$$invalidate(3, showPopUp = randomWrong());
    			$$invalidate(2, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(4, showSolution = false);
    		$$invalidate(0, task01 = taskOne$10());
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GI_MA_E11> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$10,
    		randomCorrect,
    		randomWrong,
    		Solution: AdditionSolution,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) $$invalidate(4, showSolution = $$props.showSolution);
    		if ("CheckAnswer" in $$props) $$invalidate(5, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(6, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class GI_MA_E11 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1e, create_fragment$1e, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GI_MA_E11",
    			options,
    			id: create_fragment$1e.name
    		});
    	}
    }

    let task01$$ = {
      heading: "Make a number using addition - sums up to 18",
      question: "Here are the ways to make 4. Find the pattern and type the missing addition number sentence.",
      questionValue : 0,
      valueArray: [],
      answer: 0,
      randomAnswer: 0,
      solutionArray : [],
      columns: 0,
    };

    const maxValue$N = 18;
    const minValue$N = 1;
    const findInMaxNumber$h = 18;
    const showbtn$5 = 4;

    function taskOne$$() {
      task01$$.questionValue = Math.floor(Math.random() * (maxValue$N - minValue$N + 1)) + minValue$N;
      task01$$.question = "How do you make "+task01$$.questionValue+" ?";
      task01$$.valueArray = [];
      task01$$.columns = 2;
      
      let opts = [];
      let ans = [];
      for (let i = 0; i < findInMaxNumber$h; i++) {
        for (let j = 0; j < findInMaxNumber$h; j++) {
          let a = i+"+"+j;
          if (task01$$.questionValue == (i + j)) {          
              ans.push(a);
          }else {
            opts.push(a);
          }
        }    
      }

      task01$$.valueArray = randomArrayNumbers(showbtn$5,opts.length,0,opts);
      task01$$.answer = ans[Math.floor(Math.random() * ans.length)];
      let tempNum = Math.floor(Math.random() * task01$$.valueArray.length);
      task01$$.valueArray[tempNum] = task01$$.answer; 
      task01$$.solutionArray =  task01$$.answer.split('+');  
      task01$$.randomAnswer = Math.floor(Math.random() * task01$$.valueArray.length);
      task01$$.answer = tempNum;
      console.log(task01$$.solutionArray);
      return task01$$;

    }

    /* src/components/taskComponents/GI_MA_E12.svelte generated by Svelte v3.37.0 */
    const file$1c = "src/components/taskComponents/GI_MA_E12.svelte";

    function get_each_context$12(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (65:15) {#each task01.valueArray as value,i}
    function create_each_block$12(ctx) {
    	let button;
    	let t_value = /*value*/ ctx[8] + "";
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "class", "btn toggle-btn ");
    			add_location(button, file$1c, 65, 15, 1479);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleClick*/ ctx[6](/*i*/ ctx[10]), false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*value*/ ctx[8] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$12.name,
    		type: "each",
    		source: "(65:15) {#each task01.valueArray as value,i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1d(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let t4;
    	let div3;
    	let h5;
    	let t5;
    	let t6;
    	let solution;
    	let t7;
    	let div4;
    	let button0;
    	let t9;
    	let button1;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$12(get_each_context$12(ctx, each_value, i));
    	}

    	solution = new AdditionSolution({
    			props: {
    				num_qnty: /*task01*/ ctx[0].columns,
    				usr_resp: /*answer*/ ctx[1] + 1,
    				num: /*task01*/ ctx[0].solutionArray,
    				ans_submit: /*showSolution*/ ctx[4],
    				answerchange: /*task01*/ ctx[0].answer + 1
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t5 = text(/*showPopUp*/ ctx[3]);
    			t6 = space();
    			create_component(solution.$$.fragment);
    			t7 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Rerun";
    			t9 = space();
    			button1 = element("button");
    			button1.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$1c, 57, 10, 1190);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1c, 56, 6, 1140);
    			add_location(h4, file$1c, 62, 12, 1366);
    			add_location(div1, file$1c, 63, 12, 1405);
    			add_location(div2, file$1c, 61, 8, 1347);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1c, 73, 12, 1695);
    			add_location(div3, file$1c, 72, 8, 1677);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1c, 79, 12, 1987);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1c, 80, 12, 2083);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$1c, 77, 8, 1955);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$1c, 60, 6, 1275);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$1c, 55, 5, 1092);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$1c, 54, 1, 1058);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			append_dev(div5, t4);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t5);
    			append_dev(div5, t6);
    			mount_component(solution, div5, null);
    			append_dev(div5, t7);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t9);
    			append_dev(div4, button1);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button0, "click", /*NextQuestion*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*task01*/ 1) && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*task01*/ 1) && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*handleClick, task01*/ 65) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$12(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$12(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (!current || dirty & /*showPopUp*/ 8) set_data_dev(t5, /*showPopUp*/ ctx[3]);

    			if (!current || dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}

    			const solution_changes = {};
    			if (dirty & /*task01*/ 1) solution_changes.num_qnty = /*task01*/ ctx[0].columns;
    			if (dirty & /*answer*/ 2) solution_changes.usr_resp = /*answer*/ ctx[1] + 1;
    			if (dirty & /*task01*/ 1) solution_changes.num = /*task01*/ ctx[0].solutionArray;
    			if (dirty & /*showSolution*/ 16) solution_changes.ans_submit = /*showSolution*/ ctx[4];
    			if (dirty & /*task01*/ 1) solution_changes.answerchange = /*task01*/ ctx[0].answer + 1;
    			solution.$set(solution_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			destroy_component(solution);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1d($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GI_MA_E12", slots, []);
    	let task01 = taskOne$$();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			$$invalidate(2, showNext = "inline-block");
    			return;
    		} else {
    			$$invalidate(4, showSolution = true);
    			$$invalidate(3, showPopUp = randomWrong());
    			$$invalidate(2, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(4, showSolution = false);
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$$());
    		$$invalidate(2, showNext = "none");
    	};

    	const handleClick = parameter => () => {
    		$$invalidate(1, answer = parameter);
    		CheckAnswer();
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GI_MA_E12> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$$,
    		randomCorrect,
    		randomWrong,
    		Solution: AdditionSolution,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		handleClick
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) $$invalidate(4, showSolution = $$props.showSolution);
    		if ("CheckAnswer" in $$props) CheckAnswer = $$props.CheckAnswer;
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [task01, answer, showNext, showPopUp, showSolution, NextQuestion, handleClick];
    }

    class GI_MA_E12 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1d, create_fragment$1d, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GI_MA_E12",
    			options,
    			id: create_fragment$1d.name
    		});
    	}
    }

    let task01$_ = {
      heading: "Ways to make a number - addition sentences",
      question: "Here are the ways to make 4. Find the pattern and type the missing addition number sentence.",
      questionValue : 0,
      valueArray: [],
      answer: 0,
      randomAnswer: 0,
      columns: 0,
      solutionArray : []
    };

    const maxValue$M = 5;
    const minValue$M = 1;
    const findInMaxNumber$g = 10;
    function taskOne$_() {
      task01$_.questionValue = Math.floor(Math.random() * (maxValue$M - minValue$M + 1)) + minValue$M;
      task01$_.question = "Here are the ways to make "+task01$_.questionValue+". Find the pattern and type the missing addition number sentence.";
      task01$_.valueArray = [];
      task01$_.solutionArray = [];
      task01$_.columns = 2;

      for (let i = 0; i < findInMaxNumber$g; i++) {
        for (let j = 0; j < findInMaxNumber$g; j++) {
          if (task01$_.questionValue == (i + j)) {
            let a = i+"+"+j+"="+(i+j);
              task01$_.valueArray.push(a);
          }
        }
      }

      task01$_.randomAnswer = Math.floor(Math.random() * task01$_.valueArray.length);
      task01$_.answer =  task01$_.valueArray[task01$_.randomAnswer];
      let tempnum = task01$_.valueArray[task01$_.randomAnswer].split('=');
      task01$_.solutionArray =  tempnum[0].split('+');
        
      return task01$_;
    }

    /* src/components/taskComponents/GI_MA_E2.svelte generated by Svelte v3.37.0 */
    const file$1b = "src/components/taskComponents/GI_MA_E2.svelte";

    function get_each_context$11(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (65:28) {:else}
    function create_else_block$S(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[8] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$1b, 66, 32, 1827);
    			add_location(tr, file$1b, 65, 28, 1790);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[8] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$S.name,
    		type: "else",
    		source: "(65:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (61:28) {#if i == task01.randomAnswer }
    function create_if_block$U(ctx) {
    	let tr;
    	let td;
    	let input;
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			input = element("input");
    			t = space();
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "15");
    			add_location(input, file$1b, 62, 52, 1583);
    			attr_dev(td, "align", "right");
    			add_location(td, file$1b, 62, 32, 1563);
    			add_location(tr, file$1b, 61, 28, 1526);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(tr, t);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[7]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$U.name,
    		type: "if",
    		source: "(61:28) {#if i == task01.randomAnswer }",
    		ctx
    	});

    	return block;
    }

    // (60:25) {#each task01.valueArray as col, i }
    function create_each_block$11(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[10] == /*task01*/ ctx[0].randomAnswer) return create_if_block$U;
    		return create_else_block$S;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$11.name,
    		type: "each",
    		source: "(60:25) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1c(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let h6;
    	let t5;
    	let t6_value = /*task01*/ ctx[0].answer + "";
    	let t6;
    	let t7;
    	let div3;
    	let h5;
    	let t8;
    	let t9;
    	let solution;
    	let t10;
    	let div4;
    	let button0;
    	let t12;
    	let button1;
    	let t14;
    	let button2;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$11(get_each_context$11(ctx, each_value, i));
    	}

    	solution = new AdditionSolution({
    			props: {
    				num_qnty: /*task01*/ ctx[0].columns,
    				usr_resp: /*answer*/ ctx[1],
    				num: /*task01*/ ctx[0].solutionArray,
    				ans_submit: /*showSolution*/ ctx[4],
    				answerchange: /*task01*/ ctx[0].answer
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			h6 = element("h6");
    			t5 = text("answer ");
    			t6 = text(t6_value);
    			t7 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t8 = text(/*showPopUp*/ ctx[3]);
    			t9 = space();
    			create_component(solution.$$.fragment);
    			t10 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t12 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t14 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$1b, 46, 10, 1061);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1b, 45, 6, 1011);
    			add_location(h4, file$1b, 53, 12, 1239);
    			attr_dev(table, "width", "100");
    			add_location(table, file$1b, 57, 16, 1311);
    			add_location(h6, file$1b, 74, 20, 2079);
    			add_location(div1, file$1b, 55, 12, 1284);
    			add_location(div2, file$1b, 50, 8, 1218);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1b, 79, 12, 2187);
    			add_location(div3, file$1b, 78, 8, 2169);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1b, 84, 12, 2472);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1b, 85, 12, 2568);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1b, 86, 12, 2664);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$1b, 83, 8, 2441);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$1b, 49, 6, 1146);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$1b, 44, 5, 963);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$1b, 43, 1, 929);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, h6);
    			append_dev(h6, t5);
    			append_dev(h6, t6);
    			append_dev(div5, t7);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t8);
    			append_dev(div5, t9);
    			mount_component(solution, div5, null);
    			append_dev(div5, t10);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t12);
    			append_dev(div4, button1);
    			append_dev(div4, t14);
    			append_dev(div4, button2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*task01*/ 1) && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*task01*/ 1) && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*answer, task01*/ 3) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$11(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$11(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if ((!current || dirty & /*task01*/ 1) && t6_value !== (t6_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t6, t6_value);
    			if (!current || dirty & /*showPopUp*/ 8) set_data_dev(t8, /*showPopUp*/ ctx[3]);

    			if (!current || dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}

    			const solution_changes = {};
    			if (dirty & /*task01*/ 1) solution_changes.num_qnty = /*task01*/ ctx[0].columns;
    			if (dirty & /*answer*/ 2) solution_changes.usr_resp = /*answer*/ ctx[1];
    			if (dirty & /*task01*/ 1) solution_changes.num = /*task01*/ ctx[0].solutionArray;
    			if (dirty & /*showSolution*/ 16) solution_changes.ans_submit = /*showSolution*/ ctx[4];
    			if (dirty & /*task01*/ 1) solution_changes.answerchange = /*task01*/ ctx[0].answer;
    			solution.$set(solution_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			destroy_component(solution);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1c($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GI_MA_E2", slots, []);
    	let task01 = taskOne$_();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer.replaceAll(" ", "") == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			$$invalidate(4, showSolution = true);
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$_());
    		$$invalidate(4, showSolution = false);
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GI_MA_E2> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$_,
    		randomCorrect,
    		randomWrong,
    		Solution: AdditionSolution,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) $$invalidate(4, showSolution = $$props.showSolution);
    		if ("CheckAnswer" in $$props) $$invalidate(5, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(6, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class GI_MA_E2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1c, create_fragment$1c, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GI_MA_E2",
    			options,
    			id: create_fragment$1c.name
    		});
    	}
    }

    let task01$Z = {
      heading: "Addition sentences using number lines - sums up to 18",
      question: "Which addition sentence does this model show?",
      questionValue : 0,
      valueArray: [],
      answer: 0,
      randomAnswer: 0,
      columns: 0,
      solutionArray : [],
      verticalLinePos : [],
      lineMaxWidth : 0,
    };

    const lineWidth$1 = 600;

    const findInMaxNumber$f = 18;


    function taskOne$Z() {
      
      task01$Z.randomAnswer = [];
      task01$Z.valueArray = [];
      task01$Z.solutionArray = [];
      task01$Z.columns = 2;

      task01$Z.lineMaxWidth = lineWidth$1;

        for (let i = 0; i < findInMaxNumber$f; i++) {
          task01$Z.verticalLinePos[i] = (lineWidth$1 / (findInMaxNumber$f + 1)) * (i + 1);
            } 


      for (let i = 1; i < findInMaxNumber$f; i++) {
        for (let j = 1; j < findInMaxNumber$f; j++) {      
           
            if((i+j) < findInMaxNumber$f){
              let a = i+"+"+j+"="+(i+j);
              task01$Z.randomAnswer.push(a);   
            }  
        }
      }
      
      task01$Z.valueArray = randomArrayNumbers(4,task01$Z.randomAnswer.length,0,task01$Z.randomAnswer);
      let tempN = Math.floor(Math.random() * task01$Z.valueArray.length );
      task01$Z.answer =  task01$Z.valueArray[tempN];
      
      let tempnum = task01$Z.answer.split('=');
      task01$Z.solutionArray =  tempnum[0].split('+').map(function(item) {
        return parseInt(item, 10);
    });  

        while(task01$Z.solutionArray[0] > task01$Z.solutionArray[1]){
       
          task01$Z.valueArray = randomArrayNumbers(4,task01$Z.randomAnswer.length,0,task01$Z.randomAnswer);
          tempN = Math.floor(Math.random() * task01$Z.valueArray.length );
          task01$Z.answer =  task01$Z.valueArray[tempN];   
          let tempnum = task01$Z.answer.split('=');
          task01$Z.solutionArray =  tempnum[0].split('+').map(function(item) {
            return parseInt(item, 10);
        });      
        }
        task01$Z.answer =  tempN; 
        
      return task01$Z;
    }

    /* src/components/taskComponents/GI_MA_E8.svelte generated by Svelte v3.37.0 */
    const file$1a = "src/components/taskComponents/GI_MA_E8.svelte";

    function get_each_context$10(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    function get_each_context_1$b(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (75:16) {#if task01.solutionArray[0]  < i+2  && (task01.solutionArray[0] + task01.solutionArray[1])-1 > i}
    function create_if_block$T(ctx) {
    	let text_1;
    	let t;
    	let text_1_x_value;
    	let path;
    	let path_d_value;

    	const block = {
    		c: function create() {
    			text_1 = svg_element("text");
    			t = text("+1");
    			path = svg_element("path");
    			attr_dev(text_1, "x", text_1_x_value = "" + (/*countN*/ ctx[11] - 4 + " "));
    			attr_dev(text_1, "y", "15");
    			attr_dev(text_1, "fill", "black");
    			add_location(text_1, file$1a, 75, 20, 1836);
    			attr_dev(path, "d", path_d_value = "M " + (/*countN*/ ctx[11] - 2) + " 30 q 17 -20 33 0");
    			attr_dev(path, "stroke", "red");
    			attr_dev(path, "stroke-width", "2");
    			attr_dev(path, "fill", "none");
    			add_location(path, file$1a, 76, 20, 1909);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, text_1, anchor);
    			append_dev(text_1, t);
    			insert_dev(target, path, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && text_1_x_value !== (text_1_x_value = "" + (/*countN*/ ctx[11] - 4 + " "))) {
    				attr_dev(text_1, "x", text_1_x_value);
    			}

    			if (dirty & /*task01*/ 1 && path_d_value !== (path_d_value = "M " + (/*countN*/ ctx[11] - 2) + " 30 q 17 -20 33 0")) {
    				attr_dev(path, "d", path_d_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(text_1);
    			if (detaching) detach_dev(path);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$T.name,
    		type: "if",
    		source: "(75:16) {#if task01.solutionArray[0]  < i+2  && (task01.solutionArray[0] + task01.solutionArray[1])-1 > i}",
    		ctx
    	});

    	return block;
    }

    // (73:12) {#each task01.verticalLinePos as countN,i}
    function create_each_block_1$b(ctx) {
    	let polyline;
    	let polyline_points_value;
    	let text_1;
    	let t_value = /*i*/ ctx[10] + 1 + "";
    	let t;
    	let text_1_x_value;
    	let if_block = /*task01*/ ctx[0].solutionArray[0] < /*i*/ ctx[10] + 2 && /*task01*/ ctx[0].solutionArray[0] + /*task01*/ ctx[0].solutionArray[1] - 1 > /*i*/ ctx[10] && create_if_block$T(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			polyline = svg_element("polyline");
    			text_1 = svg_element("text");
    			t = text(t_value);
    			attr_dev(polyline, "points", polyline_points_value = "" + (/*countN*/ ctx[11] + ",30  " + /*countN*/ ctx[11] + " 50"));
    			set_style(polyline, "fill", "none");
    			set_style(polyline, "stroke", "black");
    			set_style(polyline, "stroke-width", "2");
    			add_location(polyline, file$1a, 80, 16, 2044);
    			attr_dev(text_1, "x", text_1_x_value = "" + (/*countN*/ ctx[11] - 6 + " "));
    			attr_dev(text_1, "y", "70");
    			attr_dev(text_1, "fill", "black");
    			add_location(text_1, file$1a, 81, 16, 2155);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, polyline, anchor);
    			insert_dev(target, text_1, anchor);
    			append_dev(text_1, t);
    		},
    		p: function update(ctx, dirty) {
    			if (/*task01*/ ctx[0].solutionArray[0] < /*i*/ ctx[10] + 2 && /*task01*/ ctx[0].solutionArray[0] + /*task01*/ ctx[0].solutionArray[1] - 1 > /*i*/ ctx[10]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$T(ctx);
    					if_block.c();
    					if_block.m(polyline.parentNode, polyline);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*task01*/ 1 && polyline_points_value !== (polyline_points_value = "" + (/*countN*/ ctx[11] + ",30  " + /*countN*/ ctx[11] + " 50"))) {
    				attr_dev(polyline, "points", polyline_points_value);
    			}

    			if (dirty & /*task01*/ 1 && text_1_x_value !== (text_1_x_value = "" + (/*countN*/ ctx[11] - 6 + " "))) {
    				attr_dev(text_1, "x", text_1_x_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(polyline);
    			if (detaching) detach_dev(text_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$b.name,
    		type: "each",
    		source: "(73:12) {#each task01.verticalLinePos as countN,i}",
    		ctx
    	});

    	return block;
    }

    // (98:12) {#each task01.valueArray as value,i}
    function create_each_block$10(ctx) {
    	let button;
    	let t_value = /*value*/ ctx[8] + "";
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "class", "btn toggle-btn ");
    			add_location(button, file$1a, 98, 12, 2449);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleClick*/ ctx[6](/*i*/ ctx[10]), false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*value*/ ctx[8] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$10.name,
    		type: "each",
    		source: "(98:12) {#each task01.valueArray as value,i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1b(ctx) {
    	let div7;
    	let div4;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div2;
    	let div1;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let svg;
    	let polyline;
    	let polyline_points_value;
    	let svg_width_value;
    	let t4;
    	let div3;
    	let t5;
    	let div5;
    	let h5;
    	let t6;
    	let t7;
    	let solution;
    	let t8;
    	let div6;
    	let button0;
    	let t10;
    	let button1;
    	let t12;
    	let button2;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value_1 = /*task01*/ ctx[0].verticalLinePos;
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1$b(get_each_context_1$b(ctx, each_value_1, i));
    	}

    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$10(get_each_context$10(ctx, each_value, i));
    	}

    	solution = new AdditionSolution({
    			props: {
    				num_qnty: /*task01*/ ctx[0].columns,
    				usr_resp: /*task01*/ ctx[0].answer,
    				num: /*task01*/ ctx[0].solutionArray,
    				ans_submit: /*showSolution*/ ctx[3]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div4 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div2 = element("div");
    			div1 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			svg = svg_element("svg");
    			polyline = svg_element("polyline");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t4 = space();
    			div3 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t5 = space();
    			div5 = element("div");
    			h5 = element("h5");
    			t6 = text(/*showPopUp*/ ctx[2]);
    			t7 = space();
    			create_component(solution.$$.fragment);
    			t8 = space();
    			div6 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t10 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t12 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$1a, 55, 9, 1184);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$1a, 54, 5, 1135);
    			add_location(h4, file$1a, 62, 11, 1357);
    			attr_dev(polyline, "points", polyline_points_value = "0,40 " + /*task01*/ ctx[0].lineMaxWidth + ",40");
    			set_style(polyline, "fill", "none");
    			set_style(polyline, "stroke", "black");
    			set_style(polyline, "stroke-width", "2");
    			add_location(polyline, file$1a, 70, 12, 1509);
    			attr_dev(svg, "height", "80");
    			attr_dev(svg, "width", svg_width_value = /*task01*/ ctx[0].lineMaxWidth);
    			add_location(svg, file$1a, 65, 11, 1410);
    			add_location(div1, file$1a, 59, 7, 1337);
    			attr_dev(div2, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div2, file$1a, 58, 5, 1266);
    			add_location(div3, file$1a, 95, 11, 2377);
    			attr_dev(div4, "class", "shadow-sm  bg-white rounded");
    			add_location(div4, file$1a, 53, 4, 1088);
    			set_style(h5, "display", /*showNext*/ ctx[1]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$1a, 105, 11, 2614);
    			add_location(div5, file$1a, 104, 7, 2597);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$1a, 109, 11, 2864);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$1a, 110, 11, 2959);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$1a, 111, 11, 3054);
    			attr_dev(div6, "class", "mt-3");
    			add_location(div6, file$1a, 108, 7, 2834);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$1a, 52, 1, 1055);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div4);
    			append_dev(div4, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div4, t1);
    			append_dev(div4, div2);
    			append_dev(div2, div1);
    			append_dev(div1, h4);
    			append_dev(h4, t2);
    			append_dev(div1, t3);
    			append_dev(div1, svg);
    			append_dev(svg, polyline);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(svg, null);
    			}

    			append_dev(div4, t4);
    			append_dev(div4, div3);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div3, null);
    			}

    			append_dev(div7, t5);
    			append_dev(div7, div5);
    			append_dev(div5, h5);
    			append_dev(h5, t6);
    			append_dev(div7, t7);
    			mount_component(solution, div7, null);
    			append_dev(div7, t8);
    			append_dev(div7, div6);
    			append_dev(div6, button0);
    			append_dev(div6, t10);
    			append_dev(div6, button1);
    			append_dev(div6, t12);
    			append_dev(div6, button2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*task01*/ 1) && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*task01*/ 1) && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (!current || dirty & /*task01*/ 1 && polyline_points_value !== (polyline_points_value = "0,40 " + /*task01*/ ctx[0].lineMaxWidth + ",40")) {
    				attr_dev(polyline, "points", polyline_points_value);
    			}

    			if (dirty & /*task01*/ 1) {
    				each_value_1 = /*task01*/ ctx[0].verticalLinePos;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$b(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_1$b(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(svg, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_1.length;
    			}

    			if (!current || dirty & /*task01*/ 1 && svg_width_value !== (svg_width_value = /*task01*/ ctx[0].lineMaxWidth)) {
    				attr_dev(svg, "width", svg_width_value);
    			}

    			if (dirty & /*handleClick, task01*/ 65) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$10(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$10(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div3, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (!current || dirty & /*showPopUp*/ 4) set_data_dev(t6, /*showPopUp*/ ctx[2]);

    			if (!current || dirty & /*showNext*/ 2) {
    				set_style(h5, "display", /*showNext*/ ctx[1]);
    			}

    			const solution_changes = {};
    			if (dirty & /*task01*/ 1) solution_changes.num_qnty = /*task01*/ ctx[0].columns;
    			if (dirty & /*task01*/ 1) solution_changes.usr_resp = /*task01*/ ctx[0].answer;
    			if (dirty & /*task01*/ 1) solution_changes.num = /*task01*/ ctx[0].solutionArray;
    			if (dirty & /*showSolution*/ 8) solution_changes.ans_submit = /*showSolution*/ ctx[3];
    			solution.$set(solution_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    			destroy_component(solution);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1b($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GI_MA_E8", slots, []);
    	let task01 = taskOne$Z();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		if (answer == task01.answer) {
    			$$invalidate(2, showPopUp = randomCorrect());
    			$$invalidate(1, showNext = "inline-block");
    			return;
    		} else {
    			$$invalidate(3, showSolution = true);
    			$$invalidate(2, showPopUp = randomWrong());
    			$$invalidate(1, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		answer = null;
    		$$invalidate(3, showSolution = false);
    		$$invalidate(0, task01 = taskOne$Z());
    		$$invalidate(1, showNext = "none");
    	};

    	const handleClick = parameter => () => {
    		answer = parameter;
    		CheckAnswer();
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GI_MA_E8> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$Z,
    		randomCorrect,
    		randomWrong,
    		Solution: AdditionSolution,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		handleClick
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) answer = $$props.answer;
    		if ("showNext" in $$props) $$invalidate(1, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(2, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) $$invalidate(3, showSolution = $$props.showSolution);
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		handleClick
    	];
    }

    class GI_MA_E8 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1b, create_fragment$1b, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GI_MA_E8",
    			options,
    			id: create_fragment$1b.name
    		});
    	}
    }

    let task01$Y = {
      heading : "",
      question: "",
      valueArray: [], 
      answer: 0, 
      operator: "+",
      columns: 0
    };

    let columns$5 = 2;
    let maxValue$L = 20;
    let minValue$L = 1;


    function taskOne$Y() {
      task01$Y.heading = "Addition word problems - sums up to 20";
      task01$Y.question = "A school book fair sold 2 chapter books and 9 picture books. How many books were sold in all?";
      task01$Y.answer = 0;
      task01$Y.columns = columns$5;
      task01$Y.valueArray = [];
      let tempans = 0;
          for (let i = 0; i < columns$5; i++) {
            task01$Y.valueArray[i] = Math.floor(Math.random() * (maxValue$L - minValue$L + 1) ) + minValue$L; 
            task01$Y.answer += task01$Y.valueArray[i];        
          }
            while(task01$Y.answer > maxValue$L){
                task01$Y.answer = 0;
            for (let i = 0; i < columns$5; i++) {
                task01$Y.valueArray[i] = Math.floor(Math.random() * (maxValue$L - minValue$L + 1) ) + minValue$L; 
                task01$Y.answer += task01$Y.valueArray[i];        
            }
            }
            tempans = task01$Y.answer ;
            task01$Y.answer = '';
            for (let index = 0; index < task01$Y.valueArray.length; index++) {
                if(index == (task01$Y.valueArray.length-1)){
                    task01$Y.answer += task01$Y.valueArray[index] ;  
                } else {
                    task01$Y.answer += task01$Y.valueArray[index] + "+";  
                }         
            }
            task01$Y.answer += "="+tempans;
            console.log(task01$Y.answer);
        task01$Y.question = "A school book fair sold "+task01$Y.valueArray[0]+" chapter books and "+task01$Y.valueArray[1]+" picture books. How many books were sold in all?";
      return task01$Y;
    }

    /* src/components/taskComponents/GI_MA_E13.svelte generated by Svelte v3.37.0 */
    const file$19 = "src/components/taskComponents/GI_MA_E13.svelte";

    function create_fragment$1a(ctx) {
    	let div6;
    	let div5;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div4;
    	let div1;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let h6;
    	let t5;
    	let input;
    	let t6;
    	let div2;
    	let h5;
    	let t7;
    	let t8;
    	let solution;
    	let t9;
    	let div3;
    	let button0;
    	let t11;
    	let button1;
    	let t13;
    	let button2;
    	let current;
    	let mounted;
    	let dispose;

    	solution = new AdditionSolution({
    			props: {
    				num_qnty: /*task01*/ ctx[0].columns,
    				usr_resp: /*answer*/ ctx[1],
    				num: /*task01*/ ctx[0].valueArray,
    				ans_submit: /*showSolution*/ ctx[4],
    				answerchange: /*task01*/ ctx[0].answer
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div6 = element("div");
    			div5 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div4 = element("div");
    			div1 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			h6 = element("h6");
    			h6.textContent = "Write an addition number sentence that fits the story.";
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			div2 = element("div");
    			h5 = element("h5");
    			t7 = text(/*showPopUp*/ ctx[3]);
    			t8 = space();
    			create_component(solution.$$.fragment);
    			t9 = space();
    			div3 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t11 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t13 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$19, 51, 9, 1093);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$19, 50, 5, 1044);
    			add_location(h4, file$19, 57, 11, 1265);
    			add_location(h6, file$19, 59, 11, 1304);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "10");
    			add_location(input, file$19, 60, 11, 1379);
    			add_location(div1, file$19, 55, 7, 1246);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$19, 64, 11, 1522);
    			add_location(div2, file$19, 63, 7, 1505);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$19, 68, 11, 1791);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$19, 69, 11, 1886);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$19, 70, 11, 1981);
    			attr_dev(div3, "class", "mt-3");
    			add_location(div3, file$19, 67, 7, 1761);
    			attr_dev(div4, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div4, file$19, 54, 5, 1175);
    			attr_dev(div5, "class", "shadow-sm  bg-white rounded");
    			add_location(div5, file$19, 49, 4, 997);
    			attr_dev(div6, "class", "container mt-5");
    			add_location(div6, file$19, 48, 1, 964);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div5);
    			append_dev(div5, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div5, t1);
    			append_dev(div5, div4);
    			append_dev(div4, div1);
    			append_dev(div1, h4);
    			append_dev(h4, t2);
    			append_dev(div1, t3);
    			append_dev(div1, h6);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div4, t6);
    			append_dev(div4, div2);
    			append_dev(div2, h5);
    			append_dev(h5, t7);
    			append_dev(div4, t8);
    			mount_component(solution, div4, null);
    			append_dev(div4, t9);
    			append_dev(div4, div3);
    			append_dev(div3, button0);
    			append_dev(div3, t11);
    			append_dev(div3, button1);
    			append_dev(div3, t13);
    			append_dev(div3, button2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[7]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*task01*/ 1) && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*task01*/ 1) && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (!current || dirty & /*showPopUp*/ 8) set_data_dev(t7, /*showPopUp*/ ctx[3]);

    			if (!current || dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}

    			const solution_changes = {};
    			if (dirty & /*task01*/ 1) solution_changes.num_qnty = /*task01*/ ctx[0].columns;
    			if (dirty & /*answer*/ 2) solution_changes.usr_resp = /*answer*/ ctx[1];
    			if (dirty & /*task01*/ 1) solution_changes.num = /*task01*/ ctx[0].valueArray;
    			if (dirty & /*showSolution*/ 16) solution_changes.ans_submit = /*showSolution*/ ctx[4];
    			if (dirty & /*task01*/ 1) solution_changes.answerchange = /*task01*/ ctx[0].answer;
    			solution.$set(solution_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div6);
    			destroy_component(solution);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1a($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GI_MA_E13", slots, []);
    	let task01 = taskOne$Y();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		if (answer.replaceAll(" ", "") == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			$$invalidate(2, showNext = "inline-block");
    			return;
    		} else {
    			$$invalidate(4, showSolution = true);
    			$$invalidate(3, showPopUp = randomWrong());
    			$$invalidate(2, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(4, showSolution = false);
    		$$invalidate(0, task01 = taskOne$Y());
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GI_MA_E13> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$Y,
    		randomCorrect,
    		randomWrong,
    		Solution: AdditionSolution,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) $$invalidate(4, showSolution = $$props.showSolution);
    		if ("CheckAnswer" in $$props) $$invalidate(5, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(6, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class GI_MA_E13 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1a, create_fragment$1a, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GI_MA_E13",
    			options,
    			id: create_fragment$1a.name
    		});
    	}
    }

    let task01$X = {
      heading: "Related addition facts",
      question: "Which is the related addition fact for ",
      questionValue : 0,
      valueArray: [],
      answer: 0,
      randomAnswer: 0,
      solutionArray : [],
      columns: 0,
    };

    const maxValue$K = 10;
    const minValue$K = 1;
    const findInMaxNumber$e = 10;
    const showbtn$4 = 4;

    function taskOne$X() {
      task01$X.questionValue = Math.floor(Math.random() * (maxValue$K - minValue$K + 1)) + minValue$K;
      
      task01$X.valueArray = [];
      task01$X.columns = 2;
      
      let opts = [];
      let ans = [];
      for (let i = 0; i < findInMaxNumber$e; i++) {
        for (let j = 0; j < findInMaxNumber$e; j++) {
          let a = i+"+"+j;
          if (task01$X.questionValue == (i + j)) {          
              ans.push(a);
          }else {
            opts.push(a);
          }
        }    
      }

      task01$X.valueArray = randomArrayNumbers(showbtn$4,opts.length,0,opts);

      task01$X.question = "Which is the related addition fact for "+ans[Math.floor(Math.random() * ans.length)]+"?";
      task01$X.answer = ans[Math.floor(Math.random() * ans.length)];
      
      let tempNum = Math.floor(Math.random() * task01$X.valueArray.length);
      task01$X.valueArray[tempNum] = task01$X.answer; 
      task01$X.solutionArray =  task01$X.answer.split('+');  
      task01$X.randomAnswer = Math.floor(Math.random() * task01$X.valueArray.length);
      task01$X.answer = tempNum; 
      return task01$X;

    }

    /* src/components/taskComponents/GI_MA_E14.svelte generated by Svelte v3.37.0 */
    const file$18 = "src/components/taskComponents/GI_MA_E14.svelte";

    function get_each_context$$(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (65:16) {#each task01.valueArray as value,i}
    function create_each_block$$(ctx) {
    	let button;
    	let t_value = /*value*/ ctx[8] + "";
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "class", "btn toggle-btn ");
    			add_location(button, file$18, 66, 16, 1475);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleClick*/ ctx[7](/*i*/ ctx[10]), false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*value*/ ctx[8] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$$.name,
    		type: "each",
    		source: "(65:16) {#each task01.valueArray as value,i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$19(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let t4;
    	let h6;
    	let t5;
    	let t6_value = /*task01*/ ctx[0].answer + "";
    	let t6;
    	let t7;
    	let div3;
    	let h5;
    	let t8;
    	let t9;
    	let solution;
    	let t10;
    	let div4;
    	let button0;
    	let t12;
    	let button1;
    	let t14;
    	let button2;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$$(get_each_context$$(ctx, each_value, i));
    	}

    	solution = new AdditionSolution({
    			props: {
    				num_qnty: /*task01*/ ctx[0].columns,
    				usr_resp: /*answer*/ ctx[1] + 1,
    				num: /*task01*/ ctx[0].solutionArray,
    				ans_submit: /*showSolution*/ ctx[4],
    				answerchange: /*task01*/ ctx[0].answer + 1
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			h6 = element("h6");
    			t5 = text("answer ");
    			t6 = text(t6_value);
    			t7 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t8 = text(/*showPopUp*/ ctx[3]);
    			t9 = space();
    			create_component(solution.$$.fragment);
    			t10 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t12 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t14 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$18, 53, 10, 1152);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$18, 52, 6, 1102);
    			add_location(h4, file$18, 60, 12, 1330);
    			add_location(h6, file$18, 69, 20, 1616);
    			add_location(div1, file$18, 62, 12, 1375);
    			add_location(div2, file$18, 57, 8, 1309);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$18, 74, 12, 1724);
    			add_location(div3, file$18, 73, 8, 1706);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$18, 79, 12, 2016);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$18, 80, 12, 2112);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$18, 81, 12, 2208);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$18, 78, 8, 1985);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$18, 56, 6, 1237);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$18, 51, 5, 1054);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$18, 50, 1, 1020);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, h6);
    			append_dev(h6, t5);
    			append_dev(h6, t6);
    			append_dev(div5, t7);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t8);
    			append_dev(div5, t9);
    			mount_component(solution, div5, null);
    			append_dev(div5, t10);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t12);
    			append_dev(div4, button1);
    			append_dev(div4, t14);
    			append_dev(div4, button2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*task01*/ 1) && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*task01*/ 1) && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*handleClick, task01*/ 129) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$$(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$$(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, t4);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if ((!current || dirty & /*task01*/ 1) && t6_value !== (t6_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t6, t6_value);
    			if (!current || dirty & /*showPopUp*/ 8) set_data_dev(t8, /*showPopUp*/ ctx[3]);

    			if (!current || dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}

    			const solution_changes = {};
    			if (dirty & /*task01*/ 1) solution_changes.num_qnty = /*task01*/ ctx[0].columns;
    			if (dirty & /*answer*/ 2) solution_changes.usr_resp = /*answer*/ ctx[1] + 1;
    			if (dirty & /*task01*/ 1) solution_changes.num = /*task01*/ ctx[0].solutionArray;
    			if (dirty & /*showSolution*/ 16) solution_changes.ans_submit = /*showSolution*/ ctx[4];
    			if (dirty & /*task01*/ 1) solution_changes.answerchange = /*task01*/ ctx[0].answer + 1;
    			solution.$set(solution_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			destroy_component(solution);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$19.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$19($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GI_MA_E14", slots, []);
    	let task01 = taskOne$X();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			$$invalidate(4, showSolution = true);
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$X());
    		$$invalidate(4, showSolution = false);
    		$$invalidate(2, showNext = "none");
    	};

    	const handleClick = parameter => () => {
    		$$invalidate(1, answer = parameter);
    		CheckAnswer();
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GI_MA_E14> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$X,
    		randomCorrect,
    		randomWrong,
    		Solution: AdditionSolution,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		handleClick
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) $$invalidate(4, showSolution = $$props.showSolution);
    		if ("CheckAnswer" in $$props) $$invalidate(5, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(6, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		handleClick
    	];
    }

    class GI_MA_E14 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$19, create_fragment$19, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GI_MA_E14",
    			options,
    			id: create_fragment$19.name
    		});
    	}
    }

    let task01$W = {
        heading: "Addition sentences: true or false?",
        question: "Here are the ways to make 4. Find the pattern and type the missing addition number sentence.",
        questionValue : 0,
        valueArray: [],
        answer: 0,
        randomAnswer: 0,
        columns: 0,
        solutionArray : [],
        isTrue : true
      };
      
      const maxValue$J = 10;
      const minValue$J = 1;
      const findInMaxNumber$d = 10;
      function taskOne$W() {
        task01$W.questionValue = Math.floor(Math.random() * (maxValue$J - minValue$J + 1)) + minValue$J;
        task01$W.isTrue = Boolean(Math.round(Math.random()));
        task01$W.question = "Which sentence is "+ task01$W.isTrue+ "?";    
        task01$W.valueArray = [];
        task01$W.solutionArray = [];
        task01$W.columns = 2;
        let temparry = [];
        for (let i = 0; i < findInMaxNumber$d; i++) {
          for (let j = 0; j < findInMaxNumber$d; j++) {
            if (task01$W.questionValue == (i + j)) {
              let a = i+"+"+j+"="+(i+j);
              temparry.push(a);
            }
          }
        }
      
        task01$W.randomAnswer = Math.floor(Math.random() * temparry.length);
        task01$W.valueArray [0] =  temparry[task01$W.randomAnswer];
        task01$W.valueArray [1] =  Math.floor(Math.random() * maxValue$J)+"+"+Math.floor(Math.random() * maxValue$J)+"="+(task01$W.questionValue);
        if(task01$W.isTrue){
            task01$W.answer =  0;
        }else {
            task01$W.answer =  1;
        }
        let tempnum = task01$W.valueArray [0].split('=');
        task01$W.solutionArray =  tempnum[0].split('+');
        console.log(task01$W.solutionArray);
        return task01$W;
      }

    /* src/components/taskComponents/GI_MA_E15.svelte generated by Svelte v3.37.0 */
    const file$17 = "src/components/taskComponents/GI_MA_E15.svelte";

    function get_each_context$_(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (65:16) {#each task01.valueArray as value,i}
    function create_each_block$_(ctx) {
    	let button;
    	let t_value = /*value*/ ctx[8] + "";
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "class", "btn toggle-btn ");
    			add_location(button, file$17, 66, 16, 1475);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleClick*/ ctx[7](/*i*/ ctx[10]), false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*value*/ ctx[8] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$_.name,
    		type: "each",
    		source: "(65:16) {#each task01.valueArray as value,i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$18(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let t4;
    	let h6;
    	let t5;
    	let t6_value = /*task01*/ ctx[0].answer + "";
    	let t6;
    	let t7;
    	let div3;
    	let h5;
    	let t8;
    	let t9;
    	let solution;
    	let t10;
    	let div4;
    	let button0;
    	let t12;
    	let button1;
    	let t14;
    	let button2;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$_(get_each_context$_(ctx, each_value, i));
    	}

    	solution = new AdditionSolution({
    			props: {
    				num_qnty: /*task01*/ ctx[0].columns,
    				usr_resp: /*answer*/ ctx[1] + 1,
    				num: /*task01*/ ctx[0].solutionArray,
    				ans_submit: /*showSolution*/ ctx[4],
    				answerchange: /*task01*/ ctx[0].answer + 1
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			h6 = element("h6");
    			t5 = text("answer ");
    			t6 = text(t6_value);
    			t7 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t8 = text(/*showPopUp*/ ctx[3]);
    			t9 = space();
    			create_component(solution.$$.fragment);
    			t10 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t12 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t14 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$17, 53, 10, 1152);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$17, 52, 6, 1102);
    			add_location(h4, file$17, 60, 12, 1330);
    			add_location(h6, file$17, 69, 20, 1616);
    			add_location(div1, file$17, 62, 12, 1375);
    			add_location(div2, file$17, 57, 8, 1309);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$17, 74, 12, 1724);
    			add_location(div3, file$17, 73, 8, 1706);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$17, 82, 12, 2044);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$17, 83, 12, 2140);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$17, 84, 12, 2236);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$17, 81, 9, 2013);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$17, 56, 6, 1237);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$17, 51, 5, 1054);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$17, 50, 1, 1020);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, h6);
    			append_dev(h6, t5);
    			append_dev(h6, t6);
    			append_dev(div5, t7);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t8);
    			append_dev(div5, t9);
    			mount_component(solution, div5, null);
    			append_dev(div5, t10);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t12);
    			append_dev(div4, button1);
    			append_dev(div4, t14);
    			append_dev(div4, button2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*task01*/ 1) && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*task01*/ 1) && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*handleClick, task01*/ 129) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$_(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$_(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, t4);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if ((!current || dirty & /*task01*/ 1) && t6_value !== (t6_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t6, t6_value);
    			if (!current || dirty & /*showPopUp*/ 8) set_data_dev(t8, /*showPopUp*/ ctx[3]);

    			if (!current || dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}

    			const solution_changes = {};
    			if (dirty & /*task01*/ 1) solution_changes.num_qnty = /*task01*/ ctx[0].columns;
    			if (dirty & /*answer*/ 2) solution_changes.usr_resp = /*answer*/ ctx[1] + 1;
    			if (dirty & /*task01*/ 1) solution_changes.num = /*task01*/ ctx[0].solutionArray;
    			if (dirty & /*showSolution*/ 16) solution_changes.ans_submit = /*showSolution*/ ctx[4];
    			if (dirty & /*task01*/ 1) solution_changes.answerchange = /*task01*/ ctx[0].answer + 1;
    			solution.$set(solution_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			destroy_component(solution);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$18.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$18($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GI_MA_E15", slots, []);
    	let task01 = taskOne$W();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			$$invalidate(4, showSolution = true);
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$W());
    		$$invalidate(4, showSolution = false);
    		$$invalidate(2, showNext = "none");
    	};

    	const handleClick = parameter => () => {
    		$$invalidate(1, answer = parameter);
    		CheckAnswer();
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GI_MA_E15> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$W,
    		randomCorrect,
    		randomWrong,
    		Solution: AdditionSolution,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		handleClick
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) $$invalidate(4, showSolution = $$props.showSolution);
    		if ("CheckAnswer" in $$props) $$invalidate(5, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(6, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		handleClick
    	];
    }

    class GI_MA_E15 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$18, create_fragment$18, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GI_MA_E15",
    			options,
    			id: create_fragment$18.name
    		});
    	}
    }

    let task01$V = {
      heading: "Add a one-digit number to a two-digit number - without regrouping",
      question: "Add : ",
      questionValue : 0,
      valueArray: [],
      answer: 0,
      randomAnswer: 0,
      columns: 0,
      operator: "+",
      solutionArray : []
    };

    const maxValue$I = 9;
    const minValue$I = 1;
    const findInMaxNumber$c = 10;
    function taskOne$V() {
      task01$V.questionValue = Math.floor(Math.random() * (maxValue$I - minValue$I + 1)) + minValue$I;
     
      task01$V.valueArray = [];
      task01$V.solutionArray = [];
      task01$V.columns = 2;
        
      for (let i = 0; i < findInMaxNumber$c; i++) {
        for (let j = 0; j < findInMaxNumber$c; j++) {
          if (task01$V.questionValue == (i + j)) {
            let a = i+"+"+j+"="+(i+j);
              task01$V.valueArray.push(a);
          }
        }
      }

      task01$V.randomAnswer = Math.floor(Math.random() * task01$V.valueArray.length);
      
      
      let tempnum = task01$V.valueArray[task01$V.randomAnswer].split('=');
      task01$V.solutionArray =  tempnum[0].split('+');
      let n = Math.floor(Math.random() * 2);
      let numb = parseInt(Math.floor(Math.random() * 2) * 10);
      task01$V.solutionArray[n] = (parseInt(task01$V.solutionArray[n]) + numb).toString();
      task01$V.answer = task01$V.questionValue + numb;
      console.log(task01$V.solutionArray);     
      return task01$V;
    }

    /* src/components/taskComponents/GI_MA_E16.svelte generated by Svelte v3.37.0 */
    const file$16 = "src/components/taskComponents/GI_MA_E16.svelte";

    function get_each_context$Z(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	child_ctx[13] = i;
    	return child_ctx;
    }

    // (72:24) {:else}
    function create_else_block$R(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[11] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$16, 73, 28, 2023);
    			add_location(tr, file$16, 72, 24, 1990);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[11] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$R.name,
    		type: "else",
    		source: "(72:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (68:24) {#if i == (task01.solutionArray.length - 1) }
    function create_if_block$S(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[11] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$16, 69, 46, 1835);
    			attr_dev(td, "align", "right");
    			add_location(td, file$16, 69, 28, 1817);
    			add_location(tr, file$16, 68, 24, 1784);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[11] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$S.name,
    		type: "if",
    		source: "(68:24) {#if i == (task01.solutionArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (67:20) {#each task01.solutionArray as col, i }
    function create_each_block$Z(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[13] == /*task01*/ ctx[0].solutionArray.length - 1) return create_if_block$S;
    		return create_else_block$R;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$Z.name,
    		type: "each",
    		source: "(67:20) {#each task01.solutionArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$17(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let solution;
    	let t12;
    	let div4;
    	let button0;
    	let t14;
    	let button1;
    	let t16;
    	let button2;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].solutionArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$Z(get_each_context$Z(ctx, each_value, i));
    	}

    	solution = new AdditionSolution({
    			props: {
    				num_qnty: /*task01*/ ctx[0].columns,
    				usr_resp: /*answer*/ ctx[1],
    				num: /*task01*/ ctx[0].solutionArray,
    				ans_submit: /*showSolution*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			create_component(solution.$$.fragment);
    			t12 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t14 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t16 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$16, 53, 10, 1315);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$16, 52, 6, 1265);
    			add_location(h4, file$16, 60, 12, 1493);
    			attr_dev(table, "width", "100");
    			add_location(table, file$16, 64, 16, 1565);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$16, 78, 20, 2200);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$16, 79, 20, 2295);
    			add_location(h6, file$16, 80, 20, 2417);
    			add_location(div1, file$16, 62, 12, 1538);
    			add_location(div2, file$16, 57, 8, 1472);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$16, 85, 12, 2525);
    			add_location(div3, file$16, 84, 8, 2507);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$16, 89, 12, 2772);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$16, 90, 12, 2868);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$16, 91, 12, 2964);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$16, 88, 8, 2741);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$16, 56, 6, 1400);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$16, 51, 5, 1217);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$16, 50, 1, 1183);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			mount_component(solution, div5, null);
    			append_dev(div5, t12);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t14);
    			append_dev(div4, button1);
    			append_dev(div4, t16);
    			append_dev(div4, button2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[7]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*task01*/ 1) && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*task01*/ 1) && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].solutionArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$Z(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$Z(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if ((!current || dirty & /*task01*/ 1) && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (!current || dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (!current || dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}

    			const solution_changes = {};
    			if (dirty & /*task01*/ 1) solution_changes.num_qnty = /*task01*/ ctx[0].columns;
    			if (dirty & /*answer*/ 2) solution_changes.usr_resp = /*answer*/ ctx[1];
    			if (dirty & /*task01*/ 1) solution_changes.num = /*task01*/ ctx[0].solutionArray;
    			if (dirty & /*showSolution*/ 16) solution_changes.ans_submit = /*showSolution*/ ctx[4];
    			solution.$set(solution_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			destroy_component(solution);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$17.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const max$i = 10;
    const min$i = 0;
    const numberofColumn$i = 2;

    function instance$17($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GI_MA_E16", slots, []);
    	let heading = "Addition facts - sums up to 10";
    	let question = "Add :";
    	let maxandmin = MaxandMin$5(max$i, min$i, numberofColumn$i, heading, question);
    	let task01 = taskOne$V();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			$$invalidate(4, showSolution = true);
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$V());
    		$$invalidate(4, showSolution = false);
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GI_MA_E16> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$V,
    		randomCorrect,
    		randomWrong,
    		MaxandMin: MaxandMin$5,
    		Solution: AdditionSolution,
    		heading,
    		question,
    		max: max$i,
    		min: min$i,
    		numberofColumn: numberofColumn$i,
    		maxandmin,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("heading" in $$props) heading = $$props.heading;
    		if ("question" in $$props) question = $$props.question;
    		if ("maxandmin" in $$props) maxandmin = $$props.maxandmin;
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) $$invalidate(4, showSolution = $$props.showSolution);
    		if ("CheckAnswer" in $$props) $$invalidate(5, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(6, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class GI_MA_E16 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$17, create_fragment$17, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GI_MA_E16",
    			options,
    			id: create_fragment$17.name
    		});
    	}
    }

    let task01$U = {
      heading: "Add a one-digit number to a two-digit number - without regrouping",
      question: "Add : ",
      questionValue : 0,
      valueArray: [],
      answer: 0,
      randomAnswer: 0,
      columns: 0,
      operator: "+",
      solutionArray : []
    };

    const maxValue$H = 9;
    const minValue$H = 1;
    const findInMaxNumber$b = 10;
    function taskOne$U() {
      task01$U.questionValue = Math.floor(Math.random() * (maxValue$H - minValue$H + 1)) + minValue$H;
      task01$U.answer = 0;
      task01$U.valueArray = [];
      task01$U.solutionArray = [];
      task01$U.columns = 2;
        
      for (let i = 0; i < findInMaxNumber$b; i++) {
        for (let j = 0; j < findInMaxNumber$b; j++) {
          if (10 < (i + j)) {
            let a = i+"+"+j+"="+(i+j);
              task01$U.valueArray.push(a);
          }
        }
      }

      task01$U.randomAnswer = Math.floor(Math.random() * task01$U.valueArray.length);
      
      
      let tempnum = task01$U.valueArray[task01$U.randomAnswer].split('=');
      task01$U.solutionArray =  tempnum[0].split('+');
      let n = Math.floor(Math.random() * 2);  
      task01$U.solutionArray[n] = (parseInt(task01$U.solutionArray[n]) + 10).toString();
      for (let index = 0; index <task01$U.solutionArray.length; index++) {
          task01$U.answer += parseInt(task01$U.solutionArray[index]);
          
      }
      console.log(task01$U.solutionArray);     
      return task01$U;
    }

    /* src/components/taskComponents/GI_MA_E17.svelte generated by Svelte v3.37.0 */
    const file$15 = "src/components/taskComponents/GI_MA_E17.svelte";

    function get_each_context$Y(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	child_ctx[13] = i;
    	return child_ctx;
    }

    // (72:24) {:else}
    function create_else_block$Q(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[11] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$15, 73, 28, 2023);
    			add_location(tr, file$15, 72, 24, 1990);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[11] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$Q.name,
    		type: "else",
    		source: "(72:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (68:24) {#if i == (task01.solutionArray.length - 1) }
    function create_if_block$R(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[11] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$15, 69, 46, 1835);
    			attr_dev(td, "align", "right");
    			add_location(td, file$15, 69, 28, 1817);
    			add_location(tr, file$15, 68, 24, 1784);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[11] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$R.name,
    		type: "if",
    		source: "(68:24) {#if i == (task01.solutionArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (67:20) {#each task01.solutionArray as col, i }
    function create_each_block$Y(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[13] == /*task01*/ ctx[0].solutionArray.length - 1) return create_if_block$R;
    		return create_else_block$Q;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$Y.name,
    		type: "each",
    		source: "(67:20) {#each task01.solutionArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$16(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let solution;
    	let t12;
    	let div4;
    	let button0;
    	let t14;
    	let button1;
    	let t16;
    	let button2;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].solutionArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$Y(get_each_context$Y(ctx, each_value, i));
    	}

    	solution = new AdditionSolution({
    			props: {
    				num_qnty: /*task01*/ ctx[0].columns,
    				usr_resp: /*answer*/ ctx[1],
    				num: /*task01*/ ctx[0].solutionArray,
    				ans_submit: /*showSolution*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			create_component(solution.$$.fragment);
    			t12 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t14 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t16 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$15, 53, 10, 1315);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$15, 52, 6, 1265);
    			add_location(h4, file$15, 60, 12, 1493);
    			attr_dev(table, "width", "100");
    			add_location(table, file$15, 64, 16, 1565);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$15, 78, 20, 2200);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$15, 79, 20, 2295);
    			add_location(h6, file$15, 80, 20, 2417);
    			add_location(div1, file$15, 62, 12, 1538);
    			add_location(div2, file$15, 57, 8, 1472);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$15, 85, 12, 2525);
    			add_location(div3, file$15, 84, 8, 2507);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$15, 89, 12, 2772);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$15, 90, 12, 2868);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$15, 91, 12, 2964);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$15, 88, 8, 2741);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$15, 56, 6, 1400);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$15, 51, 5, 1217);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$15, 50, 1, 1183);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			mount_component(solution, div5, null);
    			append_dev(div5, t12);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t14);
    			append_dev(div4, button1);
    			append_dev(div4, t16);
    			append_dev(div4, button2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[7]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*task01*/ 1) && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*task01*/ 1) && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].solutionArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$Y(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$Y(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if ((!current || dirty & /*task01*/ 1) && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (!current || dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (!current || dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}

    			const solution_changes = {};
    			if (dirty & /*task01*/ 1) solution_changes.num_qnty = /*task01*/ ctx[0].columns;
    			if (dirty & /*answer*/ 2) solution_changes.usr_resp = /*answer*/ ctx[1];
    			if (dirty & /*task01*/ 1) solution_changes.num = /*task01*/ ctx[0].solutionArray;
    			if (dirty & /*showSolution*/ 16) solution_changes.ans_submit = /*showSolution*/ ctx[4];
    			solution.$set(solution_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			destroy_component(solution);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$16.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const max$h = 10;
    const min$h = 0;
    const numberofColumn$h = 2;

    function instance$16($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GI_MA_E17", slots, []);
    	let heading = "Addition facts - sums up to 10";
    	let question = "Add :";
    	let maxandmin = MaxandMin$5(max$h, min$h, numberofColumn$h, heading, question);
    	let task01 = taskOne$U();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			$$invalidate(4, showSolution = true);
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$U());
    		$$invalidate(4, showSolution = false);
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GI_MA_E17> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$U,
    		randomCorrect,
    		randomWrong,
    		MaxandMin: MaxandMin$5,
    		Solution: AdditionSolution,
    		heading,
    		question,
    		max: max$h,
    		min: min$h,
    		numberofColumn: numberofColumn$h,
    		maxandmin,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("heading" in $$props) heading = $$props.heading;
    		if ("question" in $$props) question = $$props.question;
    		if ("maxandmin" in $$props) maxandmin = $$props.maxandmin;
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) $$invalidate(4, showSolution = $$props.showSolution);
    		if ("CheckAnswer" in $$props) $$invalidate(5, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(6, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class GI_MA_E17 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$16, create_fragment$16, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GI_MA_E17",
    			options,
    			id: create_fragment$16.name
    		});
    	}
    }

    let task01$T = {
      heading : "",
      question: "",
      valueArray: [], 
      answer: 0, 
      operator: "-",
      columns: 0
    };

    let columns$4 = 3;
    let maxValue$G = 0;
    let minValue$G = 0;
    let heading$3 = "";
    let question$3 = "";


    function MaxandMin$3(max, min,col,headingtext,qst) {
      minValue$G = min;
      maxValue$G = max;
      columns$4 = col;
      heading$3 = headingtext;
      question$3 = qst;
    }

    function taskOne$T() {
      task01$T.heading = heading$3;
      task01$T.question = question$3;
      task01$T.answer = 0;
      task01$T.columns = columns$4;
      task01$T.valueArray = [];
      
      for (let i = 0; i < columns$4; i++) {
        task01$T.valueArray[i] = Math.floor(Math.random() * (maxValue$G - minValue$G + 1) ) + minValue$G;   
      }

      task01$T.valueArray = task01$T.valueArray.sort((a, b) => b - a);
      task01$T.answer = task01$T.valueArray[0];
      for (let index = 1; index < task01$T.valueArray.length; index++) {
        task01$T.answer -= task01$T.valueArray[index];
      }
      console.log(task01$T.valueArray.sort((a, b) => b - a));
      return task01$T;
    }

    /* src/components/taskComponents/G1_MS_I1.svelte generated by Svelte v3.37.0 */
    const file$14 = "src/components/taskComponents/G1_MS_I1.svelte";

    function get_each_context$X(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	child_ctx[13] = i;
    	return child_ctx;
    }

    // (69:28) {:else}
    function create_else_block$P(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[11] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$14, 70, 32, 1974);
    			add_location(tr, file$14, 69, 28, 1937);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[11] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$P.name,
    		type: "else",
    		source: "(69:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (65:28) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$Q(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[11] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$14, 66, 50, 1770);
    			attr_dev(td, "align", "right");
    			add_location(td, file$14, 66, 32, 1752);
    			add_location(tr, file$14, 65, 28, 1715);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[11] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$Q.name,
    		type: "if",
    		source: "(65:28) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (64:24) {#each task01.valueArray as col, i }
    function create_each_block$X(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[13] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$Q;
    		return create_else_block$P;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$X.name,
    		type: "each",
    		source: "(64:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$15(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$X(get_each_context$X(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$14, 50, 10, 1240);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$14, 49, 6, 1190);
    			add_location(h4, file$14, 57, 12, 1418);
    			attr_dev(table, "width", "100");
    			add_location(table, file$14, 61, 16, 1490);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$14, 75, 20, 2167);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$14, 76, 20, 2262);
    			add_location(h6, file$14, 77, 20, 2384);
    			add_location(div1, file$14, 59, 12, 1463);
    			add_location(div2, file$14, 54, 8, 1397);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$14, 82, 12, 2492);
    			add_location(div3, file$14, 81, 8, 2474);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$14, 86, 12, 2629);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$14, 87, 12, 2725);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$14, 88, 12, 2821);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$14, 85, 8, 2598);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$14, 53, 6, 1325);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$14, 48, 5, 1142);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$14, 47, 1, 1108);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t13);
    			append_dev(div4, button1);
    			append_dev(div4, t15);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$X(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$X(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$15.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const max$g = 10;
    const min$g = 0;
    const numberofColumn$g = 2;

    function instance$15($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MS_I1", slots, []);
    	let heading = "Subtraction facts - numbers up to 10";
    	let question = "Subtract.";
    	let maxandmin = MaxandMin$3(max$g, min$g, numberofColumn$g, heading, question);
    	let task01 = taskOne$T();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$T());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MS_I1> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$T,
    		randomCorrect,
    		randomWrong,
    		MaxandMin: MaxandMin$3,
    		heading,
    		question,
    		max: max$g,
    		min: min$g,
    		numberofColumn: numberofColumn$g,
    		maxandmin,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("heading" in $$props) heading = $$props.heading;
    		if ("question" in $$props) question = $$props.question;
    		if ("maxandmin" in $$props) maxandmin = $$props.maxandmin;
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G1_MS_I1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$15, create_fragment$15, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MS_I1",
    			options,
    			id: create_fragment$15.name
    		});
    	}
    }

    let task01$S = {
      heading: "Subtraction sentences using number lines - sums up to 18",
      question: "Which addition sentence does this model show?",
      questionValue: 0,
      valueArray: [],
      answer: 0,
      randomAnswer: 0,
      columns: 0,
      solutionArray: [],
      verticalLinePos: [],
      lineMaxWidth: 0,
    };

    const lineWidth = 600;
    const findInMaxNumber$a = 18;

    let maxValue$F = 18;
    let minValue$F = 0;
    function taskOne$S() {
      task01$S.randomAnswer = [];
      task01$S.valueArray = [];
      task01$S.solutionArray = [];
      task01$S.columns = 2;

      task01$S.lineMaxWidth = lineWidth;

      for (let i = 0; i < findInMaxNumber$a; i++) {
        task01$S.verticalLinePos[i] = (lineWidth / (findInMaxNumber$a + 1)) * (i + 1);
      }

      for (let i = 0; i < task01$S.columns; i++) {
        task01$S.valueArray[i] =
          Math.floor(Math.random() * (maxValue$F - minValue$F + 1)) + minValue$F;
      }

      task01$S.valueArray = task01$S.valueArray.sort((a, b) => b - a);
      task01$S.answer = task01$S.valueArray[0];
      for (let index = 1; index < task01$S.valueArray.length; index++) {
        task01$S.answer -= task01$S.valueArray[index];
      }
      console.log(task01$S.valueArray.sort((a, b) => b - a));
      return task01$S;
    }

    let task01$R = {
        heading: "Subtract  a one-digit number to a two-digit number - without regrouping",
        question: "Subtract  : ",
        questionValue : 0,
        valueArray: [],
        answer: 0,
        randomAnswer: 0,
        columns: 0,
        operator: "-",
        solutionArray : []
      };
      
      const maxValue$E = 18;
      const minValue$E = 1;
      const findInMaxNumber$9 = 18;
      function taskOne$R() {
        task01$R.questionValue = Math.floor(Math.random() * (maxValue$E - minValue$E + 1)) + minValue$E;
       
        task01$R.valueArray = [];
        task01$R.solutionArray = [];
        task01$R.columns = 2;
          
        for (let i = 0; i < findInMaxNumber$9; i++) {
          for (let j = 0; j < findInMaxNumber$9; j++) {
            if (task01$R.questionValue == (i + j)) {
              let a = i+"-"+j+"="+(i+j);
                task01$R.valueArray.push(a);
            }
          }
        }
      
        task01$R.randomAnswer = Math.floor(Math.random() * task01$R.valueArray.length);
        
        
        let tempnum = task01$R.valueArray[task01$R.randomAnswer].split('=');
        task01$R.solutionArray =  tempnum[0].split('-');
        let n = Math.floor(Math.random() * 2);
        let numb = parseInt(Math.floor(Math.random() * 2) * 10);
        task01$R.solutionArray[n] = (parseInt(task01$R.solutionArray[n]) + numb).toString();
        task01$R.solutionArray = task01$R.solutionArray.sort((a, b) => b - a);
        task01$R.answer = task01$R.solutionArray[0] - task01$R.solutionArray[1];
        return task01$R;
      }

    /* src/components/taskComponents/G1_MS_I15.svelte generated by Svelte v3.37.0 */
    const file$13 = "src/components/taskComponents/G1_MS_I15.svelte";

    function get_each_context$W(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (64:24) {:else}
    function create_else_block$O(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[8] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$13, 65, 28, 1686);
    			add_location(tr, file$13, 64, 24, 1653);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[8] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$O.name,
    		type: "else",
    		source: "(64:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (60:24) {#if i == (task01.solutionArray.length - 1) }
    function create_if_block$P(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[8] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$13, 61, 46, 1498);
    			attr_dev(td, "align", "right");
    			add_location(td, file$13, 61, 28, 1480);
    			add_location(tr, file$13, 60, 24, 1447);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[8] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$P.name,
    		type: "if",
    		source: "(60:24) {#if i == (task01.solutionArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (59:20) {#each task01.solutionArray as col, i }
    function create_each_block$W(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[10] == /*task01*/ ctx[0].solutionArray.length - 1) return create_if_block$P;
    		return create_else_block$O;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$W.name,
    		type: "each",
    		source: "(59:20) {#each task01.solutionArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$14(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].solutionArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$W(get_each_context$W(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$13, 45, 10, 978);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$13, 44, 6, 928);
    			add_location(h4, file$13, 52, 12, 1156);
    			attr_dev(table, "width", "100");
    			add_location(table, file$13, 56, 16, 1228);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$13, 70, 20, 1863);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$13, 71, 20, 1958);
    			add_location(h6, file$13, 72, 20, 2080);
    			add_location(div1, file$13, 54, 12, 1201);
    			add_location(div2, file$13, 49, 8, 1135);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$13, 77, 12, 2188);
    			add_location(div3, file$13, 76, 8, 2170);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$13, 81, 12, 2318);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$13, 82, 12, 2414);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$13, 83, 12, 2510);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$13, 80, 8, 2287);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$13, 48, 6, 1063);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$13, 43, 5, 880);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$13, 42, 1, 846);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t13);
    			append_dev(div4, button1);
    			append_dev(div4, t15);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].solutionArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$W(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$W(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$14.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$14($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MS_I15", slots, []);
    	let task01 = taskOne$R();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$R());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MS_I15> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$R,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G1_MS_I15 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$14, create_fragment$14, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MS_I15",
    			options,
    			id: create_fragment$14.name
    		});
    	}
    }

    /* src/components/taskComponents/G1_MS_I16.svelte generated by Svelte v3.37.0 */
    const file$12 = "src/components/taskComponents/G1_MS_I16.svelte";

    function get_each_context$V(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	child_ctx[13] = i;
    	return child_ctx;
    }

    // (69:28) {:else}
    function create_else_block$N(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[11] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$12, 70, 32, 2012);
    			add_location(tr, file$12, 69, 28, 1975);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[11] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$N.name,
    		type: "else",
    		source: "(69:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (65:28) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$O(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[11] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$12, 66, 50, 1808);
    			attr_dev(td, "align", "right");
    			add_location(td, file$12, 66, 32, 1790);
    			add_location(tr, file$12, 65, 28, 1753);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[11] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$O.name,
    		type: "if",
    		source: "(65:28) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (64:24) {#each task01.valueArray as col, i }
    function create_each_block$V(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[13] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$O;
    		return create_else_block$N;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$V.name,
    		type: "each",
    		source: "(64:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$13(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$V(get_each_context$V(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$12, 50, 10, 1278);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$12, 49, 6, 1228);
    			add_location(h4, file$12, 57, 12, 1456);
    			attr_dev(table, "width", "100");
    			add_location(table, file$12, 61, 16, 1528);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$12, 75, 20, 2205);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$12, 76, 20, 2300);
    			add_location(h6, file$12, 77, 20, 2422);
    			add_location(div1, file$12, 59, 12, 1501);
    			add_location(div2, file$12, 54, 8, 1435);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$12, 82, 12, 2530);
    			add_location(div3, file$12, 81, 8, 2512);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$12, 86, 12, 2667);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$12, 87, 12, 2763);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$12, 88, 12, 2859);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$12, 85, 8, 2636);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$12, 53, 6, 1363);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$12, 48, 5, 1180);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$12, 47, 1, 1146);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t13);
    			append_dev(div4, button1);
    			append_dev(div4, t15);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$V(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$V(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$13.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const max$f = 18;
    const min$f = 0;
    const numberofColumn$f = 2;

    function instance$13($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MS_I16", slots, []);
    	let heading = " Subtract a one-digit number from a two-digit number - with regrouping";
    	let question = "Subtract.";
    	let maxandmin = MaxandMin$3(max$f, min$f, numberofColumn$f, heading, question);
    	let task01 = taskOne$T();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$T());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MS_I16> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$T,
    		randomCorrect,
    		randomWrong,
    		MaxandMin: MaxandMin$3,
    		heading,
    		question,
    		max: max$f,
    		min: min$f,
    		numberofColumn: numberofColumn$f,
    		maxandmin,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("heading" in $$props) heading = $$props.heading;
    		if ("question" in $$props) question = $$props.question;
    		if ("maxandmin" in $$props) maxandmin = $$props.maxandmin;
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G1_MS_I16 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$13, create_fragment$13, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MS_I16",
    			options,
    			id: create_fragment$13.name
    		});
    	}
    }

    let task01$Q = {
      heading : "",
      question: "",
      valueArray: [], 
      answer: 0, 
      operator: "-",
      columns: 0
    };

    const substractionvalue$a = 1;
    const maxValue$D = 18;
    const minValue$D = 1;

    function taskOne$Q() {
      task01$Q.heading = "Subtracting 1";
      task01$Q.question = "Subtract:";
      task01$Q.answer = 0;
      task01$Q.columns = 2;
      task01$Q.valueArray = [];
      task01$Q.valueArray[0] = Math.floor(Math.random() * (maxValue$D - minValue$D + 1) + minValue$D ) ;   
      task01$Q.valueArray[1] = substractionvalue$a;   

      task01$Q.answer = task01$Q.valueArray[0] - minValue$D;

      return task01$Q;
    }

    /* src/components/taskComponents/G1_MS_H1.svelte generated by Svelte v3.37.0 */
    const file$11 = "src/components/taskComponents/G1_MS_H1.svelte";

    function get_each_context$U(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (63:27) {:else}
    function create_else_block$M(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[8] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$11, 64, 31, 1689);
    			add_location(tr, file$11, 63, 27, 1653);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[8] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$M.name,
    		type: "else",
    		source: "(63:27) {:else}",
    		ctx
    	});

    	return block;
    }

    // (59:27) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$N(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[8] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$11, 60, 49, 1489);
    			attr_dev(td, "align", "right");
    			add_location(td, file$11, 60, 31, 1471);
    			add_location(tr, file$11, 59, 27, 1435);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[8] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$N.name,
    		type: "if",
    		source: "(59:27) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (58:23) {#each task01.valueArray as col, i }
    function create_each_block$U(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[10] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$N;
    		return create_else_block$M;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$U.name,
    		type: "each",
    		source: "(58:23) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$12(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$U(get_each_context$U(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$11, 43, 9, 960);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$11, 42, 5, 911);
    			add_location(h4, file$11, 50, 11, 1133);
    			attr_dev(table, "width", "100");
    			add_location(table, file$11, 55, 15, 1214);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$11, 69, 19, 1877);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$11, 70, 19, 1971);
    			add_location(h6, file$11, 71, 19, 2092);
    			add_location(div1, file$11, 53, 11, 1188);
    			add_location(div2, file$11, 47, 7, 1113);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$11, 76, 11, 2195);
    			add_location(div3, file$11, 75, 7, 2178);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$11, 80, 11, 2328);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$11, 81, 11, 2423);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$11, 82, 11, 2518);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$11, 79, 7, 2298);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$11, 46, 5, 1042);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$11, 41, 4, 864);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$11, 40, 0, 831);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t13);
    			append_dev(div4, button1);
    			append_dev(div4, t15);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$U(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$U(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$12.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$12($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MS_H1", slots, []);
    	let task01 = taskOne$Q();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$Q());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MS_H1> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$Q,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G1_MS_H1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$12, create_fragment$12, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MS_H1",
    			options,
    			id: create_fragment$12.name
    		});
    	}
    }

    let task01$P = {
      heading : "",
      question: "",
      valueArray: [], 
      answer: 0, 
      operator: "-",
      columns: 0
    };

    const substractionvalue$9 = 0;
    const maxValue$C = 18;
    const minValue$C = 1;

    function taskOne$P() {
      task01$P.heading = "Subtracting 0";
      task01$P.question = "Subtract:";
      task01$P.answer = 0;
      task01$P.columns = 2;
      task01$P.valueArray = [];
      task01$P.valueArray[0] = Math.floor(Math.random() * (maxValue$C - minValue$C + 1) ) + minValue$C;   
      task01$P.valueArray[1] = substractionvalue$9;   

      task01$P.answer = task01$P.valueArray[0];

      return task01$P;
    }

    /* src/components/taskComponents/G1_MS_H10.svelte generated by Svelte v3.37.0 */
    const file$10 = "src/components/taskComponents/G1_MS_H10.svelte";

    function get_each_context$T(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (62:28) {:else}
    function create_else_block$L(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[8] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$10, 63, 32, 1703);
    			add_location(tr, file$10, 62, 28, 1666);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[8] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$L.name,
    		type: "else",
    		source: "(62:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (58:28) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$M(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[8] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$10, 59, 50, 1499);
    			attr_dev(td, "align", "right");
    			add_location(td, file$10, 59, 32, 1481);
    			add_location(tr, file$10, 58, 28, 1444);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[8] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$M.name,
    		type: "if",
    		source: "(58:28) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (57:24) {#each task01.valueArray as col, i }
    function create_each_block$T(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[10] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$M;
    		return create_else_block$L;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$T.name,
    		type: "each",
    		source: "(57:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$11(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$T(get_each_context$T(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$10, 43, 10, 969);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$10, 42, 6, 919);
    			add_location(h4, file$10, 50, 12, 1147);
    			attr_dev(table, "width", "100");
    			add_location(table, file$10, 54, 16, 1219);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$10, 68, 20, 1896);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$10, 69, 20, 1991);
    			add_location(h6, file$10, 70, 20, 2113);
    			add_location(div1, file$10, 52, 12, 1192);
    			add_location(div2, file$10, 47, 8, 1126);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$10, 75, 12, 2221);
    			add_location(div3, file$10, 74, 8, 2203);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$10, 79, 12, 2358);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$10, 80, 12, 2454);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$10, 81, 12, 2550);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$10, 78, 8, 2327);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$10, 46, 6, 1054);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$10, 41, 5, 871);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$10, 40, 1, 837);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t13);
    			append_dev(div4, button1);
    			append_dev(div4, t15);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$T(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$T(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$11.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$11($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MS_H10", slots, []);
    	let task01 = taskOne$P();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$P());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MS_H10> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$P,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G1_MS_H10 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$11, create_fragment$11, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MS_H10",
    			options,
    			id: create_fragment$11.name
    		});
    	}
    }

    let task01$O = {
      heading: "Ways to make a number - subtraction sentences",
      question: "Here are the ways to make 4. Find the pattern and type the missing addition number sentence.",
      questionValue : 0,
      valueArray: [],
      answer: 0,
      randomAnswer: 0,
      columns: 0,
      solutionArray : []
    };

    const maxValue$B = 5;
    const minValue$B = 0;
    const findInMaxNumber$8 = 6;
    function taskOne$O() {
      task01$O.questionValue = Math.floor(Math.random() * (maxValue$B - minValue$B + 1)) + minValue$B;
      task01$O.question = "Here are the ways to make "+task01$O.questionValue+". Find the pattern and type the missing addition number sentence.";
      task01$O.valueArray = [];
      task01$O.solutionArray = [];
      task01$O.columns = 2;

      for (let i = 0; i < findInMaxNumber$8; i++) {
        for (let j = 0; j < findInMaxNumber$8; j++) {
          if (task01$O.questionValue == (i - j)) {
            let a = i+"-"+j+"="+(i-j);
              task01$O.valueArray.push(a);
          }
        }
      }
      
      task01$O.randomAnswer = Math.floor(Math.random() * task01$O.valueArray.length);
      task01$O.answer =  task01$O.valueArray[task01$O.randomAnswer];
      let tempnum = task01$O.valueArray[task01$O.randomAnswer].split('=');
      task01$O.solutionArray =  tempnum[0].split('+');
        
      return task01$O;
    }

    /* src/components/taskComponents/G1_MS_I2.svelte generated by Svelte v3.37.0 */
    const file$$ = "src/components/taskComponents/G1_MS_I2.svelte";

    function get_each_context$S(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (65:28) {:else}
    function create_else_block$K(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[8] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$$, 66, 32, 1759);
    			add_location(tr, file$$, 65, 28, 1722);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[8] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$K.name,
    		type: "else",
    		source: "(65:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (61:28) {#if i == task01.randomAnswer }
    function create_if_block$L(ctx) {
    	let tr;
    	let td;
    	let input;
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			input = element("input");
    			t = space();
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "15");
    			add_location(input, file$$, 62, 52, 1515);
    			attr_dev(td, "align", "right");
    			add_location(td, file$$, 62, 32, 1495);
    			add_location(tr, file$$, 61, 28, 1458);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(tr, t);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[6]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$L.name,
    		type: "if",
    		source: "(61:28) {#if i == task01.randomAnswer }",
    		ctx
    	});

    	return block;
    }

    // (60:25) {#each task01.valueArray as col, i }
    function create_each_block$S(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[10] == /*task01*/ ctx[0].randomAnswer) return create_if_block$L;
    		return create_else_block$K;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$S.name,
    		type: "each",
    		source: "(60:25) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$10(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let h6;
    	let t5;
    	let t6_value = /*task01*/ ctx[0].answer + "";
    	let t6;
    	let t7;
    	let div3;
    	let h5;
    	let t8;
    	let t9;
    	let div4;
    	let button0;
    	let t11;
    	let button1;
    	let t13;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$S(get_each_context$S(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			h6 = element("h6");
    			t5 = text("answer ");
    			t6 = text(t6_value);
    			t7 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t8 = text(/*showPopUp*/ ctx[3]);
    			t9 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t11 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t13 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$$, 46, 10, 993);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$$, 45, 6, 943);
    			add_location(h4, file$$, 53, 12, 1171);
    			attr_dev(table, "width", "100");
    			add_location(table, file$$, 57, 16, 1243);
    			add_location(h6, file$$, 74, 20, 2011);
    			add_location(div1, file$$, 55, 12, 1216);
    			add_location(div2, file$$, 50, 8, 1150);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$$, 79, 12, 2119);
    			add_location(div3, file$$, 78, 8, 2101);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$$, 83, 12, 2256);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$$, 84, 12, 2352);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$$, 85, 12, 2448);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$$, 82, 8, 2225);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$$, 49, 6, 1078);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$$, 44, 5, 895);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$$, 43, 1, 861);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, h6);
    			append_dev(h6, t5);
    			append_dev(h6, t6);
    			append_dev(div5, t7);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t11);
    			append_dev(div4, button1);
    			append_dev(div4, t13);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*answer, task01*/ 3) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$S(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$S(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*task01*/ 1 && t6_value !== (t6_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t8, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$10.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$10($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MS_I2", slots, []);
    	let task01 = taskOne$O();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer.replaceAll(" ", "") == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$O());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MS_I2> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$O,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G1_MS_I2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$10, create_fragment$10, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MS_I2",
    			options,
    			id: create_fragment$10.name
    		});
    	}
    }

    let task01$N = {
      heading: "Ways to make a number - subtraction sentences",
      question: "Here are the ways to make 4. Find the pattern and type the missing addition number sentence.",
      questionValue : 0,
      valueArray: [],
      answer: 0,
      randomAnswer: 0,
      columns: 0,
      solutionArray : []
    };

    const maxValue$A = 10;
    const minValue$A = 0;
    const findInMaxNumber$7 = 10;
    function taskOne$N() {
      task01$N.questionValue = Math.floor(Math.random() * (maxValue$A - minValue$A + 1)) + minValue$A;
      task01$N.question = "Here are the ways to make "+task01$N.questionValue+". Find the pattern and type the missing addition number sentence.";
      task01$N.valueArray = [];
      task01$N.solutionArray = [];
      task01$N.columns = 2;

      for (let i = 0; i < findInMaxNumber$7; i++) {
        for (let j = 0; j < findInMaxNumber$7; j++) {
          if (task01$N.questionValue == (i - j)) {
            let a = i+"-"+j+"="+(i-j);
              task01$N.valueArray.push(a);
          }
        }
      }
      
      task01$N.randomAnswer = Math.floor(Math.random() * task01$N.valueArray.length);
      task01$N.answer =  task01$N.valueArray[task01$N.randomAnswer];
      let tempnum = task01$N.valueArray[task01$N.randomAnswer].split('=');
      task01$N.solutionArray =  tempnum[0].split('+');
        
      return task01$N;
    }

    /* src/components/taskComponents/G1_MS_I3.svelte generated by Svelte v3.37.0 */
    const file$_ = "src/components/taskComponents/G1_MS_I3.svelte";

    function get_each_context$R(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (65:28) {:else}
    function create_else_block$J(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[8] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$_, 66, 32, 1759);
    			add_location(tr, file$_, 65, 28, 1722);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[8] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$J.name,
    		type: "else",
    		source: "(65:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (61:28) {#if i == task01.randomAnswer }
    function create_if_block$K(ctx) {
    	let tr;
    	let td;
    	let input;
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			input = element("input");
    			t = space();
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "15");
    			add_location(input, file$_, 62, 52, 1515);
    			attr_dev(td, "align", "right");
    			add_location(td, file$_, 62, 32, 1495);
    			add_location(tr, file$_, 61, 28, 1458);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(tr, t);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[6]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$K.name,
    		type: "if",
    		source: "(61:28) {#if i == task01.randomAnswer }",
    		ctx
    	});

    	return block;
    }

    // (60:25) {#each task01.valueArray as col, i }
    function create_each_block$R(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[10] == /*task01*/ ctx[0].randomAnswer) return create_if_block$K;
    		return create_else_block$J;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$R.name,
    		type: "each",
    		source: "(60:25) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$$(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let h6;
    	let t5;
    	let t6_value = /*task01*/ ctx[0].answer + "";
    	let t6;
    	let t7;
    	let div3;
    	let h5;
    	let t8;
    	let t9;
    	let div4;
    	let button0;
    	let t11;
    	let button1;
    	let t13;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$R(get_each_context$R(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			h6 = element("h6");
    			t5 = text("answer ");
    			t6 = text(t6_value);
    			t7 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t8 = text(/*showPopUp*/ ctx[3]);
    			t9 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t11 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t13 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$_, 46, 10, 993);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$_, 45, 6, 943);
    			add_location(h4, file$_, 53, 12, 1171);
    			attr_dev(table, "width", "100");
    			add_location(table, file$_, 57, 16, 1243);
    			add_location(h6, file$_, 74, 20, 2011);
    			add_location(div1, file$_, 55, 12, 1216);
    			add_location(div2, file$_, 50, 8, 1150);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$_, 79, 12, 2119);
    			add_location(div3, file$_, 78, 8, 2101);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$_, 83, 12, 2256);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$_, 84, 12, 2352);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$_, 85, 12, 2448);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$_, 82, 8, 2225);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$_, 49, 6, 1078);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$_, 44, 5, 895);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$_, 43, 1, 861);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, h6);
    			append_dev(h6, t5);
    			append_dev(h6, t6);
    			append_dev(div5, t7);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t11);
    			append_dev(div4, button1);
    			append_dev(div4, t13);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*answer, task01*/ 3) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$R(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$R(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*task01*/ 1 && t6_value !== (t6_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t8, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$$.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$$($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MS_I3", slots, []);
    	let task01 = taskOne$N();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer.replaceAll(" ", "") == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$N());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MS_I3> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$N,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G1_MS_I3 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$$, create_fragment$$, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MS_I3",
    			options,
    			id: create_fragment$$.name
    		});
    	}
    }

    let task01$M = {
      heading: "Make a number using subtraction - numbers up to 10",
      question: "Here are the ways to make 4. Find the pattern and type the missing subtraction number sentence.",
      questionValue : 0,
      valueArray: [],
      answer: 0,
      randomAnswer: 0,
      solutionArray : [],
      columns: 0,
    };

    const maxValue$z = 10;
    const minValue$z = 1;
    const findInMaxNumber$6 = 10;
    const showbtn$3 = 4;

    function taskOne$M() {
      task01$M.questionValue = Math.floor(Math.random() * (maxValue$z - minValue$z + 1)) + minValue$z;
      task01$M.question = "How do you make "+task01$M.questionValue+" ?";
      task01$M.valueArray = [];
      task01$M.columns = 2;
      
      let opts = [];
      let ans = [];
      for (let i = 0; i < findInMaxNumber$6; i++) {
        for (let j = 0; j < findInMaxNumber$6; j++) {
          let a = i+"-"+j;
          if (task01$M.questionValue == (i - j)) {          
              ans.push(a);
          }else {
            opts.push(a);
          }
        }    
      }

      task01$M.valueArray = randomArrayNumbers(showbtn$3,opts.length,0,opts);
      task01$M.answer = ans[Math.floor(Math.random() * ans.length)];
      let tempNum = Math.floor(Math.random() * task01$M.valueArray.length);
      task01$M.valueArray[tempNum] = task01$M.answer; 
      task01$M.solutionArray =  task01$M.answer.split('-');  
      task01$M.randomAnswer = Math.floor(Math.random() * task01$M.valueArray.length);
      task01$M.answer = tempNum;
      console.log(task01$M.solutionArray);
      return task01$M;

    }

    /* src/components/taskComponents/G1_MS_I4.svelte generated by Svelte v3.37.0 */
    const file$Z = "src/components/taskComponents/G1_MS_I4.svelte";

    function get_each_context$Q(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (65:15) {#each task01.valueArray as value,i}
    function create_each_block$Q(ctx) {
    	let button;
    	let t_value = /*value*/ ctx[8] + "";
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "class", "btn toggle-btn ");
    			add_location(button, file$Z, 65, 15, 1408);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleClick*/ ctx[4](/*i*/ ctx[10]), false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*value*/ ctx[8] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$Q.name,
    		type: "each",
    		source: "(65:15) {#each task01.valueArray as value,i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$_(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let t4;
    	let div3;
    	let h5;
    	let t5;
    	let t6;
    	let div4;
    	let button0;
    	let t8;
    	let button1;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$Q(get_each_context$Q(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t5 = text(/*showPopUp*/ ctx[2]);
    			t6 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Rerun";
    			t8 = space();
    			button1 = element("button");
    			button1.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$Z, 57, 10, 1119);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$Z, 56, 6, 1069);
    			add_location(h4, file$Z, 62, 12, 1295);
    			add_location(div1, file$Z, 63, 12, 1334);
    			add_location(div2, file$Z, 61, 8, 1276);
    			set_style(h5, "display", /*showNext*/ ctx[1]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$Z, 73, 12, 1624);
    			add_location(div3, file$Z, 72, 8, 1606);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$Z, 78, 12, 1763);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$Z, 79, 12, 1859);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$Z, 76, 8, 1731);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$Z, 60, 6, 1204);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$Z, 55, 5, 1021);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$Z, 54, 1, 987);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			append_dev(div5, t4);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t5);
    			append_dev(div5, t6);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t8);
    			append_dev(div4, button1);

    			if (!mounted) {
    				dispose = listen_dev(button0, "click", /*NextQuestion*/ ctx[3], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*handleClick, task01*/ 17) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$Q(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$Q(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*showPopUp*/ 4) set_data_dev(t5, /*showPopUp*/ ctx[2]);

    			if (dirty & /*showNext*/ 2) {
    				set_style(h5, "display", /*showNext*/ ctx[1]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$_.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$_($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MS_I4", slots, []);
    	let task01 = taskOne$M();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		if (answer == task01.answer) {
    			$$invalidate(2, showPopUp = randomCorrect());
    			$$invalidate(1, showNext = "inline-block");
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(2, showPopUp = randomWrong());
    			$$invalidate(1, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		showSolution = false;
    		answer = null;
    		$$invalidate(0, task01 = taskOne$M());
    		$$invalidate(1, showNext = "none");
    	};

    	const handleClick = parameter => () => {
    		answer = parameter;
    		CheckAnswer();
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MS_I4> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$M,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		handleClick
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) answer = $$props.answer;
    		if ("showNext" in $$props) $$invalidate(1, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(2, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) CheckAnswer = $$props.CheckAnswer;
    		if ("NextQuestion" in $$props) $$invalidate(3, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [task01, showNext, showPopUp, NextQuestion, handleClick];
    }

    class G1_MS_I4 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$_, create_fragment$_, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MS_I4",
    			options,
    			id: create_fragment$_.name
    		});
    	}
    }

    let task01$L = {
      heading : "",
      question: "",
      valueArray: [], 
      answer: 0, 
      operator: "-",
      columns: 0
    };

    const substractionvalue$8 = 2;
    const maxValue$y = 99;
    const minValue$y = 10;

    function taskOne$L() {
      task01$L.heading = "Subtract two two-digit numbers - without regrouping";
      task01$L.question = "Subtract:";
      task01$L.answer = 0;
      task01$L.columns = 2;
      task01$L.valueArray = []; 
      task01$L.answer = 0;

      let temp = 0;
      let temparry = [];
      for (let index = 0; index < substractionvalue$8; index++) {    
        temp = (Math.floor(Math.random() * (maxValue$y - minValue$y + 1) ) + minValue$y).toString().split('').sort((a, b) => b - a);
          for (let j = 0; j < temp.length; j++) {
            if(index < 1){
              temparry[j] = temp[j];
            }else {
              temparry[j] += temp[j];
            }
            
          }
      }
      task01$L.valueArray = temparry.map(function(item) {
        return parseInt(item, 10);
      });
      console.log(task01$L.valueArray);
      task01$L.answer = task01$L.valueArray[0];
      for (let index = 1; index < task01$L.valueArray.length; index++) {
        task01$L.answer -= task01$L.valueArray[index];
        
      }
      return task01$L;
    }

    /* src/components/taskComponents/G2_MS_H4.svelte generated by Svelte v3.37.0 */
    const file$Y = "src/components/taskComponents/G2_MS_H4.svelte";

    function get_each_context$P(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (61:28) {:else}
    function create_else_block$I(ctx) {
    	let td;
    	let t_value = /*col*/ ctx[8] + "";
    	let t;

    	const block = {
    		c: function create() {
    			td = element("td");
    			t = text(t_value);
    			attr_dev(td, "align", "right");
    			add_location(td, file$Y, 61, 32, 1662);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*col*/ ctx[8] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$I.name,
    		type: "else",
    		source: "(61:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (59:28) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$J(ctx) {
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[8] + "";
    	let t1;

    	const block = {
    		c: function create() {
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$Y, 59, 50, 1497);
    			attr_dev(td, "align", "right");
    			add_location(td, file$Y, 59, 32, 1479);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[8] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$J.name,
    		type: "if",
    		source: "(59:28) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (58:24) {#each task01.valueArray as col, i }
    function create_each_block$P(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[10] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$J;
    		return create_else_block$I;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$P.name,
    		type: "each",
    		source: "(58:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$Z(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let tr;
    	let t4;
    	let td0;
    	let t6;
    	let td1;
    	let input;
    	let t7;
    	let h6;
    	let t8;
    	let t9_value = /*task01*/ ctx[0].answer + "";
    	let t9;
    	let t10;
    	let div3;
    	let h5;
    	let t11;
    	let t12;
    	let div4;
    	let button0;
    	let t14;
    	let button1;
    	let t16;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$P(get_each_context$P(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");
    			tr = element("tr");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			td0 = element("td");
    			td0.textContent = "=";
    			t6 = space();
    			td1 = element("td");
    			input = element("input");
    			t7 = space();
    			h6 = element("h6");
    			t8 = text("answer ");
    			t9 = text(t9_value);
    			t10 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t11 = text(/*showPopUp*/ ctx[3]);
    			t12 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t14 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t16 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$Y, 44, 10, 968);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$Y, 43, 6, 918);
    			add_location(h4, file$Y, 51, 12, 1146);
    			attr_dev(td0, "align", "right");
    			add_location(td0, file$Y, 64, 24, 1809);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$Y, 65, 42, 1883);
    			attr_dev(td1, "align", "right");
    			add_location(td1, file$Y, 65, 24, 1865);
    			add_location(tr, file$Y, 56, 20, 1258);
    			attr_dev(table, "width", "100");
    			add_location(table, file$Y, 55, 16, 1218);
    			add_location(h6, file$Y, 69, 20, 2083);
    			add_location(div1, file$Y, 53, 12, 1191);
    			add_location(div2, file$Y, 48, 8, 1125);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$Y, 74, 12, 2191);
    			add_location(div3, file$Y, 73, 8, 2173);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$Y, 78, 12, 2328);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$Y, 79, 12, 2424);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$Y, 80, 12, 2520);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$Y, 77, 8, 2297);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$Y, 47, 6, 1053);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$Y, 42, 5, 870);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$Y, 41, 1, 836);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);
    			append_dev(table, tr);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			append_dev(tr, t4);
    			append_dev(tr, td0);
    			append_dev(tr, t6);
    			append_dev(tr, td1);
    			append_dev(td1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t7);
    			append_dev(div1, h6);
    			append_dev(h6, t8);
    			append_dev(h6, t9);
    			append_dev(div5, t10);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t11);
    			append_dev(div5, t12);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t14);
    			append_dev(div4, button1);
    			append_dev(div4, t16);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$P(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$P(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, t4);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t9_value !== (t9_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t9, t9_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t11, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G2_MS_H4", slots, []);
    	let task01 = taskOne$L();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$L());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G2_MS_H4> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$L,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G2_MS_H4 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Z, create_fragment$Z, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G2_MS_H4",
    			options,
    			id: create_fragment$Z.name
    		});
    	}
    }

    /* src/components/taskComponents/G2_MS_H5.svelte generated by Svelte v3.37.0 */
    const file$X = "src/components/taskComponents/G2_MS_H5.svelte";

    function get_each_context$O(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	child_ctx[13] = i;
    	return child_ctx;
    }

    // (69:28) {:else}
    function create_else_block$H(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[11] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$X, 70, 32, 1991);
    			add_location(tr, file$X, 69, 28, 1954);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[11] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$H.name,
    		type: "else",
    		source: "(69:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (65:28) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$I(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[11] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$X, 66, 50, 1787);
    			attr_dev(td, "align", "right");
    			add_location(td, file$X, 66, 32, 1769);
    			add_location(tr, file$X, 65, 28, 1732);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[11] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$I.name,
    		type: "if",
    		source: "(65:28) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (64:24) {#each task01.valueArray as col, i }
    function create_each_block$O(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[13] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$I;
    		return create_else_block$H;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$O.name,
    		type: "each",
    		source: "(64:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$Y(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$O(get_each_context$O(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$X, 50, 10, 1257);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$X, 49, 6, 1207);
    			add_location(h4, file$X, 57, 12, 1435);
    			attr_dev(table, "width", "100");
    			add_location(table, file$X, 61, 16, 1507);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$X, 75, 20, 2184);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$X, 76, 20, 2279);
    			add_location(h6, file$X, 77, 20, 2401);
    			add_location(div1, file$X, 59, 12, 1480);
    			add_location(div2, file$X, 54, 8, 1414);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$X, 82, 12, 2509);
    			add_location(div3, file$X, 81, 8, 2491);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$X, 86, 12, 2646);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$X, 87, 12, 2742);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$X, 88, 12, 2838);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$X, 85, 8, 2615);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$X, 53, 6, 1342);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$X, 48, 5, 1159);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$X, 47, 1, 1125);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t13);
    			append_dev(div4, button1);
    			append_dev(div4, t15);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$O(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$O(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const max$e = 99;
    const min$e = 10;
    const numberofColumn$e = 2;

    function instance$Y($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G2_MS_H5", slots, []);
    	let heading = "Subtract two two-digit numbers - with regrouping";
    	let question = "Subtract.";
    	let maxandmin = MaxandMin$3(max$e, min$e, numberofColumn$e, heading, question);
    	let task01 = taskOne$T();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$T());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G2_MS_H5> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$T,
    		randomCorrect,
    		randomWrong,
    		MaxandMin: MaxandMin$3,
    		heading,
    		question,
    		max: max$e,
    		min: min$e,
    		numberofColumn: numberofColumn$e,
    		maxandmin,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("heading" in $$props) heading = $$props.heading;
    		if ("question" in $$props) question = $$props.question;
    		if ("maxandmin" in $$props) maxandmin = $$props.maxandmin;
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G2_MS_H5 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Y, create_fragment$Y, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G2_MS_H5",
    			options,
    			id: create_fragment$Y.name
    		});
    	}
    }

    let task01$K = {
      heading : "Subtract:",
      question: "Type the missing digit:",
      valueArray: [],
      answer: [],
      operator: "-",
      displayValues:[],
      columns: 0
    };

    let columns$3 = 0;
    let maxValue$x = 0;
    let minValue$x = 0;
    let heading$2 = "";
    let question$2 = "";
    let maxInputs$4 = 2;

    function MaxandMin$2(max, min,col,headingtext,qst, maxinput) {
      minValue$x = min;
      maxValue$x = max;
      columns$3 = col;
      heading$2 = headingtext;
      question$2 = qst; 
      maxInputs$4 = maxinput;
    }

    function taskOne$K() {

      task01$K.heading = heading$2;
      task01$K.question = question$2;
      task01$K.answer = [];
      task01$K.columns = columns$3;
      task01$K.valueArray = [];
      task01$K.displayValues = [];
     
      for (let i = 0; i < columns$3; i++) {
        task01$K.valueArray[i] = Math.floor(Math.random() * (maxValue$x - minValue$x + 1) ) + minValue$x;   
      }

      task01$K.valueArray = task01$K.valueArray.sort((a, b) => b - a);

      let sum = task01$K.valueArray[0];

      for (let index = 1; index < task01$K.valueArray.length; index++) {
        sum -= task01$K.valueArray[index];
      }
      
      sum.toString().split('');
       
      let tempArray = [];

      task01$K.valueArray.forEach(element => {    
        task01$K.displayValues.push(element.toString().split('').reverse());
      });

      task01$K.displayValues.push(sum.toString().split('').reverse());

      for (let index = 0; index < task01$K.displayValues.length; index++) {
        tempArray[index] = [...task01$K.displayValues[index]];    
      }
      
      let tempRandom = 0;
      let tempRandomInput = 0; 
      
     
      for (let index = 0; index < maxInputs$4; index++) {      
      tempRandom = Math.floor(Math.random() * task01$K.displayValues.length);
      tempRandomInput = Math.floor(Math.random() * task01$K.displayValues[tempRandom].length);
        if(task01$K.displayValues[tempRandom][tempRandomInput] == 'i'){
          while(task01$K.displayValues[tempRandom][tempRandomInput] == 'i'){              
            tempRandom = Math.floor(Math.random() * task01$K.displayValues.length);
            tempRandomInput = Math.floor(Math.random() * task01$K.displayValues[tempRandom].length);      
          }
          
          task01$K.displayValues[tempRandom][tempRandomInput] = 'i'; 
        
        }else {     
          task01$K.displayValues[tempRandom][tempRandomInput] = 'i';   
          
        }
      }

      
    let tempId = 0;
      for (let i = 0; i <  task01$K.displayValues.length; i++) {
        
          for (let j = 0; j <  task01$K.displayValues[i].length; j++) {

              if(task01$K.displayValues[i][j] == 'i'){
                task01$K.displayValues[i][j] = ('i'+tempId);
                tempId++;
                task01$K.answer.push(tempArray[i][j]);
              }
            
          }
      }

      return task01$K;
    }

    let task01$J = {
      heading : "Subtraction sentences for word problems - numbers up to 10",
      question: "",
      valueArray: [], 
      answer: 0, 
      operator: "-",
      columns: 0
    };


    let maxValue$w = 10;
    let minValue$w = 0;




    function taskOne$J() {

      task01$J.answer = "";
      task01$J.columns = 2;
      task01$J.valueArray = [];
      
      for (let i = 0; i < task01$J.columns; i++) {
        task01$J.valueArray[i] = Math.floor(Math.random() * (maxValue$w - minValue$w + 1) ) + minValue$w;   
      }

      task01$J.valueArray = task01$J.valueArray.sort((a, b) => b - a);
      task01$J.answer = task01$J.valueArray[0] +'-'+task01$J.valueArray[1]+'='+(task01$J.valueArray[0] - task01$J.valueArray[1]);
      task01$J.question = task01$J.valueArray[1] + " of the pairs of shoes in a shoe store are black. There are "+task01$J.valueArray[0]+" pairs of shoes in the store in all.  How many of the pairs of shoes are not black?";
      console.log(task01$J.valueArray.sort((a, b) => b - a));
      return task01$J;
    }

    /* src/components/taskComponents/G1_MS_I7.svelte generated by Svelte v3.37.0 */
    const file$W = "src/components/taskComponents/G1_MS_I7.svelte";

    function create_fragment$X(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let input;
    	let t4;
    	let h6;
    	let t5;
    	let t6_value = /*task01*/ ctx[0].answer + "";
    	let t6;
    	let t7;
    	let div3;
    	let h5;
    	let t8;
    	let t9;
    	let div4;
    	let button0;
    	let t11;
    	let button1;
    	let t13;
    	let button2;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			input = element("input");
    			t4 = space();
    			h6 = element("h6");
    			t5 = text("answer ");
    			t6 = text(t6_value);
    			t7 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t8 = text(/*showPopUp*/ ctx[3]);
    			t9 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t11 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t13 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$W, 43, 10, 988);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$W, 42, 6, 938);
    			add_location(h4, file$W, 50, 12, 1166);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$W, 54, 20, 1242);
    			add_location(h6, file$W, 55, 20, 1364);
    			add_location(div1, file$W, 52, 12, 1211);
    			add_location(div2, file$W, 47, 8, 1145);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$W, 60, 12, 1472);
    			add_location(div3, file$W, 59, 8, 1454);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$W, 64, 12, 1609);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$W, 65, 12, 1705);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$W, 66, 12, 1801);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$W, 63, 8, 1578);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$W, 46, 6, 1073);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$W, 41, 5, 890);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$W, 40, 1, 856);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t4);
    			append_dev(div1, h6);
    			append_dev(h6, t5);
    			append_dev(h6, t6);
    			append_dev(div5, t7);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t11);
    			append_dev(div4, button1);
    			append_dev(div4, t13);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t6_value !== (t6_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t8, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$X.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$X($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MS_I7", slots, []);
    	let task01 = taskOne$J();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer.replaceAll(" ", "") == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$J());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MS_I7> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$J,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G1_MS_I7 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$X, create_fragment$X, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MS_I7",
    			options,
    			id: create_fragment$X.name
    		});
    	}
    }

    /* src/components/taskComponents/G1_MS_I8.svelte generated by Svelte v3.37.0 */
    const file$V = "src/components/taskComponents/G1_MS_I8.svelte";

    function get_each_context$N(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	child_ctx[13] = i;
    	return child_ctx;
    }

    // (69:28) {:else}
    function create_else_block$G(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[11] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$V, 70, 32, 1978);
    			add_location(tr, file$V, 69, 28, 1941);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[11] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$G.name,
    		type: "else",
    		source: "(69:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (65:28) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$H(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[11] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$V, 66, 50, 1774);
    			attr_dev(td, "align", "right");
    			add_location(td, file$V, 66, 32, 1756);
    			add_location(tr, file$V, 65, 28, 1719);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[11] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$H.name,
    		type: "if",
    		source: "(65:28) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (64:24) {#each task01.valueArray as col, i }
    function create_each_block$N(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[13] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$H;
    		return create_else_block$G;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$N.name,
    		type: "each",
    		source: "(64:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$W(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$N(get_each_context$N(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$V, 50, 10, 1244);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$V, 49, 6, 1194);
    			add_location(h4, file$V, 57, 12, 1422);
    			attr_dev(table, "width", "100");
    			add_location(table, file$V, 61, 16, 1494);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$V, 75, 20, 2171);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$V, 76, 20, 2266);
    			add_location(h6, file$V, 77, 20, 2388);
    			add_location(div1, file$V, 59, 12, 1467);
    			add_location(div2, file$V, 54, 8, 1401);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$V, 82, 12, 2496);
    			add_location(div3, file$V, 81, 8, 2478);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$V, 86, 12, 2633);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$V, 87, 12, 2729);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$V, 88, 12, 2825);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$V, 85, 8, 2602);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$V, 53, 6, 1329);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$V, 48, 5, 1146);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$V, 47, 1, 1112);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t13);
    			append_dev(div4, button1);
    			append_dev(div4, t15);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$N(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$N(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$W.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const max$d = 18;
    const min$d = 0;
    const numberofColumn$d = 2;

    function instance$W($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MS_I8", slots, []);
    	let heading = "Subtraction facts - numbers up to 18";
    	let question = "Subtract.";
    	let maxandmin = MaxandMin$3(max$d, min$d, numberofColumn$d, heading, question);
    	let task01 = taskOne$T();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$T());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MS_I8> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$T,
    		randomCorrect,
    		randomWrong,
    		MaxandMin: MaxandMin$3,
    		heading,
    		question,
    		max: max$d,
    		min: min$d,
    		numberofColumn: numberofColumn$d,
    		maxandmin,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("heading" in $$props) heading = $$props.heading;
    		if ("question" in $$props) question = $$props.question;
    		if ("maxandmin" in $$props) maxandmin = $$props.maxandmin;
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G1_MS_I8 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$W, create_fragment$W, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MS_I8",
    			options,
    			id: create_fragment$W.name
    		});
    	}
    }

    /* src/components/taskComponents/G1_MS_I9.svelte generated by Svelte v3.37.0 */
    const file$U = "src/components/taskComponents/G1_MS_I9.svelte";

    function get_each_context$M(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (63:16) {#if task01.valueArray[1] < i+2 && task01.valueArray[0] > i+1}
    function create_if_block$G(ctx) {
    	let text_1;
    	let t;
    	let text_1_x_value;
    	let path;
    	let path_d_value;

    	const block = {
    		c: function create() {
    			text_1 = svg_element("text");
    			t = text("-1");
    			path = svg_element("path");
    			attr_dev(text_1, "x", text_1_x_value = "" + (/*countN*/ ctx[8] + " "));
    			attr_dev(text_1, "y", "15");
    			attr_dev(text_1, "fill", "black");
    			add_location(text_1, file$U, 63, 20, 1548);
    			attr_dev(path, "d", path_d_value = "M " + /*countN*/ ctx[8] + " 30 q 17 -20 33 0");
    			attr_dev(path, "stroke", "red");
    			attr_dev(path, "stroke-width", "2");
    			attr_dev(path, "fill", "none");
    			add_location(path, file$U, 64, 20, 1619);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, text_1, anchor);
    			append_dev(text_1, t);
    			insert_dev(target, path, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && text_1_x_value !== (text_1_x_value = "" + (/*countN*/ ctx[8] + " "))) {
    				attr_dev(text_1, "x", text_1_x_value);
    			}

    			if (dirty & /*task01*/ 1 && path_d_value !== (path_d_value = "M " + /*countN*/ ctx[8] + " 30 q 17 -20 33 0")) {
    				attr_dev(path, "d", path_d_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(text_1);
    			if (detaching) detach_dev(path);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$G.name,
    		type: "if",
    		source: "(63:16) {#if task01.valueArray[1] < i+2 && task01.valueArray[0] > i+1}",
    		ctx
    	});

    	return block;
    }

    // (62:12) {#each task01.verticalLinePos as countN,i}
    function create_each_block$M(ctx) {
    	let polyline;
    	let polyline_points_value;
    	let text_1;
    	let t_value = /*i*/ ctx[10] + 1 + "";
    	let t;
    	let text_1_x_value;
    	let if_block = /*task01*/ ctx[0].valueArray[1] < /*i*/ ctx[10] + 2 && /*task01*/ ctx[0].valueArray[0] > /*i*/ ctx[10] + 1 && create_if_block$G(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			polyline = svg_element("polyline");
    			text_1 = svg_element("text");
    			t = text(t_value);
    			attr_dev(polyline, "points", polyline_points_value = "" + (/*countN*/ ctx[8] + ",30  " + /*countN*/ ctx[8] + " 50"));
    			set_style(polyline, "fill", "none");
    			set_style(polyline, "stroke", "black");
    			set_style(polyline, "stroke-width", "2");
    			add_location(polyline, file$U, 66, 16, 1747);
    			attr_dev(text_1, "x", text_1_x_value = "" + (/*countN*/ ctx[8] - 6 + " "));
    			attr_dev(text_1, "y", "70");
    			attr_dev(text_1, "fill", "black");
    			add_location(text_1, file$U, 67, 16, 1858);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, polyline, anchor);
    			insert_dev(target, text_1, anchor);
    			append_dev(text_1, t);
    		},
    		p: function update(ctx, dirty) {
    			if (/*task01*/ ctx[0].valueArray[1] < /*i*/ ctx[10] + 2 && /*task01*/ ctx[0].valueArray[0] > /*i*/ ctx[10] + 1) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$G(ctx);
    					if_block.c();
    					if_block.m(polyline.parentNode, polyline);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*task01*/ 1 && polyline_points_value !== (polyline_points_value = "" + (/*countN*/ ctx[8] + ",30  " + /*countN*/ ctx[8] + " 50"))) {
    				attr_dev(polyline, "points", polyline_points_value);
    			}

    			if (dirty & /*task01*/ 1 && text_1_x_value !== (text_1_x_value = "" + (/*countN*/ ctx[8] - 6 + " "))) {
    				attr_dev(text_1, "x", text_1_x_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(polyline);
    			if (detaching) detach_dev(text_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$M.name,
    		type: "each",
    		source: "(62:12) {#each task01.verticalLinePos as countN,i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$V(ctx) {
    	let div7;
    	let div4;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div2;
    	let div1;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let svg;
    	let polyline;
    	let polyline_points_value;
    	let svg_width_value;
    	let t4;
    	let div3;
    	let input;
    	let t5;
    	let h6;
    	let t6;
    	let t7_value = /*task01*/ ctx[0].answer + "";
    	let t7;
    	let t8;
    	let div5;
    	let h5;
    	let t9;
    	let t10;
    	let div6;
    	let button0;
    	let t12;
    	let button1;
    	let t14;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].verticalLinePos;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$M(get_each_context$M(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div4 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div2 = element("div");
    			div1 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			svg = svg_element("svg");
    			polyline = svg_element("polyline");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			div3 = element("div");
    			input = element("input");
    			t5 = space();
    			h6 = element("h6");
    			t6 = text("answer ");
    			t7 = text(t7_value);
    			t8 = space();
    			div5 = element("div");
    			h5 = element("h5");
    			t9 = text(/*showPopUp*/ ctx[3]);
    			t10 = space();
    			div6 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t12 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t14 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$U, 50, 9, 1002);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$U, 49, 5, 953);
    			add_location(h4, file$U, 57, 11, 1175);
    			attr_dev(polyline, "points", polyline_points_value = "0,40 " + /*task01*/ ctx[0].lineMaxWidth + ",40");
    			set_style(polyline, "fill", "none");
    			set_style(polyline, "stroke", "black");
    			set_style(polyline, "stroke-width", "2");
    			add_location(polyline, file$U, 59, 11, 1273);
    			attr_dev(svg, "height", "80");
    			attr_dev(svg, "width", svg_width_value = /*task01*/ ctx[0].lineMaxWidth);
    			add_location(svg, file$U, 58, 11, 1213);
    			add_location(div1, file$U, 54, 7, 1155);
    			attr_dev(div2, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div2, file$U, 53, 5, 1084);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$U, 75, 12, 2041);
    			add_location(h6, file$U, 76, 12, 2155);
    			add_location(div3, file$U, 73, 11, 2018);
    			attr_dev(div4, "class", "shadow-sm  bg-white rounded");
    			add_location(div4, file$U, 48, 4, 906);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$U, 82, 11, 2254);
    			add_location(div5, file$U, 81, 7, 2237);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$U, 86, 11, 2386);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$U, 87, 11, 2481);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$U, 88, 11, 2576);
    			attr_dev(div6, "class", "mt-3");
    			add_location(div6, file$U, 85, 7, 2356);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$U, 47, 1, 873);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div4);
    			append_dev(div4, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div4, t1);
    			append_dev(div4, div2);
    			append_dev(div2, div1);
    			append_dev(div1, h4);
    			append_dev(h4, t2);
    			append_dev(div1, t3);
    			append_dev(div1, svg);
    			append_dev(svg, polyline);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(svg, null);
    			}

    			append_dev(div4, t4);
    			append_dev(div4, div3);
    			append_dev(div3, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div3, t5);
    			append_dev(div3, h6);
    			append_dev(h6, t6);
    			append_dev(h6, t7);
    			append_dev(div7, t8);
    			append_dev(div7, div5);
    			append_dev(div5, h5);
    			append_dev(h5, t9);
    			append_dev(div7, t10);
    			append_dev(div7, div6);
    			append_dev(div6, button0);
    			append_dev(div6, t12);
    			append_dev(div6, button1);
    			append_dev(div6, t14);
    			append_dev(div6, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1 && polyline_points_value !== (polyline_points_value = "0,40 " + /*task01*/ ctx[0].lineMaxWidth + ",40")) {
    				attr_dev(polyline, "points", polyline_points_value);
    			}

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].verticalLinePos;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$M(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$M(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(svg, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*task01*/ 1 && svg_width_value !== (svg_width_value = /*task01*/ ctx[0].lineMaxWidth)) {
    				attr_dev(svg, "width", svg_width_value);
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t7_value !== (t7_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t7, t7_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t9, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$V.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$V($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MS_I9", slots, []);
    	let task01 = taskOne$S();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			$$invalidate(2, showNext = "inline-block");
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    			$$invalidate(2, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		showSolution = false;
    		$$invalidate(0, task01 = taskOne$S());
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MS_I9> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$S,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G1_MS_I9 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$V, create_fragment$V, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MS_I9",
    			options,
    			id: create_fragment$V.name
    		});
    	}
    }

    let task01$I = {
      heading : "",
      question: "",
      valueArray: [], 
      answer: 0, 
      operator: "-",
      columns: 0
    };

    let columns$2 = 2;
    let maxValue$v = 0;
    let minValue$v = 0;
    let heading$1 = "";
    let question$1 = "";


    function MaxandMin$1(max, min,col,headingtext,qst) {
      minValue$v = min;
      maxValue$v = max;
      columns$2 = col;
      heading$1 = headingtext;
      question$1 = qst;
    }

    function taskOne$I() {
      task01$I.heading = heading$1;
      task01$I.question = question$1;
      task01$I.answer = 0;
      task01$I.columns = columns$2;
      task01$I.valueArray = [];
      
      for (let i = 0; i < columns$2; i++) {
        task01$I.valueArray[i] = Math.floor(Math.random() * (maxValue$v - minValue$v + 1) ) + minValue$v;   
      }

      task01$I.valueArray = task01$I.valueArray.sort((a, b) => b - a);
      task01$I.answer = task01$I.valueArray[0];
      for (let index = 1; index < task01$I.valueArray.length; index++) {
        task01$I.answer -= task01$I.valueArray[index];
      }

      task01$I.question = task01$I.valueArray[1] + " of the pairs of shoes in a shoe store are black. There are "+task01$I.valueArray[0]+" pairs of shoes in the store in all.  How many of the pairs of shoes are not black?";
      console.log(task01$I.valueArray.sort((a, b) => b - a));
      return task01$I;
    }

    /* src/components/taskComponents/G1_MS_I10.svelte generated by Svelte v3.37.0 */
    const file$T = "src/components/taskComponents/G1_MS_I10.svelte";

    function create_fragment$U(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let input;
    	let t4;
    	let h6;
    	let t5;
    	let t6_value = /*task01*/ ctx[0].answer + "";
    	let t6;
    	let t7;
    	let div3;
    	let h5;
    	let t8;
    	let t9;
    	let div4;
    	let button0;
    	let t11;
    	let button1;
    	let t13;
    	let button2;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			input = element("input");
    			t4 = space();
    			h6 = element("h6");
    			t5 = text("answer ");
    			t6 = text(t6_value);
    			t7 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t8 = text(/*showPopUp*/ ctx[3]);
    			t9 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t11 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t13 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$T, 50, 10, 1276);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$T, 49, 6, 1226);
    			add_location(h4, file$T, 57, 12, 1454);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$T, 62, 20, 1531);
    			add_location(h6, file$T, 63, 20, 1653);
    			add_location(div1, file$T, 59, 12, 1499);
    			add_location(div2, file$T, 54, 8, 1433);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$T, 68, 12, 1761);
    			add_location(div3, file$T, 67, 8, 1743);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$T, 72, 12, 1898);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$T, 73, 12, 1994);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$T, 74, 12, 2090);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$T, 71, 8, 1867);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$T, 53, 6, 1361);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$T, 48, 5, 1178);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$T, 47, 1, 1144);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t4);
    			append_dev(div1, h6);
    			append_dev(h6, t5);
    			append_dev(h6, t6);
    			append_dev(div5, t7);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t11);
    			append_dev(div4, button1);
    			append_dev(div4, t13);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t6_value !== (t6_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t8, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$U.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const max$c = 18;
    const min$c = 0;
    const numberofColumn$c = 2;

    function instance$U($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MS_I10", slots, []);
    	let heading = "Subtraction word problems - numbers up to 18";
    	let question = "Subtract.";
    	let maxandmin = MaxandMin$1(max$c, min$c, numberofColumn$c, heading, question);
    	let task01 = taskOne$I();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$I());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MS_I10> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$I,
    		randomCorrect,
    		randomWrong,
    		MaxandMin: MaxandMin$1,
    		heading,
    		question,
    		max: max$c,
    		min: min$c,
    		numberofColumn: numberofColumn$c,
    		maxandmin,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("heading" in $$props) heading = $$props.heading;
    		if ("question" in $$props) question = $$props.question;
    		if ("maxandmin" in $$props) maxandmin = $$props.maxandmin;
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G1_MS_I10 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$U, create_fragment$U, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MS_I10",
    			options,
    			id: create_fragment$U.name
    		});
    	}
    }

    let task01$H = {
      heading : "Subtraction sentences for word problems - numbers up to 18",
      question: "",
      valueArray: [], 
      answer: 0, 
      operator: "-",
      columns: 0
    };


    let maxValue$u = 18;
    let minValue$u = 0;




    function taskOne$H() {

      task01$H.answer = "";
      task01$H.columns = 2;
      task01$H.valueArray = [];
      
      for (let i = 0; i < task01$H.columns; i++) {
        task01$H.valueArray[i] = Math.floor(Math.random() * (maxValue$u - minValue$u + 1) ) + minValue$u;   
      }

      task01$H.valueArray = task01$H.valueArray.sort((a, b) => b - a);
      task01$H.answer = task01$H.valueArray[0] +'-'+task01$H.valueArray[1]+'='+(task01$H.valueArray[0] - task01$H.valueArray[1]);
      task01$H.question = task01$H.valueArray[1] + " of the pairs of shoes in a shoe store are black. There are "+task01$H.valueArray[0]+" pairs of shoes in the store in all.  How many of the pairs of shoes are not black?";
      console.log(task01$H.valueArray.sort((a, b) => b - a));
      return task01$H;
    }

    /* src/components/taskComponents/G1_MS_I11.svelte generated by Svelte v3.37.0 */
    const file$S = "src/components/taskComponents/G1_MS_I11.svelte";

    function create_fragment$T(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let input;
    	let t4;
    	let h6;
    	let t5;
    	let t6_value = /*task01*/ ctx[0].answer + "";
    	let t6;
    	let t7;
    	let div3;
    	let h5;
    	let t8;
    	let t9;
    	let div4;
    	let button0;
    	let t11;
    	let button1;
    	let t13;
    	let button2;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			input = element("input");
    			t4 = space();
    			h6 = element("h6");
    			t5 = text("answer ");
    			t6 = text(t6_value);
    			t7 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t8 = text(/*showPopUp*/ ctx[3]);
    			t9 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t11 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t13 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$S, 43, 10, 989);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$S, 42, 6, 939);
    			add_location(h4, file$S, 50, 12, 1167);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "10");
    			add_location(input, file$S, 54, 20, 1243);
    			add_location(h6, file$S, 55, 20, 1366);
    			add_location(div1, file$S, 52, 12, 1212);
    			add_location(div2, file$S, 47, 8, 1146);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$S, 60, 12, 1474);
    			add_location(div3, file$S, 59, 8, 1456);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$S, 64, 12, 1611);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$S, 65, 12, 1707);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$S, 66, 12, 1803);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$S, 63, 8, 1580);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$S, 46, 6, 1074);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$S, 41, 5, 891);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$S, 40, 1, 857);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t4);
    			append_dev(div1, h6);
    			append_dev(h6, t5);
    			append_dev(h6, t6);
    			append_dev(div5, t7);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t11);
    			append_dev(div4, button1);
    			append_dev(div4, t13);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t6_value !== (t6_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t8, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$T.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$T($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MS_I11", slots, []);
    	let task01 = taskOne$H();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer.replaceAll(" ", "") == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$H());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MS_I11> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$H,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G1_MS_I11 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$T, create_fragment$T, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MS_I11",
    			options,
    			id: create_fragment$T.name
    		});
    	}
    }

    let task01$G = {
      heading: "Make a number using subtraction - numbers up to 20",
      question: "Here are the ways to make 4. Find the pattern and type the missing subtraction number sentence.",
      questionValue : 0,
      valueArray: [],
      answer: 0,
      randomAnswer: 0,
      solutionArray : [],
      columns: 0,
    };

    const maxValue$t = 20;
    const minValue$t = 1;
    const findInMaxNumber$5 = 20;
    const showbtn$2 = 4;

    function taskOne$G() {
      task01$G.questionValue = Math.floor(Math.random() * (maxValue$t - minValue$t + 1)) + minValue$t;
      task01$G.question = "How do you make "+task01$G.questionValue+" ?";
      task01$G.valueArray = [];
      task01$G.columns = 2;
      
      let opts = [];
      let ans = [];
      for (let i = 0; i < findInMaxNumber$5; i++) {
        for (let j = 0; j < findInMaxNumber$5; j++) {
          let a = i+"-"+j;
          if (task01$G.questionValue == (i - j)) {          
              ans.push(a);
          }else {
            opts.push(a);
          }
        }    
      }

      task01$G.valueArray = randomArrayNumbers(showbtn$2,opts.length,0,opts);
      task01$G.answer = ans[Math.floor(Math.random() * ans.length)];
      let tempNum = Math.floor(Math.random() * task01$G.valueArray.length);
      task01$G.valueArray[tempNum] = task01$G.answer; 
      task01$G.solutionArray =  task01$G.answer.split('-');  
      task01$G.randomAnswer = Math.floor(Math.random() * task01$G.valueArray.length);
      task01$G.answer = tempNum;
      console.log(task01$G.solutionArray);
      return task01$G;

    }

    /* src/components/taskComponents/G1_MS_I12.svelte generated by Svelte v3.37.0 */
    const file$R = "src/components/taskComponents/G1_MS_I12.svelte";

    function get_each_context$L(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (65:15) {#each task01.valueArray as value,i}
    function create_each_block$L(ctx) {
    	let button;
    	let t_value = /*value*/ ctx[8] + "";
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "class", "btn toggle-btn ");
    			add_location(button, file$R, 65, 15, 1409);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleClick*/ ctx[4](/*i*/ ctx[10]), false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*value*/ ctx[8] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$L.name,
    		type: "each",
    		source: "(65:15) {#each task01.valueArray as value,i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$S(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let t4;
    	let div3;
    	let h5;
    	let t5;
    	let t6;
    	let div4;
    	let button0;
    	let t8;
    	let button1;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$L(get_each_context$L(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t5 = text(/*showPopUp*/ ctx[2]);
    			t6 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Rerun";
    			t8 = space();
    			button1 = element("button");
    			button1.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$R, 57, 10, 1120);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$R, 56, 6, 1070);
    			add_location(h4, file$R, 62, 12, 1296);
    			add_location(div1, file$R, 63, 12, 1335);
    			add_location(div2, file$R, 61, 8, 1277);
    			set_style(h5, "display", /*showNext*/ ctx[1]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$R, 73, 12, 1625);
    			add_location(div3, file$R, 72, 8, 1607);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$R, 78, 12, 1764);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$R, 79, 12, 1860);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$R, 76, 8, 1732);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$R, 60, 6, 1205);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$R, 55, 5, 1022);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$R, 54, 1, 988);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			append_dev(div5, t4);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t5);
    			append_dev(div5, t6);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t8);
    			append_dev(div4, button1);

    			if (!mounted) {
    				dispose = listen_dev(button0, "click", /*NextQuestion*/ ctx[3], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*handleClick, task01*/ 17) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$L(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$L(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*showPopUp*/ 4) set_data_dev(t5, /*showPopUp*/ ctx[2]);

    			if (dirty & /*showNext*/ 2) {
    				set_style(h5, "display", /*showNext*/ ctx[1]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$S.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$S($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MS_I12", slots, []);
    	let task01 = taskOne$G();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		if (answer == task01.answer) {
    			$$invalidate(2, showPopUp = randomCorrect());
    			$$invalidate(1, showNext = "inline-block");
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(2, showPopUp = randomWrong());
    			$$invalidate(1, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		showSolution = false;
    		answer = null;
    		$$invalidate(0, task01 = taskOne$G());
    		$$invalidate(1, showNext = "none");
    	};

    	const handleClick = parameter => () => {
    		answer = parameter;
    		CheckAnswer();
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MS_I12> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$G,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		handleClick
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) answer = $$props.answer;
    		if ("showNext" in $$props) $$invalidate(1, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(2, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) CheckAnswer = $$props.CheckAnswer;
    		if ("NextQuestion" in $$props) $$invalidate(3, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [task01, showNext, showPopUp, NextQuestion, handleClick];
    }

    class G1_MS_I12 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$S, create_fragment$S, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MS_I12",
    			options,
    			id: create_fragment$S.name
    		});
    	}
    }

    let task01$F = {
      heading: "Related addition facts",
      question: "Which is the related addition fact for ",
      questionValue : 0,
      valueArray: [],
      answer: 0,
      randomAnswer: 0,
      solutionArray : [],
      columns: 0,
    };

    const maxValue$s = 10;
    const minValue$s = 1;
    const findInMaxNumber$4 = 10;
    const showbtn$1 = 4;

    function taskOne$F() {
      task01$F.questionValue = Math.floor(Math.random() * (maxValue$s - minValue$s + 1)) + minValue$s;
      
      task01$F.valueArray = [];
      task01$F.columns = 2;
      
      let opts = [];
      let ans = [];
      for (let i = 0; i < findInMaxNumber$4; i++) {
        for (let j = 0; j < findInMaxNumber$4; j++) {
          let a = i+"-"+j;
          if (task01$F.questionValue == (i - j)) {          
              ans.push(a);
          }else {
            opts.push(a);
          }
        }    
      }

      task01$F.valueArray = randomArrayNumbers(showbtn$1,opts.length,0,opts);

      task01$F.question = "Which is the related addition fact for "+ans[Math.floor(Math.random() * ans.length)]+"?";
      task01$F.answer = ans[Math.floor(Math.random() * ans.length)];
      
      let tempNum = Math.floor(Math.random() * task01$F.valueArray.length);
      task01$F.valueArray[tempNum] = task01$F.answer; 
      task01$F.solutionArray =  task01$F.answer.split('-');  
      task01$F.randomAnswer = Math.floor(Math.random() * task01$F.valueArray.length);
      task01$F.answer = tempNum; 
      return task01$F;

    }

    /* src/components/taskComponents/G1_MS_I13.svelte generated by Svelte v3.37.0 */
    const file$Q = "src/components/taskComponents/G1_MS_I13.svelte";

    function get_each_context$K(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (65:16) {#each task01.valueArray as value,i}
    function create_each_block$K(ctx) {
    	let button;
    	let t_value = /*value*/ ctx[8] + "";
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "class", "btn toggle-btn ");
    			add_location(button, file$Q, 66, 16, 1405);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleClick*/ ctx[5](/*i*/ ctx[10]), false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*value*/ ctx[8] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$K.name,
    		type: "each",
    		source: "(65:16) {#each task01.valueArray as value,i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$R(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let t4;
    	let h6;
    	let t5;
    	let t6_value = /*task01*/ ctx[0].answer + "";
    	let t6;
    	let t7;
    	let div3;
    	let h5;
    	let t8;
    	let t9;
    	let div4;
    	let button0;
    	let t11;
    	let button1;
    	let t13;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$K(get_each_context$K(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			h6 = element("h6");
    			t5 = text("answer ");
    			t6 = text(t6_value);
    			t7 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t8 = text(/*showPopUp*/ ctx[2]);
    			t9 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t11 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t13 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$Q, 53, 10, 1082);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$Q, 52, 6, 1032);
    			add_location(h4, file$Q, 60, 12, 1260);
    			add_location(h6, file$Q, 69, 20, 1546);
    			add_location(div1, file$Q, 62, 12, 1305);
    			add_location(div2, file$Q, 57, 8, 1239);
    			set_style(h5, "display", /*showNext*/ ctx[1]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$Q, 74, 12, 1654);
    			add_location(div3, file$Q, 73, 8, 1636);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$Q, 79, 12, 1801);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$Q, 80, 12, 1897);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$Q, 81, 12, 1993);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$Q, 78, 8, 1770);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$Q, 56, 6, 1167);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$Q, 51, 5, 984);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$Q, 50, 1, 950);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, h6);
    			append_dev(h6, t5);
    			append_dev(h6, t6);
    			append_dev(div5, t7);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t11);
    			append_dev(div4, button1);
    			append_dev(div4, t13);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[3], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[4], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*handleClick, task01*/ 33) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$K(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$K(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, t4);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*task01*/ 1 && t6_value !== (t6_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*showPopUp*/ 4) set_data_dev(t8, /*showPopUp*/ ctx[2]);

    			if (dirty & /*showNext*/ 2) {
    				set_style(h5, "display", /*showNext*/ ctx[1]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$R.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$R($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MS_I13", slots, []);
    	let task01 = taskOne$F();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(1, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(2, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(2, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		answer = null;
    		$$invalidate(0, task01 = taskOne$F());
    		showSolution = false;
    		$$invalidate(1, showNext = "none");
    	};

    	const handleClick = parameter => () => {
    		answer = parameter;
    		CheckAnswer();
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MS_I13> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$F,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		handleClick
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) answer = $$props.answer;
    		if ("showNext" in $$props) $$invalidate(1, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(2, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(3, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(4, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [task01, showNext, showPopUp, CheckAnswer, NextQuestion, handleClick];
    }

    class G1_MS_I13 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$R, create_fragment$R, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MS_I13",
    			options,
    			id: create_fragment$R.name
    		});
    	}
    }

    let task01$E = {
        heading: "Addition sentences: true or false?",
        question: "Here are the ways to make 4. Find the pattern and type the missing addition number sentence.",
        questionValue : 0,
        valueArray: [],
        answer: 0,
        randomAnswer: 0,
        columns: 0,
        solutionArray : [],
        isTrue : true
      };
      
      const maxValue$r = 10;
      const minValue$r = 1;
      const findInMaxNumber$3 = 10;
      function taskOne$E() {
        task01$E.questionValue = Math.floor(Math.random() * (maxValue$r - minValue$r + 1)) + minValue$r;
        task01$E.isTrue = Boolean(Math.round(Math.random()));
        task01$E.question = "Which sentence is "+ task01$E.isTrue+ "?";    
        task01$E.valueArray = [];
        task01$E.solutionArray = [];
        task01$E.columns = 2;
        let temparry = [];
        for (let i = 0; i < findInMaxNumber$3; i++) {
          for (let j = 0; j < findInMaxNumber$3; j++) {
            if (task01$E.questionValue == (i - j)) {
              let a = i+"-"+j+"="+(i-j);
              temparry.push(a);
            }
          }
        }
      
        task01$E.randomAnswer = Math.floor(Math.random() * temparry.length);
        task01$E.valueArray [0] =  temparry[task01$E.randomAnswer];
        task01$E.valueArray [1] =  Math.floor(Math.random() * maxValue$r)+"-"+Math.floor(Math.random() * maxValue$r)+"="+(task01$E.questionValue);
        if(task01$E.isTrue){
            task01$E.answer =  0;
        }else {
            task01$E.answer =  1;
        }
        let tempnum = task01$E.valueArray [0].split('=');
        task01$E.solutionArray =  tempnum[0].split('+');
        console.log(task01$E.solutionArray);
        return task01$E;
      }

    /* src/components/taskComponents/G1_MS_I14.svelte generated by Svelte v3.37.0 */
    const file$P = "src/components/taskComponents/G1_MS_I14.svelte";

    function get_each_context$J(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (65:16) {#each task01.valueArray as value,i}
    function create_each_block$J(ctx) {
    	let button;
    	let t_value = /*value*/ ctx[8] + "";
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "class", "btn toggle-btn ");
    			add_location(button, file$P, 66, 16, 1407);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleClick*/ ctx[5](/*i*/ ctx[10]), false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*value*/ ctx[8] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$J.name,
    		type: "each",
    		source: "(65:16) {#each task01.valueArray as value,i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$Q(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let t4;
    	let h6;
    	let t5;
    	let t6_value = /*task01*/ ctx[0].answer + "";
    	let t6;
    	let t7;
    	let div3;
    	let h5;
    	let t8;
    	let t9;
    	let div4;
    	let button0;
    	let t11;
    	let button1;
    	let t13;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$J(get_each_context$J(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			h6 = element("h6");
    			t5 = text("answer ");
    			t6 = text(t6_value);
    			t7 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t8 = text(/*showPopUp*/ ctx[2]);
    			t9 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t11 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t13 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$P, 53, 10, 1084);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$P, 52, 6, 1034);
    			add_location(h4, file$P, 60, 12, 1262);
    			add_location(h6, file$P, 69, 20, 1548);
    			add_location(div1, file$P, 62, 12, 1307);
    			add_location(div2, file$P, 57, 8, 1241);
    			set_style(h5, "display", /*showNext*/ ctx[1]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$P, 74, 12, 1656);
    			add_location(div3, file$P, 73, 8, 1638);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$P, 81, 12, 1822);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$P, 82, 12, 1918);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$P, 83, 12, 2014);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$P, 80, 9, 1791);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$P, 56, 6, 1169);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$P, 51, 5, 986);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$P, 50, 1, 952);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, h6);
    			append_dev(h6, t5);
    			append_dev(h6, t6);
    			append_dev(div5, t7);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t11);
    			append_dev(div4, button1);
    			append_dev(div4, t13);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[3], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[4], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*handleClick, task01*/ 33) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$J(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$J(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, t4);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*task01*/ 1 && t6_value !== (t6_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*showPopUp*/ 4) set_data_dev(t8, /*showPopUp*/ ctx[2]);

    			if (dirty & /*showNext*/ 2) {
    				set_style(h5, "display", /*showNext*/ ctx[1]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Q($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MS_I14", slots, []);
    	let task01 = taskOne$E();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(1, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(2, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(2, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		answer = null;
    		$$invalidate(0, task01 = taskOne$E());
    		showSolution = false;
    		$$invalidate(1, showNext = "none");
    	};

    	const handleClick = parameter => () => {
    		answer = parameter;
    		CheckAnswer();
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MS_I14> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$E,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		handleClick
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) answer = $$props.answer;
    		if ("showNext" in $$props) $$invalidate(1, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(2, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(3, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(4, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [task01, showNext, showPopUp, CheckAnswer, NextQuestion, handleClick];
    }

    class G1_MS_I14 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Q, create_fragment$Q, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MS_I14",
    			options,
    			id: create_fragment$Q.name
    		});
    	}
    }

    /* src/components/taskComponents/G1_MS_I5.svelte generated by Svelte v3.37.0 */
    const file$O = "src/components/taskComponents/G1_MS_I5.svelte";

    function get_each_context$I(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	child_ctx[15] = i;
    	return child_ctx;
    }

    function get_each_context_2$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	child_ctx[19] = list;
    	child_ctx[20] = i;
    	return child_ctx;
    }

    function get_each_context_1$a(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	child_ctx[17] = list;
    	child_ctx[18] = i;
    	return child_ctx;
    }

    // (87:27) {:else}
    function create_else_block_1$3(ctx) {
    	let tr;
    	let t;
    	let each_value_2 = /*value*/ ctx[13];
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$4(get_each_context_2$4(ctx, each_value_2, i));
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			attr_dev(tr, "class", "tablerow");
    			add_location(tr, file$O, 87, 27, 2606);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			append_dev(tr, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*answer, task01*/ 3) {
    				each_value_2 = /*value*/ ctx[13];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$4(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_2$4(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, t);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_2.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$3.name,
    		type: "else",
    		source: "(87:27) {:else}",
    		ctx
    	});

    	return block;
    }

    // (75:23) {#if i == (task01.displayValues.length-1)}
    function create_if_block$F(ctx) {
    	let hr;
    	let t0;
    	let tr;
    	let t1;
    	let each_value_1 = /*value*/ ctx[13];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$a(get_each_context_1$a(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			hr = element("hr");
    			t0 = space();
    			tr = element("tr");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			add_location(hr, file$O, 75, 23, 2025);
    			attr_dev(tr, "class", "tablerow");
    			add_location(tr, file$O, 76, 23, 2053);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, hr, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, tr, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*answer, task01*/ 3) {
    				each_value_1 = /*value*/ ctx[13];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$a(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$a(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, t1);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(hr);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(tr);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$F.name,
    		type: "if",
    		source: "(75:23) {#if i == (task01.displayValues.length-1)}",
    		ctx
    	});

    	return block;
    }

    // (93:28) {:else}
    function create_else_block_2$3(ctx) {
    	let td;
    	let t_value = /*val*/ ctx[16] + "";
    	let t;

    	const block = {
    		c: function create() {
    			td = element("td");
    			t = text(t_value);
    			attr_dev(td, "align", "right");
    			add_location(td, file$O, 93, 32, 2953);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*val*/ ctx[16] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$3.name,
    		type: "else",
    		source: "(93:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (91:28) {#if val[0] == 'i'}
    function create_if_block_2$8(ctx) {
    	let td;
    	let input;
    	let mounted;
    	let dispose;

    	function input_input_handler_1() {
    		/*input_input_handler_1*/ ctx[7].call(input, /*val*/ ctx[16]);
    	}

    	const block = {
    		c: function create() {
    			td = element("td");
    			input = element("input");
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "style", " width : 30px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$O, 91, 46, 2772);
    			attr_dev(td, "align", "right");
    			add_location(td, file$O, 91, 28, 2754);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, input);
    			set_input_value(input, /*answer*/ ctx[1][/*val*/ ctx[16][1]]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler_1);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*answer, task01*/ 3 && input.value !== /*answer*/ ctx[1][/*val*/ ctx[16][1]]) {
    				set_input_value(input, /*answer*/ ctx[1][/*val*/ ctx[16][1]]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$8.name,
    		type: "if",
    		source: "(91:28) {#if val[0] == 'i'}",
    		ctx
    	});

    	return block;
    }

    // (89:28) {#each value as val}
    function create_each_block_2$4(ctx) {
    	let if_block_anchor;

    	function select_block_type_2(ctx, dirty) {
    		if (/*val*/ ctx[16][0] == "i") return create_if_block_2$8;
    		return create_else_block_2$3;
    	}

    	let current_block_type = select_block_type_2(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$4.name,
    		type: "each",
    		source: "(89:28) {#each value as val}",
    		ctx
    	});

    	return block;
    }

    // (82:24) {:else}
    function create_else_block$F(ctx) {
    	let td;
    	let t_value = /*val*/ ctx[16] + "";
    	let t;

    	const block = {
    		c: function create() {
    			td = element("td");
    			t = text(t_value);
    			attr_dev(td, "align", "right");
    			add_location(td, file$O, 82, 28, 2403);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*val*/ ctx[16] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$F.name,
    		type: "else",
    		source: "(82:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (80:24) {#if val[0] == 'i'}
    function create_if_block_1$8(ctx) {
    	let td;
    	let input;
    	let mounted;
    	let dispose;

    	function input_input_handler() {
    		/*input_input_handler*/ ctx[6].call(input, /*val*/ ctx[16]);
    	}

    	const block = {
    		c: function create() {
    			td = element("td");
    			input = element("input");
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "style", " width : 30px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$O, 80, 42, 2230);
    			attr_dev(td, "align", "right");
    			add_location(td, file$O, 80, 24, 2212);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, input);
    			set_input_value(input, /*answer*/ ctx[1][/*val*/ ctx[16][1]]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*answer, task01*/ 3 && input.value !== /*answer*/ ctx[1][/*val*/ ctx[16][1]]) {
    				set_input_value(input, /*answer*/ ctx[1][/*val*/ ctx[16][1]]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$8.name,
    		type: "if",
    		source: "(80:24) {#if val[0] == 'i'}",
    		ctx
    	});

    	return block;
    }

    // (78:24) {#each value as val}
    function create_each_block_1$a(ctx) {
    	let if_block_anchor;

    	function select_block_type_1(ctx, dirty) {
    		if (/*val*/ ctx[16][0] == "i") return create_if_block_1$8;
    		return create_else_block$F;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$a.name,
    		type: "each",
    		source: "(78:24) {#each value as val}",
    		ctx
    	});

    	return block;
    }

    // (73:20) {#each task01.displayValues as value , i}
    function create_each_block$I(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[15] == /*task01*/ ctx[0].displayValues.length - 1) return create_if_block$F;
    		return create_else_block_1$3;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$I.name,
    		type: "each",
    		source: "(73:20) {#each task01.displayValues as value , i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$P(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h20;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h21;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let div3;
    	let h5;
    	let t5;
    	let t6;
    	let div4;
    	let button0;
    	let t8;
    	let button1;
    	let t10;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].displayValues;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$I(get_each_context$I(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h20 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h21 = element("h2");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t5 = text(/*showPopUp*/ ctx[3]);
    			t6 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t8 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t10 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h20, "class", "text-center display-4 mb-0");
    			add_location(h20, file$O, 62, 10, 1515);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$O, 61, 6, 1465);
    			add_location(h21, file$O, 67, 12, 1691);
    			attr_dev(table, "width", "100");
    			add_location(table, file$O, 70, 16, 1771);
    			add_location(div1, file$O, 68, 12, 1730);
    			add_location(div2, file$O, 66, 8, 1672);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$O, 105, 12, 3283);
    			add_location(div3, file$O, 104, 8, 3265);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$O, 111, 12, 3422);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$O, 112, 12, 3518);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$O, 113, 12, 3614);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$O, 110, 8, 3391);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$O, 65, 6, 1600);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$O, 60, 5, 1417);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$O, 59, 1, 1383);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h20);
    			append_dev(h20, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h21);
    			append_dev(h21, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div5, t4);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t5);
    			append_dev(div5, t6);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t8);
    			append_dev(div4, button1);
    			append_dev(div4, t10);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01, answer*/ 3) {
    				each_value = /*task01*/ ctx[0].displayValues;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$I(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$I(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*showPopUp*/ 8) set_data_dev(t5, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$P.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const max$b = 9;
    const min$b = 0;
    const maxInputs$3 = 1;
    const numberofColumn$b = 2;

    function instance$P($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MS_I5", slots, []);
    	let question = "Subtract:";
    	let heading = "Complete the addition sentence - sums up to 10";
    	let showSolution = false;
    	let maxandmin = MaxandMin$2(max$b, min$b, numberofColumn$b, heading, question, maxInputs$3);
    	let task01 = taskOne$K();
    	let answer = [];
    	let showNext = "none";
    	let showPopUp;
    	let tempString = "";

    	let CheckAnswer = function () {
    		for (let index = 0; index < task01.answer.length; index++) {
    			if (answer[index] != task01.answer[index]) {
    				$$invalidate(3, showPopUp = randomWrong());
    				$$invalidate(2, showNext = "inline-block");
    				showSolution = true;
    				return;
    			} else {
    				$$invalidate(3, showPopUp = randomCorrect());
    				$$invalidate(2, showNext = "inline-block");
    			}
    		}
    	};

    	let NextQuestion = function () {
    		showSolution = false;
    		$$invalidate(1, answer = []);
    		$$invalidate(0, task01 = taskOne$K());
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MS_I5> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler(val) {
    		answer[val[1]] = this.value;
    		$$invalidate(1, answer);
    		$$invalidate(0, task01);
    	}

    	function input_input_handler_1(val) {
    		answer[val[1]] = this.value;
    		$$invalidate(1, answer);
    		$$invalidate(0, task01);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$K,
    		randomCorrect,
    		randomWrong,
    		MaxandMin: MaxandMin$2,
    		question,
    		heading,
    		max: max$b,
    		min: min$b,
    		maxInputs: maxInputs$3,
    		numberofColumn: numberofColumn$b,
    		showSolution,
    		maxandmin,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		tempString,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("question" in $$props) question = $$props.question;
    		if ("heading" in $$props) heading = $$props.heading;
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("maxandmin" in $$props) maxandmin = $$props.maxandmin;
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("tempString" in $$props) tempString = $$props.tempString;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler,
    		input_input_handler_1
    	];
    }

    class G1_MS_I5 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$P, create_fragment$P, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MS_I5",
    			options,
    			id: create_fragment$P.name
    		});
    	}
    }

    let task01$D = {
      heading: "Make a number using addition - sums up to 10",
      question: "John is building a cabinet. He needs 2 one-inch bolts and 3 one-and-a-half inch bolts. How many bolts in all does John need?",
      questionValue : 0,
      valueArray: [],
      answer: 0,
      randomAnswer: 0,
      displayBtn : [],
      columns: 0
    };

    const maxValue$q = 10;
    const minValue$q = 1;
    const findInMaxNumber$2 = 10;
    const showbtn = 4;

    function taskOne$D() {
      task01$D.answer = Math.floor(Math.random() * (maxValue$q - minValue$q + 1)) + minValue$q;
      task01$D.valueArray = [];
      task01$D.columns = 2;
      let ans = [];
      for (let i = 0; i < findInMaxNumber$2; i++) {
        for (let j = 0; j < findInMaxNumber$2; j++) {
          let a = i+"-"+j;
          if (task01$D.answer == (i - j)) {          
              ans.push(a);
          }
        }    
      }  

      task01$D.valueArray = ans[Math.floor(Math.random() * ans.length)].split('-');
      task01$D.question = "Rick has "+task01$D.valueArray[0]+" toys in his toy box. One day, he knocks the toy box over and "+task01$D.valueArray[1]+" toys spill onto the floor. How many toys are still in the box?";
      task01$D.displayBtn = randomNumbers$3(showbtn,maxValue$q,minValue$q);
      if(!task01$D.displayBtn.includes(task01$D.answer)){      
        let tempnum = Math.floor(Math.random() * task01$D.displayBtn.length);
        task01$D.displayBtn[tempnum] = task01$D.answer;
      }
      return task01$D;
    }

    /* src/components/taskComponents/G1_MS_I6.svelte generated by Svelte v3.37.0 */
    const file$N = "src/components/taskComponents/G1_MS_I6.svelte";

    function get_each_context$H(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	return child_ctx;
    }

    // (56:20) {#each task01.displayBtn as value}
    function create_each_block$H(ctx) {
    	let button;
    	let t_value = /*value*/ ctx[8] + "";
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "class", "btn toggle-btn ");
    			add_location(button, file$N, 56, 20, 1483);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(
    					button,
    					"click",
    					function () {
    						if (is_function(/*handleClick*/ ctx[7](/*value*/ ctx[8]))) /*handleClick*/ ctx[7](/*value*/ ctx[8]).apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*value*/ ctx[8] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$H.name,
    		type: "each",
    		source: "(56:20) {#each task01.displayBtn as value}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$O(ctx) {
    	let div8;
    	let div7;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div6;
    	let div3;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div2;
    	let div1;
    	let t4;
    	let h6;
    	let t5;
    	let t6_value = /*task01*/ ctx[0].answer + "";
    	let t6;
    	let t7;
    	let div4;
    	let h5;
    	let t8;
    	let t9;
    	let solution;
    	let t10;
    	let div5;
    	let button0;
    	let t12;
    	let button1;
    	let t14;
    	let button2;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].displayBtn;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$H(get_each_context$H(ctx, each_value, i));
    	}

    	solution = new AdditionSolution({
    			props: {
    				num_qnty: /*task01*/ ctx[0].columns,
    				usr_resp: /*answer*/ ctx[1],
    				num: /*task01*/ ctx[0].valueArray,
    				ans_submit: /*showSolution*/ ctx[4],
    				answerchange: /*task01*/ ctx[0].answer
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div8 = element("div");
    			div7 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div6 = element("div");
    			div3 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div2 = element("div");
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			h6 = element("h6");
    			t5 = text("answer ");
    			t6 = text(t6_value);
    			t7 = space();
    			div4 = element("div");
    			h5 = element("h5");
    			t8 = text(/*showPopUp*/ ctx[3]);
    			t9 = space();
    			create_component(solution.$$.fragment);
    			t10 = space();
    			div5 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t12 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t14 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$N, 47, 10, 1162);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$N, 46, 6, 1112);
    			add_location(h4, file$N, 52, 12, 1338);
    			add_location(div1, file$N, 54, 16, 1401);
    			add_location(h6, file$N, 61, 16, 1690);
    			add_location(div2, file$N, 53, 12, 1377);
    			add_location(div3, file$N, 51, 8, 1319);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$N, 67, 12, 1807);
    			add_location(div4, file$N, 66, 8, 1789);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$N, 72, 12, 2082);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$N, 73, 12, 2178);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$N, 74, 12, 2274);
    			attr_dev(div5, "class", "mt-3");
    			add_location(div5, file$N, 71, 8, 2051);
    			attr_dev(div6, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div6, file$N, 50, 6, 1247);
    			attr_dev(div7, "class", "shadow-sm  bg-white rounded");
    			add_location(div7, file$N, 45, 5, 1064);
    			attr_dev(div8, "class", "container mt-5");
    			add_location(div8, file$N, 44, 1, 1030);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div8, anchor);
    			append_dev(div8, div7);
    			append_dev(div7, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div7, t1);
    			append_dev(div7, div6);
    			append_dev(div6, div3);
    			append_dev(div3, h4);
    			append_dev(h4, t2);
    			append_dev(div3, t3);
    			append_dev(div3, div2);
    			append_dev(div2, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			append_dev(div2, t4);
    			append_dev(div2, h6);
    			append_dev(h6, t5);
    			append_dev(h6, t6);
    			append_dev(div6, t7);
    			append_dev(div6, div4);
    			append_dev(div4, h5);
    			append_dev(h5, t8);
    			append_dev(div6, t9);
    			mount_component(solution, div6, null);
    			append_dev(div6, t10);
    			append_dev(div6, div5);
    			append_dev(div5, button0);
    			append_dev(div5, t12);
    			append_dev(div5, button1);
    			append_dev(div5, t14);
    			append_dev(div5, button2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*task01*/ 1) && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*task01*/ 1) && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*handleClick, task01*/ 129) {
    				each_value = /*task01*/ ctx[0].displayBtn;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$H(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$H(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if ((!current || dirty & /*task01*/ 1) && t6_value !== (t6_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t6, t6_value);
    			if (!current || dirty & /*showPopUp*/ 8) set_data_dev(t8, /*showPopUp*/ ctx[3]);

    			if (!current || dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}

    			const solution_changes = {};
    			if (dirty & /*task01*/ 1) solution_changes.num_qnty = /*task01*/ ctx[0].columns;
    			if (dirty & /*answer*/ 2) solution_changes.usr_resp = /*answer*/ ctx[1];
    			if (dirty & /*task01*/ 1) solution_changes.num = /*task01*/ ctx[0].valueArray;
    			if (dirty & /*showSolution*/ 16) solution_changes.ans_submit = /*showSolution*/ ctx[4];
    			if (dirty & /*task01*/ 1) solution_changes.answerchange = /*task01*/ ctx[0].answer;
    			solution.$set(solution_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div8);
    			destroy_each(each_blocks, detaching);
    			destroy_component(solution);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$O.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$O($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MS_I6", slots, []);
    	let task01 = taskOne$D();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			$$invalidate(2, showNext = "inline-block");
    			return;
    		} else {
    			$$invalidate(4, showSolution = true);
    			$$invalidate(3, showPopUp = randomWrong());
    			$$invalidate(2, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(4, showSolution = false);
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$D());
    		$$invalidate(2, showNext = "none");
    	};

    	const handleClick = parameter => () => {
    		$$invalidate(1, answer = parameter);
    		CheckAnswer();
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MS_I6> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$D,
    		randomCorrect,
    		randomWrong,
    		Solution: AdditionSolution,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		handleClick
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) $$invalidate(4, showSolution = $$props.showSolution);
    		if ("CheckAnswer" in $$props) $$invalidate(5, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(6, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		handleClick
    	];
    }

    class G1_MS_I6 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$O, create_fragment$O, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MS_I6",
    			options,
    			id: create_fragment$O.name
    		});
    	}
    }

    let task01$C = {
      heading : "",
      question: "",
      valueArray: [], 
      answer: 0, 
      operator: "-",
      columns: 0
    };


    const maxValue$p = 10;
    const minValue$p = 1;

    function taskOne$C() {
      task01$C.heading = "Subtract doubles";
      task01$C.question = "Subtract:";
      task01$C.answer = 0;
      task01$C.columns = 2;
      task01$C.valueArray = [];
      task01$C.valueArray[1] = Math.floor(Math.random() * (maxValue$p - minValue$p + 1) ) + minValue$p;   
      task01$C.valueArray[0] = task01$C.valueArray[1] * 2;  

      task01$C.answer = task01$C.valueArray[1];

      return task01$C;
    }

    /* src/components/taskComponents/G2_MS_F4.svelte generated by Svelte v3.37.0 */
    const file$M = "src/components/taskComponents/G2_MS_F4.svelte";

    function get_each_context$G(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (62:28) {:else}
    function create_else_block$E(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[8] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$M, 63, 32, 1702);
    			add_location(tr, file$M, 62, 28, 1665);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[8] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$E.name,
    		type: "else",
    		source: "(62:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (58:28) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$E(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[8] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$M, 59, 50, 1498);
    			attr_dev(td, "align", "right");
    			add_location(td, file$M, 59, 32, 1480);
    			add_location(tr, file$M, 58, 28, 1443);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[8] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$E.name,
    		type: "if",
    		source: "(58:28) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (57:24) {#each task01.valueArray as col, i }
    function create_each_block$G(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[10] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$E;
    		return create_else_block$E;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$G.name,
    		type: "each",
    		source: "(57:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$N(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$G(get_each_context$G(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$M, 43, 10, 968);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$M, 42, 6, 918);
    			add_location(h4, file$M, 50, 12, 1146);
    			attr_dev(table, "width", "100");
    			add_location(table, file$M, 54, 16, 1218);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$M, 68, 20, 1895);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$M, 69, 20, 1990);
    			add_location(h6, file$M, 70, 20, 2112);
    			add_location(div1, file$M, 52, 12, 1191);
    			add_location(div2, file$M, 47, 8, 1125);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$M, 75, 12, 2220);
    			add_location(div3, file$M, 74, 8, 2202);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$M, 79, 12, 2357);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$M, 80, 12, 2453);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$M, 81, 12, 2549);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$M, 78, 8, 2326);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$M, 46, 6, 1053);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$M, 41, 5, 870);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$M, 40, 1, 836);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t13);
    			append_dev(div4, button1);
    			append_dev(div4, t15);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$G(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$G(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$N.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$N($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G2_MS_F4", slots, []);
    	let task01 = taskOne$C();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$C());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G2_MS_F4> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$C,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G2_MS_F4 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$N, create_fragment$N, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G2_MS_F4",
    			options,
    			id: create_fragment$N.name
    		});
    	}
    }

    let task01$B = {
      heading : "",
      question: "",
      valueArray: [], 
      answer: 0, 
      operator: "-",
      columns: 0
    };

    let columns$1 = 2;
    let maxValue$o = 18;
    let minValue$o = 1;




    function taskOne$B() {
      task01$B.heading = "Subtraction with pictures";
      task01$B.question = "Subtract: ";
      task01$B.answer = 0;
      task01$B.columns = columns$1;
      task01$B.valueArray = [];
      
      for (let i = 0; i < columns$1; i++) {
        task01$B.valueArray[i] = Math.floor(Math.random() * (maxValue$o - minValue$o + 1) ) + minValue$o;   
      }

      task01$B.valueArray = task01$B.valueArray.sort((a, b) => b - a);
      task01$B.answer = task01$B.valueArray[0];
      for (let index = 1; index < task01$B.valueArray.length; index++) {
        task01$B.answer -= task01$B.valueArray[index];
      }
      console.log(task01$B.valueArray.sort((a, b) => b - a));
      return task01$B;
    }

    /* src/components/taskComponents/G2_MS_F6.svelte generated by Svelte v3.37.0 */
    const file$L = "src/components/taskComponents/G2_MS_F6.svelte";

    function get_each_context$F(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (64:28) {:else}
    function create_else_block$D(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[8] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$L, 65, 32, 1750);
    			add_location(tr, file$L, 64, 28, 1713);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[8] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$D.name,
    		type: "else",
    		source: "(64:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (60:28) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$D(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[8] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$L, 61, 50, 1546);
    			attr_dev(td, "align", "right");
    			add_location(td, file$L, 61, 32, 1528);
    			add_location(tr, file$L, 60, 28, 1491);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[8] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$D.name,
    		type: "if",
    		source: "(60:28) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (59:24) {#each task01.valueArray as col, i }
    function create_each_block$F(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[10] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$D;
    		return create_else_block$D;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$F.name,
    		type: "each",
    		source: "(59:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$M(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$F(get_each_context$F(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$L, 45, 10, 1016);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$L, 44, 6, 966);
    			add_location(h4, file$L, 52, 12, 1194);
    			attr_dev(table, "width", "100");
    			add_location(table, file$L, 56, 16, 1266);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$L, 70, 20, 1943);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$L, 71, 20, 2038);
    			add_location(h6, file$L, 72, 20, 2160);
    			add_location(div1, file$L, 54, 12, 1239);
    			add_location(div2, file$L, 49, 8, 1173);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$L, 77, 12, 2268);
    			add_location(div3, file$L, 76, 8, 2250);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$L, 81, 12, 2405);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$L, 82, 12, 2501);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$L, 83, 12, 2597);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$L, 80, 8, 2374);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$L, 48, 6, 1101);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$L, 43, 5, 918);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$L, 42, 1, 884);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t13);
    			append_dev(div4, button1);
    			append_dev(div4, t15);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$F(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$F(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$M.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$M($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G2_MS_F6", slots, []);
    	let task01 = taskOne$B();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$B());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G2_MS_F6> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$B,
    		randomCorrect,
    		randomWrong,
    		MaxandMin: MaxandMin$3,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G2_MS_F6 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$M, create_fragment$M, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G2_MS_F6",
    			options,
    			id: create_fragment$M.name
    		});
    	}
    }

    let task01$A = {
      heading : "Subtraction input/output tables - sums to 18",
      question: "Complete the table.",
      qstNum : 0,
      valueArray: [], 
      answer: [], 
      operator: "-",
      columns: 4,
      input : 0
    };

    const maxValue$n = 18;
    const minValue$n = 6;
    const tablesize$1 = 4;

    function taskOne$A() {

      task01$A.valueArray = [];
      task01$A.answer = []; 

       let displayBtn = randomNumbers$3(tablesize$1,maxValue$n,minValue$n);
       task01$A.qstNum =  Math.floor(Math.random() * 5);
       for(let i = 0 ; i < displayBtn.length;i++){
          task01$A.valueArray[i] = [displayBtn[i], displayBtn[i]-task01$A.qstNum];
          task01$A.answer[i] = [displayBtn[i]-task01$A.qstNum];
       }
       task01$A.input = Math.floor(Math.random() * task01$A.valueArray.length);
       for(let i = 0 ; i < displayBtn.length;i++){
         if(i != task01$A.input){
          task01$A.valueArray[i] = [displayBtn[i], ['i']];
         }
     }
      
      return task01$A;
    }

    /* src/components/taskComponents/G2_MS_F8.svelte generated by Svelte v3.37.0 */
    const file$K = "src/components/taskComponents/G2_MS_F8.svelte";

    function get_each_context$E(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[9] = list;
    	child_ctx[10] = i;
    	return child_ctx;
    }

    function get_each_context_1$9(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	return child_ctx;
    }

    // (72:32) {:else}
    function create_else_block$C(ctx) {
    	let td;
    	let t_value = /*a*/ ctx[11] + "";
    	let t;

    	const block = {
    		c: function create() {
    			td = element("td");
    			t = text(t_value);
    			attr_dev(td, "align", "right");
    			add_location(td, file$K, 72, 32, 2000);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*a*/ ctx[11] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$C.name,
    		type: "else",
    		source: "(72:32) {:else}",
    		ctx
    	});

    	return block;
    }

    // (70:32) {#if a == 'i'}
    function create_if_block$C(ctx) {
    	let td;
    	let input;
    	let mounted;
    	let dispose;

    	function input_input_handler() {
    		/*input_input_handler*/ ctx[6].call(input, /*i*/ ctx[10]);
    	}

    	const block = {
    		c: function create() {
    			td = element("td");
    			input = element("input");
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "style", " width : 30px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$K, 70, 50, 1823);
    			attr_dev(td, "align", "right");
    			add_location(td, file$K, 70, 32, 1805);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, input);
    			set_input_value(input, /*answer*/ ctx[1][/*i*/ ctx[10]]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1][/*i*/ ctx[10]]) {
    				set_input_value(input, /*answer*/ ctx[1][/*i*/ ctx[10]]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$C.name,
    		type: "if",
    		source: "(70:32) {#if a == 'i'}",
    		ctx
    	});

    	return block;
    }

    // (69:28) {#each col as a}
    function create_each_block_1$9(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*a*/ ctx[11] == "i") return create_if_block$C;
    		return create_else_block$C;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$9.name,
    		type: "each",
    		source: "(69:28) {#each col as a}",
    		ctx
    	});

    	return block;
    }

    // (67:24) {#each task01.valueArray as col, i }
    function create_each_block$E(ctx) {
    	let tr;
    	let t;
    	let each_value_1 = /*col*/ ctx[8];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$9(get_each_context_1$9(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			add_location(tr, file$K, 67, 24, 1650);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			append_dev(tr, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*answer, task01*/ 3) {
    				each_value_1 = /*col*/ ctx[8];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$9(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$9(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, t);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$E.name,
    		type: "each",
    		source: "(67:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$L(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h40;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let h41;
    	let t4;
    	let t5_value = /*task01*/ ctx[0].qstNum + "";
    	let t5;
    	let t6;
    	let table;
    	let t7;
    	let h6;
    	let t8;
    	let t9_value = /*task01*/ ctx[0].answer + "";
    	let t9;
    	let t10;
    	let div3;
    	let h5;
    	let t11;
    	let t12;
    	let div4;
    	let button0;
    	let t14;
    	let button1;
    	let t16;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$E(get_each_context$E(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h40 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			h41 = element("h4");
    			t4 = text("Rule: add ");
    			t5 = text(t5_value);
    			t6 = space();
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t7 = space();
    			h6 = element("h6");
    			t8 = text("answer ");
    			t9 = text(t9_value);
    			t10 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t11 = text(/*showPopUp*/ ctx[3]);
    			t12 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t14 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t16 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$K, 53, 10, 1200);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$K, 52, 6, 1150);
    			add_location(h40, file$K, 60, 12, 1378);
    			add_location(h41, file$K, 63, 16, 1449);
    			attr_dev(table, "width", "100");
    			add_location(table, file$K, 64, 16, 1500);
    			add_location(h6, file$K, 80, 20, 2294);
    			add_location(div1, file$K, 62, 12, 1423);
    			add_location(div2, file$K, 57, 8, 1357);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$K, 85, 12, 2402);
    			add_location(div3, file$K, 84, 8, 2384);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$K, 89, 12, 2540);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$K, 90, 12, 2636);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$K, 91, 12, 2732);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$K, 88, 8, 2509);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$K, 56, 6, 1285);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$K, 51, 5, 1102);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$K, 50, 1, 1068);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h40);
    			append_dev(h40, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, h41);
    			append_dev(h41, t4);
    			append_dev(h41, t5);
    			append_dev(div1, t6);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t7);
    			append_dev(div1, h6);
    			append_dev(h6, t8);
    			append_dev(h6, t9);
    			append_dev(div5, t10);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t11);
    			append_dev(div5, t12);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t14);
    			append_dev(div4, button1);
    			append_dev(div4, t16);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*task01*/ 1 && t5_value !== (t5_value = /*task01*/ ctx[0].qstNum + "")) set_data_dev(t5, t5_value);

    			if (dirty & /*task01, answer*/ 3) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$E(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$E(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*task01*/ 1 && t9_value !== (t9_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t9, t9_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t11, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$L.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$L($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G2_MS_F8", slots, []);
    	let task01 = taskOne$A();
    	let answer = [];
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		for (let index = 0; index < answer.length; index++) {
    			if (task01.input != index) {
    				if (answer[index] != task01.answer[index]) {
    					$$invalidate(3, showPopUp = randomWrong());
    					showSolution = true;
    					return;
    				} else {
    					$$invalidate(3, showPopUp = randomCorrect());
    				}
    			}
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = []);
    		$$invalidate(1, answer.length = task01.answer.length, answer);
    		$$invalidate(0, task01 = taskOne$A());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G2_MS_F8> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler(i) {
    		answer[i] = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$A,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G2_MS_F8 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$L, create_fragment$L, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G2_MS_F8",
    			options,
    			id: create_fragment$L.name
    		});
    	}
    }

    /* src/components/taskComponents/G2_MS_F10.svelte generated by Svelte v3.37.0 */
    const file$J = "src/components/taskComponents/G2_MS_F10.svelte";

    function create_fragment$K(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let input;
    	let t4;
    	let h6;
    	let t5;
    	let t6_value = /*task01*/ ctx[0].answer + "";
    	let t6;
    	let t7;
    	let div3;
    	let h5;
    	let t8;
    	let t9;
    	let div4;
    	let button0;
    	let t11;
    	let button1;
    	let t13;
    	let button2;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			input = element("input");
    			t4 = space();
    			h6 = element("h6");
    			t5 = text("answer ");
    			t6 = text(t6_value);
    			t7 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t8 = text(/*showPopUp*/ ctx[3]);
    			t9 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t11 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t13 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$J, 50, 10, 1276);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$J, 49, 6, 1226);
    			add_location(h4, file$J, 57, 12, 1454);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$J, 62, 20, 1531);
    			add_location(h6, file$J, 63, 20, 1653);
    			add_location(div1, file$J, 59, 12, 1499);
    			add_location(div2, file$J, 54, 8, 1433);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$J, 68, 12, 1761);
    			add_location(div3, file$J, 67, 8, 1743);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$J, 72, 12, 1898);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$J, 73, 12, 1994);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$J, 74, 12, 2090);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$J, 71, 8, 1867);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$J, 53, 6, 1361);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$J, 48, 5, 1178);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$J, 47, 1, 1144);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t4);
    			append_dev(div1, h6);
    			append_dev(h6, t5);
    			append_dev(h6, t6);
    			append_dev(div5, t7);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t11);
    			append_dev(div4, button1);
    			append_dev(div4, t13);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t6_value !== (t6_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t8, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$K.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const max$a = 18;
    const min$a = 0;
    const numberofColumn$a = 2;

    function instance$K($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G2_MS_F10", slots, []);
    	let heading = "Subtraction word problems - numbers up to 18";
    	let question = "Subtract.";
    	let maxandmin = MaxandMin$1(max$a, min$a, numberofColumn$a, heading, question);
    	let task01 = taskOne$I();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$I());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G2_MS_F10> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$I,
    		randomCorrect,
    		randomWrong,
    		MaxandMin: MaxandMin$1,
    		heading,
    		question,
    		max: max$a,
    		min: min$a,
    		numberofColumn: numberofColumn$a,
    		maxandmin,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("heading" in $$props) heading = $$props.heading;
    		if ("question" in $$props) question = $$props.question;
    		if ("maxandmin" in $$props) maxandmin = $$props.maxandmin;
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G2_MS_F10 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$K, create_fragment$K, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G2_MS_F10",
    			options,
    			id: create_fragment$K.name
    		});
    	}
    }

    /* src/components/taskComponents/G2_MS_F11.svelte generated by Svelte v3.37.0 */
    const file$I = "src/components/taskComponents/G2_MS_F11.svelte";

    function get_each_context$D(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	child_ctx[15] = i;
    	return child_ctx;
    }

    function get_each_context_2$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	child_ctx[19] = list;
    	child_ctx[20] = i;
    	return child_ctx;
    }

    function get_each_context_1$8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	child_ctx[17] = list;
    	child_ctx[18] = i;
    	return child_ctx;
    }

    // (87:27) {:else}
    function create_else_block_1$2(ctx) {
    	let tr;
    	let t;
    	let each_value_2 = /*value*/ ctx[13];
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$3(get_each_context_2$3(ctx, each_value_2, i));
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			attr_dev(tr, "class", "tablerow");
    			add_location(tr, file$I, 87, 27, 2607);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			append_dev(tr, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*answer, task01*/ 3) {
    				each_value_2 = /*value*/ ctx[13];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$3(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_2$3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, t);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_2.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$2.name,
    		type: "else",
    		source: "(87:27) {:else}",
    		ctx
    	});

    	return block;
    }

    // (75:23) {#if i == (task01.displayValues.length-1)}
    function create_if_block$B(ctx) {
    	let hr;
    	let t0;
    	let tr;
    	let t1;
    	let each_value_1 = /*value*/ ctx[13];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$8(get_each_context_1$8(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			hr = element("hr");
    			t0 = space();
    			tr = element("tr");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			add_location(hr, file$I, 75, 23, 2026);
    			attr_dev(tr, "class", "tablerow");
    			add_location(tr, file$I, 76, 23, 2054);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, hr, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, tr, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*answer, task01*/ 3) {
    				each_value_1 = /*value*/ ctx[13];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$8(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$8(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, t1);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(hr);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(tr);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$B.name,
    		type: "if",
    		source: "(75:23) {#if i == (task01.displayValues.length-1)}",
    		ctx
    	});

    	return block;
    }

    // (93:28) {:else}
    function create_else_block_2$2(ctx) {
    	let td;
    	let t_value = /*val*/ ctx[16] + "";
    	let t;

    	const block = {
    		c: function create() {
    			td = element("td");
    			t = text(t_value);
    			attr_dev(td, "align", "right");
    			add_location(td, file$I, 93, 32, 2954);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*val*/ ctx[16] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$2.name,
    		type: "else",
    		source: "(93:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (91:28) {#if val[0] == 'i'}
    function create_if_block_2$7(ctx) {
    	let td;
    	let input;
    	let mounted;
    	let dispose;

    	function input_input_handler_1() {
    		/*input_input_handler_1*/ ctx[7].call(input, /*val*/ ctx[16]);
    	}

    	const block = {
    		c: function create() {
    			td = element("td");
    			input = element("input");
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "style", " width : 30px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$I, 91, 46, 2773);
    			attr_dev(td, "align", "right");
    			add_location(td, file$I, 91, 28, 2755);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, input);
    			set_input_value(input, /*answer*/ ctx[1][/*val*/ ctx[16][1]]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler_1);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*answer, task01*/ 3 && input.value !== /*answer*/ ctx[1][/*val*/ ctx[16][1]]) {
    				set_input_value(input, /*answer*/ ctx[1][/*val*/ ctx[16][1]]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$7.name,
    		type: "if",
    		source: "(91:28) {#if val[0] == 'i'}",
    		ctx
    	});

    	return block;
    }

    // (89:28) {#each value as val}
    function create_each_block_2$3(ctx) {
    	let if_block_anchor;

    	function select_block_type_2(ctx, dirty) {
    		if (/*val*/ ctx[16][0] == "i") return create_if_block_2$7;
    		return create_else_block_2$2;
    	}

    	let current_block_type = select_block_type_2(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$3.name,
    		type: "each",
    		source: "(89:28) {#each value as val}",
    		ctx
    	});

    	return block;
    }

    // (82:24) {:else}
    function create_else_block$B(ctx) {
    	let td;
    	let t_value = /*val*/ ctx[16] + "";
    	let t;

    	const block = {
    		c: function create() {
    			td = element("td");
    			t = text(t_value);
    			attr_dev(td, "align", "right");
    			add_location(td, file$I, 82, 28, 2404);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*val*/ ctx[16] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$B.name,
    		type: "else",
    		source: "(82:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (80:24) {#if val[0] == 'i'}
    function create_if_block_1$7(ctx) {
    	let td;
    	let input;
    	let mounted;
    	let dispose;

    	function input_input_handler() {
    		/*input_input_handler*/ ctx[6].call(input, /*val*/ ctx[16]);
    	}

    	const block = {
    		c: function create() {
    			td = element("td");
    			input = element("input");
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "style", " width : 30px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$I, 80, 42, 2231);
    			attr_dev(td, "align", "right");
    			add_location(td, file$I, 80, 24, 2213);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, input);
    			set_input_value(input, /*answer*/ ctx[1][/*val*/ ctx[16][1]]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*answer, task01*/ 3 && input.value !== /*answer*/ ctx[1][/*val*/ ctx[16][1]]) {
    				set_input_value(input, /*answer*/ ctx[1][/*val*/ ctx[16][1]]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$7.name,
    		type: "if",
    		source: "(80:24) {#if val[0] == 'i'}",
    		ctx
    	});

    	return block;
    }

    // (78:24) {#each value as val}
    function create_each_block_1$8(ctx) {
    	let if_block_anchor;

    	function select_block_type_1(ctx, dirty) {
    		if (/*val*/ ctx[16][0] == "i") return create_if_block_1$7;
    		return create_else_block$B;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$8.name,
    		type: "each",
    		source: "(78:24) {#each value as val}",
    		ctx
    	});

    	return block;
    }

    // (73:20) {#each task01.displayValues as value , i}
    function create_each_block$D(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[15] == /*task01*/ ctx[0].displayValues.length - 1) return create_if_block$B;
    		return create_else_block_1$2;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$D.name,
    		type: "each",
    		source: "(73:20) {#each task01.displayValues as value , i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$J(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h20;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h21;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let div3;
    	let h5;
    	let t5;
    	let t6;
    	let div4;
    	let button0;
    	let t8;
    	let button1;
    	let t10;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].displayValues;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$D(get_each_context$D(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h20 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h21 = element("h2");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t5 = text(/*showPopUp*/ ctx[3]);
    			t6 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t8 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t10 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h20, "class", "text-center display-4 mb-0");
    			add_location(h20, file$I, 62, 10, 1516);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$I, 61, 6, 1466);
    			add_location(h21, file$I, 67, 12, 1692);
    			attr_dev(table, "width", "100");
    			add_location(table, file$I, 70, 16, 1772);
    			add_location(div1, file$I, 68, 12, 1731);
    			add_location(div2, file$I, 66, 8, 1673);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$I, 105, 12, 3284);
    			add_location(div3, file$I, 104, 8, 3266);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$I, 111, 12, 3423);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$I, 112, 12, 3519);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$I, 113, 12, 3615);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$I, 110, 8, 3392);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$I, 65, 6, 1601);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$I, 60, 5, 1418);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$I, 59, 1, 1384);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h20);
    			append_dev(h20, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h21);
    			append_dev(h21, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div5, t4);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t5);
    			append_dev(div5, t6);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t8);
    			append_dev(div4, button1);
    			append_dev(div4, t10);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01, answer*/ 3) {
    				each_value = /*task01*/ ctx[0].displayValues;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$D(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$D(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*showPopUp*/ 8) set_data_dev(t5, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$J.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const max$9 = 18;
    const min$9 = 0;
    const maxInputs$2 = 1;
    const numberofColumn$9 = 2;

    function instance$J($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G2_MS_F11", slots, []);
    	let question = "Subtract:";
    	let heading = "Complete the addition sentence - sums up to 18";
    	let showSolution = false;
    	let maxandmin = MaxandMin$2(max$9, min$9, numberofColumn$9, heading, question, maxInputs$2);
    	let task01 = taskOne$K();
    	let answer = [];
    	let showNext = "none";
    	let showPopUp;
    	let tempString = "";

    	let CheckAnswer = function () {
    		for (let index = 0; index < task01.answer.length; index++) {
    			if (answer[index] != task01.answer[index]) {
    				$$invalidate(3, showPopUp = randomWrong());
    				$$invalidate(2, showNext = "inline-block");
    				showSolution = true;
    				return;
    			} else {
    				$$invalidate(3, showPopUp = randomCorrect());
    				$$invalidate(2, showNext = "inline-block");
    			}
    		}
    	};

    	let NextQuestion = function () {
    		showSolution = false;
    		$$invalidate(1, answer = []);
    		$$invalidate(0, task01 = taskOne$K());
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G2_MS_F11> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler(val) {
    		answer[val[1]] = this.value;
    		$$invalidate(1, answer);
    		$$invalidate(0, task01);
    	}

    	function input_input_handler_1(val) {
    		answer[val[1]] = this.value;
    		$$invalidate(1, answer);
    		$$invalidate(0, task01);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$K,
    		randomCorrect,
    		randomWrong,
    		MaxandMin: MaxandMin$2,
    		question,
    		heading,
    		max: max$9,
    		min: min$9,
    		maxInputs: maxInputs$2,
    		numberofColumn: numberofColumn$9,
    		showSolution,
    		maxandmin,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		tempString,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("question" in $$props) question = $$props.question;
    		if ("heading" in $$props) heading = $$props.heading;
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("maxandmin" in $$props) maxandmin = $$props.maxandmin;
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("tempString" in $$props) tempString = $$props.tempString;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler,
    		input_input_handler_1
    	];
    }

    class G2_MS_F11 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$J, create_fragment$J, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G2_MS_F11",
    			options,
    			id: create_fragment$J.name
    		});
    	}
    }

    let task01$z = {
      heading : "Subtraction sentences for word problems - numbers up to 18",
      question: "",
      valueArray: [], 
      answer: 0, 
      operator: "-",
      columns: 0
    };


    let maxValue$m = 18;
    let minValue$m = 0;




    function taskOne$z() {

      task01$z.answer = "";
      task01$z.columns = 2;
      task01$z.valueArray = [];
      
      for (let i = 0; i < task01$z.columns; i++) {
        task01$z.valueArray[i] = Math.floor(Math.random() * (maxValue$m - minValue$m + 1) ) + minValue$m;   
      }

      task01$z.valueArray = task01$z.valueArray.sort((a, b) => b - a);
      task01$z.answer = task01$z.valueArray[0] +'-'+task01$z.valueArray[1]+'='+(task01$z.valueArray[0] - task01$z.valueArray[1]);
      task01$z.question = task01$z.valueArray[1] + " of the pairs of shoes in a shoe store are black. There are "+task01$z.valueArray[0]+" pairs of shoes in the store in all.  How many of the pairs of shoes are not black?";
      console.log(task01$z.valueArray.sort((a, b) => b - a));
      return task01$z;
    }

    /* src/components/taskComponents/G2_MS_F12.svelte generated by Svelte v3.37.0 */
    const file$H = "src/components/taskComponents/G2_MS_F12.svelte";

    function create_fragment$I(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let input;
    	let t4;
    	let h6;
    	let t5;
    	let t6_value = /*task01*/ ctx[0].answer + "";
    	let t6;
    	let t7;
    	let div3;
    	let h5;
    	let t8;
    	let t9;
    	let div4;
    	let button0;
    	let t11;
    	let button1;
    	let t13;
    	let button2;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			input = element("input");
    			t4 = space();
    			h6 = element("h6");
    			t5 = text("answer ");
    			t6 = text(t6_value);
    			t7 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t8 = text(/*showPopUp*/ ctx[3]);
    			t9 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t11 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t13 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$H, 43, 10, 989);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$H, 42, 6, 939);
    			add_location(h4, file$H, 50, 12, 1167);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$H, 54, 20, 1243);
    			add_location(h6, file$H, 55, 20, 1365);
    			add_location(div1, file$H, 52, 12, 1212);
    			add_location(div2, file$H, 47, 8, 1146);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$H, 60, 12, 1473);
    			add_location(div3, file$H, 59, 8, 1455);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$H, 64, 12, 1610);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$H, 65, 12, 1706);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$H, 66, 12, 1802);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$H, 63, 8, 1579);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$H, 46, 6, 1074);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$H, 41, 5, 891);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$H, 40, 1, 857);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t4);
    			append_dev(div1, h6);
    			append_dev(h6, t5);
    			append_dev(h6, t6);
    			append_dev(div5, t7);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t11);
    			append_dev(div4, button1);
    			append_dev(div4, t13);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t6_value !== (t6_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t8, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$I($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G2_MS_F12", slots, []);
    	let task01 = taskOne$z();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer.replaceAll(" ", "") == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$z());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G2_MS_F12> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$z,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G2_MS_F12 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$I, create_fragment$I, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G2_MS_F12",
    			options,
    			id: create_fragment$I.name
    		});
    	}
    }

    let task01$y = {
      heading: "Balance subtraction equations - up to 18",
      question:
        "Here are the ways to make 4. Find the pattern and type the missing addition number sentence.",
      questionValue: 0,
      valueArray: [],
      answer: 0,
      randomAnswer: 0,
      solutionArray: [],
      columns: 0,
    };

    const maxValue$l = 20;
    const minValue$l = 1;
    const findInMaxNumber$1 = 10;


    function taskOne$y() {
      task01$y.questionValue =
        Math.floor(Math.random() * (maxValue$l - minValue$l + 1)) + minValue$l;
      task01$y.question = "How do you make " + task01$y.questionValue + " ?";
      task01$y.valueArray = [];
      task01$y.solutionArray = [];
      task01$y.columns = 2;
      let ans = [];
      for (let i = 0; i < findInMaxNumber$1; i++) {
        for (let j = 0; j < findInMaxNumber$1; j++) {
          let a = i + "-" + j;
          if (task01$y.questionValue == i - j) {
            ans.push(a);
          }
        }
      }

      let temparray = randomArrayNumbers(2, ans.length, 0, ans);
      for (let i = 0; i < temparray.length; i++) {
        task01$y.valueArray[i] = temparray[i].split("-").map(function (item) {
          return parseInt(item, 10);
        });
      }
      let RandomValue = Math.floor(Math.random() *  task01$y.valueArray.length);
      let randomINput = Math.floor(Math.random() *  task01$y.valueArray[RandomValue].length);
      task01$y.solutionArray = [...task01$y.valueArray[RandomValue]];
      task01$y.answer = task01$y.valueArray[RandomValue][randomINput];
     
      console.log(task01$y.answer);
      task01$y.valueArray[RandomValue][randomINput] = 'i';
      return task01$y;
    }

    /* src/components/taskComponents/G2_MS_F13.svelte generated by Svelte v3.37.0 */
    const file$G = "src/components/taskComponents/G2_MS_F13.svelte";

    function get_each_context$C(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	child_ctx[13] = i;
    	return child_ctx;
    }

    function get_each_context_1$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[14] = list[i];
    	child_ctx[13] = i;
    	return child_ctx;
    }

    // (74:36) {:else}
    function create_else_block$A(ctx) {
    	let t_value = /*a*/ ctx[14] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*a*/ ctx[14] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$A.name,
    		type: "else",
    		source: "(74:36) {:else}",
    		ctx
    	});

    	return block;
    }

    // (72:34) {#if a == 'i'}
    function create_if_block_2$6(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "style", " width : 30px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$G, 72, 34, 1811);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*answer*/ ctx[1]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[7]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$6.name,
    		type: "if",
    		source: "(72:34) {#if a == 'i'}",
    		ctx
    	});

    	return block;
    }

    // (77:34) {#if i < col.length-1}
    function create_if_block_1$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("-");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$6.name,
    		type: "if",
    		source: "(77:34) {#if i < col.length-1}",
    		ctx
    	});

    	return block;
    }

    // (71:32) {#each col as a, i}
    function create_each_block_1$7(ctx) {
    	let t;
    	let if_block1_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*a*/ ctx[14] == "i") return create_if_block_2$6;
    		return create_else_block$A;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);
    	let if_block1 = /*i*/ ctx[13] < /*col*/ ctx[11].length - 1 && create_if_block_1$6(ctx);

    	const block = {
    		c: function create() {
    			if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(t.parentNode, t);
    				}
    			}

    			if (/*i*/ ctx[13] < /*col*/ ctx[11].length - 1) {
    				if (if_block1) ; else {
    					if_block1 = create_if_block_1$6(ctx);
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$7.name,
    		type: "each",
    		source: "(71:32) {#each col as a, i}",
    		ctx
    	});

    	return block;
    }

    // (81:32) {#if i < task01.valueArray.length-1}
    function create_if_block$A(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("=");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$A.name,
    		type: "if",
    		source: "(81:32) {#if i < task01.valueArray.length-1}",
    		ctx
    	});

    	return block;
    }

    // (69:20) {#each task01.valueArray as col, i }
    function create_each_block$C(ctx) {
    	let t;
    	let if_block_anchor;
    	let each_value_1 = /*col*/ ctx[11];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$7(get_each_context_1$7(ctx, each_value_1, i));
    	}

    	let if_block = /*i*/ ctx[13] < /*task01*/ ctx[0].valueArray.length - 1 && create_if_block$A(ctx);

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01, answer*/ 3) {
    				each_value_1 = /*col*/ ctx[11];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$7(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$7(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(t.parentNode, t);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}

    			if (/*i*/ ctx[13] < /*task01*/ ctx[0].valueArray.length - 1) {
    				if (if_block) ; else {
    					if_block = create_if_block$A(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$C.name,
    		type: "each",
    		source: "(69:20) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$H(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let tr;
    	let td;
    	let span;
    	let t4;
    	let h6;
    	let t5;
    	let t6_value = /*task01*/ ctx[0].answer + "";
    	let t6;
    	let t7;
    	let div3;
    	let h5;
    	let t8;
    	let t9;
    	let solution;
    	let t10;
    	let div4;
    	let button0;
    	let t12;
    	let button1;
    	let t14;
    	let button2;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$C(get_each_context$C(ctx, each_value, i));
    	}

    	solution = new AdditionSolution({
    			props: {
    				num_qnty: /*task01*/ ctx[0].columns,
    				usr_resp: /*answer*/ ctx[1],
    				num: /*task01*/ ctx[0].solutionArray,
    				ans_submit: /*showSolution*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");
    			tr = element("tr");
    			td = element("td");
    			span = element("span");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			h6 = element("h6");
    			t5 = text("answer ");
    			t6 = text(t6_value);
    			t7 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t8 = text(/*showPopUp*/ ctx[3]);
    			t9 = space();
    			create_component(solution.$$.fragment);
    			t10 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t12 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t14 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$G, 53, 8, 1227);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$G, 52, 4, 1179);
    			add_location(h4, file$G, 60, 10, 1395);
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$G, 66, 36, 1538);
    			attr_dev(td, "align", "right");
    			add_location(td, file$G, 66, 18, 1520);
    			add_location(tr, file$G, 65, 16, 1497);
    			attr_dev(table, "width", "150");
    			add_location(table, file$G, 64, 14, 1461);
    			add_location(h6, file$G, 89, 18, 2633);
    			add_location(div1, file$G, 62, 10, 1436);
    			add_location(div2, file$G, 57, 6, 1376);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$G, 94, 10, 2731);
    			add_location(div3, file$G, 93, 6, 2715);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$G, 98, 10, 2970);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$G, 99, 10, 3064);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$G, 100, 10, 3158);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$G, 97, 6, 2941);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$G, 56, 4, 1306);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$G, 51, 3, 1133);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$G, 50, 0, 1101);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);
    			append_dev(table, tr);
    			append_dev(tr, td);
    			append_dev(td, span);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(span, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, h6);
    			append_dev(h6, t5);
    			append_dev(h6, t6);
    			append_dev(div5, t7);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t8);
    			append_dev(div5, t9);
    			mount_component(solution, div5, null);
    			append_dev(div5, t10);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t12);
    			append_dev(div4, button1);
    			append_dev(div4, t14);
    			append_dev(div4, button2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*task01*/ 1) && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*task01*/ 1) && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01, answer*/ 3) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$C(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$C(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(span, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if ((!current || dirty & /*task01*/ 1) && t6_value !== (t6_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t6, t6_value);
    			if (!current || dirty & /*showPopUp*/ 8) set_data_dev(t8, /*showPopUp*/ ctx[3]);

    			if (!current || dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}

    			const solution_changes = {};
    			if (dirty & /*task01*/ 1) solution_changes.num_qnty = /*task01*/ ctx[0].columns;
    			if (dirty & /*answer*/ 2) solution_changes.usr_resp = /*answer*/ ctx[1];
    			if (dirty & /*task01*/ 1) solution_changes.num = /*task01*/ ctx[0].solutionArray;
    			if (dirty & /*showSolution*/ 16) solution_changes.ans_submit = /*showSolution*/ ctx[4];
    			solution.$set(solution_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			destroy_component(solution);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const max$8 = 10;
    const min$8 = 0;
    const numberofColumn$8 = 2;

    function instance$H($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G2_MS_F13", slots, []);
    	let heading = "Addition facts - sums up to 10";
    	let question = "Add :";
    	let maxandmin = MaxandMin$5(max$8, min$8, numberofColumn$8, heading, question);
    	let task01 = taskOne$y();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			$$invalidate(4, showSolution = true);
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$y());
    		$$invalidate(4, showSolution = false);
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G2_MS_F13> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$y,
    		randomCorrect,
    		randomWrong,
    		MaxandMin: MaxandMin$5,
    		Solution: AdditionSolution,
    		heading,
    		question,
    		max: max$8,
    		min: min$8,
    		numberofColumn: numberofColumn$8,
    		maxandmin,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("heading" in $$props) heading = $$props.heading;
    		if ("question" in $$props) question = $$props.question;
    		if ("maxandmin" in $$props) maxandmin = $$props.maxandmin;
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) $$invalidate(4, showSolution = $$props.showSolution);
    		if ("CheckAnswer" in $$props) $$invalidate(5, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(6, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G2_MS_F13 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$H, create_fragment$H, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G2_MS_F13",
    			options,
    			id: create_fragment$H.name
    		});
    	}
    }

    /* src/components/taskComponents/G3_MS_D1.svelte generated by Svelte v3.37.0 */
    const file$F = "src/components/taskComponents/G3_MS_D1.svelte";

    function get_each_context$B(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	child_ctx[13] = i;
    	return child_ctx;
    }

    // (69:28) {:else}
    function create_else_block$z(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[11] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$F, 70, 32, 1979);
    			add_location(tr, file$F, 69, 28, 1942);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[11] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$z.name,
    		type: "else",
    		source: "(69:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (65:28) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$z(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[11] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$F, 66, 50, 1775);
    			attr_dev(td, "align", "right");
    			add_location(td, file$F, 66, 32, 1757);
    			add_location(tr, file$F, 65, 28, 1720);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[11] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$z.name,
    		type: "if",
    		source: "(65:28) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (64:24) {#each task01.valueArray as col, i }
    function create_each_block$B(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[13] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$z;
    		return create_else_block$z;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$B.name,
    		type: "each",
    		source: "(64:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$G(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$B(get_each_context$B(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$F, 50, 10, 1245);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$F, 49, 6, 1195);
    			add_location(h4, file$F, 57, 12, 1423);
    			attr_dev(table, "width", "100");
    			add_location(table, file$F, 61, 16, 1495);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$F, 75, 20, 2172);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$F, 76, 20, 2267);
    			add_location(h6, file$F, 77, 20, 2389);
    			add_location(div1, file$F, 59, 12, 1468);
    			add_location(div2, file$F, 54, 8, 1402);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$F, 82, 12, 2497);
    			add_location(div3, file$F, 81, 8, 2479);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$F, 86, 12, 2634);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$F, 87, 12, 2730);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$F, 88, 12, 2826);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$F, 85, 8, 2603);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$F, 53, 6, 1330);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$F, 48, 5, 1147);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$F, 47, 1, 1113);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t13);
    			append_dev(div4, button1);
    			append_dev(div4, t15);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$B(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$B(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const max$7 = 999;
    const min$7 = 0;
    const numberofColumn$7 = 2;

    function instance$G($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G3_MS_D1", slots, []);
    	let heading = "Subtraction facts - numbers up to 10";
    	let question = "Subtract.";
    	let maxandmin = MaxandMin$3(max$7, min$7, numberofColumn$7, heading, question);
    	let task01 = taskOne$T();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$T());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G3_MS_D1> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$T,
    		randomCorrect,
    		randomWrong,
    		MaxandMin: MaxandMin$3,
    		heading,
    		question,
    		max: max$7,
    		min: min$7,
    		numberofColumn: numberofColumn$7,
    		maxandmin,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("heading" in $$props) heading = $$props.heading;
    		if ("question" in $$props) question = $$props.question;
    		if ("maxandmin" in $$props) maxandmin = $$props.maxandmin;
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G3_MS_D1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$G, create_fragment$G, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G3_MS_D1",
    			options,
    			id: create_fragment$G.name
    		});
    	}
    }

    let task01$x = {
      heading : "Subtraction input/output tables - up to three digits",
      question: "Complete the table.",
      qstNum : 0,
      valueArray: [], 
      answer: [], 
      operator: "-",
      columns: 4,
      input : 0
    };

    const maxValue$k = 999;
    const minValue$k = 101;
    const tablesize = 4;

    function taskOne$x() {

      task01$x.valueArray = [];
      task01$x.answer = []; 

       let displayBtn = randomNumbers$3(tablesize,maxValue$k,minValue$k);
       task01$x.qstNum =  100;
       for(let i = 0 ; i < displayBtn.length;i++){
          task01$x.valueArray[i] = [displayBtn[i], displayBtn[i]-task01$x.qstNum];
          task01$x.answer[i] = [displayBtn[i]-task01$x.qstNum];
       }
       task01$x.input = Math.floor(Math.random() * task01$x.valueArray.length);
       for(let i = 0 ; i < displayBtn.length;i++){
         if(i != task01$x.input){
          task01$x.valueArray[i] = [displayBtn[i], ['i']];
         }
     }
      
      return task01$x;
    }

    /* src/components/taskComponents/G3_MS_D2.svelte generated by Svelte v3.37.0 */
    const file$E = "src/components/taskComponents/G3_MS_D2.svelte";

    function get_each_context$A(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[9] = list;
    	child_ctx[10] = i;
    	return child_ctx;
    }

    function get_each_context_1$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	return child_ctx;
    }

    // (72:32) {:else}
    function create_else_block$y(ctx) {
    	let td;
    	let t_value = /*a*/ ctx[11] + "";
    	let t;

    	const block = {
    		c: function create() {
    			td = element("td");
    			t = text(t_value);
    			attr_dev(td, "align", "right");
    			add_location(td, file$E, 72, 32, 2000);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*a*/ ctx[11] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$y.name,
    		type: "else",
    		source: "(72:32) {:else}",
    		ctx
    	});

    	return block;
    }

    // (70:32) {#if a == 'i'}
    function create_if_block$y(ctx) {
    	let td;
    	let input;
    	let mounted;
    	let dispose;

    	function input_input_handler() {
    		/*input_input_handler*/ ctx[6].call(input, /*i*/ ctx[10]);
    	}

    	const block = {
    		c: function create() {
    			td = element("td");
    			input = element("input");
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "style", " width : 30px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$E, 70, 50, 1823);
    			attr_dev(td, "align", "right");
    			add_location(td, file$E, 70, 32, 1805);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, input);
    			set_input_value(input, /*answer*/ ctx[1][/*i*/ ctx[10]]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1][/*i*/ ctx[10]]) {
    				set_input_value(input, /*answer*/ ctx[1][/*i*/ ctx[10]]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$y.name,
    		type: "if",
    		source: "(70:32) {#if a == 'i'}",
    		ctx
    	});

    	return block;
    }

    // (69:28) {#each col as a}
    function create_each_block_1$6(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*a*/ ctx[11] == "i") return create_if_block$y;
    		return create_else_block$y;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$6.name,
    		type: "each",
    		source: "(69:28) {#each col as a}",
    		ctx
    	});

    	return block;
    }

    // (67:24) {#each task01.valueArray as col, i }
    function create_each_block$A(ctx) {
    	let tr;
    	let t;
    	let each_value_1 = /*col*/ ctx[8];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$6(get_each_context_1$6(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			add_location(tr, file$E, 67, 24, 1650);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			append_dev(tr, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*answer, task01*/ 3) {
    				each_value_1 = /*col*/ ctx[8];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$6(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$6(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, t);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$A.name,
    		type: "each",
    		source: "(67:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$F(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h40;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let h41;
    	let t4;
    	let t5_value = /*task01*/ ctx[0].qstNum + "";
    	let t5;
    	let t6;
    	let table;
    	let t7;
    	let h6;
    	let t8;
    	let t9_value = /*task01*/ ctx[0].answer + "";
    	let t9;
    	let t10;
    	let div3;
    	let h5;
    	let t11;
    	let t12;
    	let div4;
    	let button0;
    	let t14;
    	let button1;
    	let t16;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$A(get_each_context$A(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h40 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			h41 = element("h4");
    			t4 = text("Rule: add ");
    			t5 = text(t5_value);
    			t6 = space();
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t7 = space();
    			h6 = element("h6");
    			t8 = text("answer ");
    			t9 = text(t9_value);
    			t10 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t11 = text(/*showPopUp*/ ctx[3]);
    			t12 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t14 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t16 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$E, 53, 10, 1200);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$E, 52, 6, 1150);
    			add_location(h40, file$E, 60, 12, 1378);
    			add_location(h41, file$E, 63, 16, 1449);
    			attr_dev(table, "width", "100");
    			add_location(table, file$E, 64, 16, 1500);
    			add_location(h6, file$E, 80, 20, 2294);
    			add_location(div1, file$E, 62, 12, 1423);
    			add_location(div2, file$E, 57, 8, 1357);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$E, 85, 12, 2402);
    			add_location(div3, file$E, 84, 8, 2384);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$E, 89, 12, 2540);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$E, 90, 12, 2636);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$E, 91, 12, 2732);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$E, 88, 8, 2509);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$E, 56, 6, 1285);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$E, 51, 5, 1102);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$E, 50, 1, 1068);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h40);
    			append_dev(h40, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, h41);
    			append_dev(h41, t4);
    			append_dev(h41, t5);
    			append_dev(div1, t6);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t7);
    			append_dev(div1, h6);
    			append_dev(h6, t8);
    			append_dev(h6, t9);
    			append_dev(div5, t10);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t11);
    			append_dev(div5, t12);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t14);
    			append_dev(div4, button1);
    			append_dev(div4, t16);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*task01*/ 1 && t5_value !== (t5_value = /*task01*/ ctx[0].qstNum + "")) set_data_dev(t5, t5_value);

    			if (dirty & /*task01, answer*/ 3) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$A(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$A(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*task01*/ 1 && t9_value !== (t9_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t9, t9_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t11, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$F($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G3_MS_D2", slots, []);
    	let task01 = taskOne$x();
    	let answer = [];
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		for (let index = 0; index < answer.length; index++) {
    			if (task01.input != index) {
    				if (answer[index] != task01.answer[index]) {
    					$$invalidate(3, showPopUp = randomWrong());
    					showSolution = true;
    					return;
    				} else {
    					$$invalidate(3, showPopUp = randomCorrect());
    				}
    			}
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = []);
    		$$invalidate(1, answer.length = task01.answer.length, answer);
    		$$invalidate(0, task01 = taskOne$x());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G3_MS_D2> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler(i) {
    		answer[i] = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$x,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G3_MS_D2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$F, create_fragment$F, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G3_MS_D2",
    			options,
    			id: create_fragment$F.name
    		});
    	}
    }

    /* src/components/taskComponents/G3_MS_D3.svelte generated by Svelte v3.37.0 */
    const file$D = "src/components/taskComponents/G3_MS_D3.svelte";

    function create_fragment$E(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let input;
    	let t4;
    	let h6;
    	let t5;
    	let t6_value = /*task01*/ ctx[0].answer + "";
    	let t6;
    	let t7;
    	let div3;
    	let h5;
    	let t8;
    	let t9;
    	let div4;
    	let button0;
    	let t11;
    	let button1;
    	let t13;
    	let button2;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			input = element("input");
    			t4 = space();
    			h6 = element("h6");
    			t5 = text("answer ");
    			t6 = text(t6_value);
    			t7 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t8 = text(/*showPopUp*/ ctx[3]);
    			t9 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t11 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t13 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$D, 50, 10, 1284);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$D, 49, 6, 1234);
    			add_location(h4, file$D, 57, 12, 1462);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$D, 62, 20, 1539);
    			add_location(h6, file$D, 63, 20, 1661);
    			add_location(div1, file$D, 59, 12, 1507);
    			add_location(div2, file$D, 54, 8, 1441);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$D, 68, 12, 1769);
    			add_location(div3, file$D, 67, 8, 1751);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$D, 72, 12, 1906);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$D, 73, 12, 2002);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$D, 74, 12, 2098);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$D, 71, 8, 1875);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$D, 53, 6, 1369);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$D, 48, 5, 1186);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$D, 47, 1, 1152);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t4);
    			append_dev(div1, h6);
    			append_dev(h6, t5);
    			append_dev(h6, t6);
    			append_dev(div5, t7);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t11);
    			append_dev(div4, button1);
    			append_dev(div4, t13);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t6_value !== (t6_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t8, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const max$6 = 999;
    const min$6 = 1;
    const numberofColumn$6 = 2;

    function instance$E($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G3_MS_D3", slots, []);
    	let heading = "Subtract numbers up to three digits - word problems";
    	let question = "Subtract.";
    	let maxandmin = MaxandMin$1(max$6, min$6, numberofColumn$6, heading, question);
    	let task01 = taskOne$I();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$I());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G3_MS_D3> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$I,
    		randomCorrect,
    		randomWrong,
    		MaxandMin: MaxandMin$1,
    		heading,
    		question,
    		max: max$6,
    		min: min$6,
    		numberofColumn: numberofColumn$6,
    		maxandmin,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("heading" in $$props) heading = $$props.heading;
    		if ("question" in $$props) question = $$props.question;
    		if ("maxandmin" in $$props) maxandmin = $$props.maxandmin;
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G3_MS_D3 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$E, create_fragment$E, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G3_MS_D3",
    			options,
    			id: create_fragment$E.name
    		});
    	}
    }

    /* src/components/taskComponents/G3_MS_D4.svelte generated by Svelte v3.37.0 */
    const file$C = "src/components/taskComponents/G3_MS_D4.svelte";

    function get_each_context$z(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	child_ctx[15] = i;
    	return child_ctx;
    }

    function get_each_context_2$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	child_ctx[19] = list;
    	child_ctx[20] = i;
    	return child_ctx;
    }

    function get_each_context_1$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	child_ctx[17] = list;
    	child_ctx[18] = i;
    	return child_ctx;
    }

    // (87:27) {:else}
    function create_else_block_1$1(ctx) {
    	let tr;
    	let t;
    	let each_value_2 = /*value*/ ctx[13];
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$2(get_each_context_2$2(ctx, each_value_2, i));
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			attr_dev(tr, "class", "tablerow");
    			add_location(tr, file$C, 87, 27, 2634);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			append_dev(tr, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*answer, task01*/ 3) {
    				each_value_2 = /*value*/ ctx[13];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$2(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_2$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, t);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_2.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$1.name,
    		type: "else",
    		source: "(87:27) {:else}",
    		ctx
    	});

    	return block;
    }

    // (75:23) {#if i == (task01.displayValues.length-1)}
    function create_if_block$x(ctx) {
    	let hr;
    	let t0;
    	let tr;
    	let t1;
    	let each_value_1 = /*value*/ ctx[13];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$5(get_each_context_1$5(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			hr = element("hr");
    			t0 = space();
    			tr = element("tr");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			add_location(hr, file$C, 75, 23, 2053);
    			attr_dev(tr, "class", "tablerow");
    			add_location(tr, file$C, 76, 23, 2081);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, hr, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, tr, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*answer, task01*/ 3) {
    				each_value_1 = /*value*/ ctx[13];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$5(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$5(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, t1);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(hr);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(tr);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$x.name,
    		type: "if",
    		source: "(75:23) {#if i == (task01.displayValues.length-1)}",
    		ctx
    	});

    	return block;
    }

    // (93:28) {:else}
    function create_else_block_2$1(ctx) {
    	let td;
    	let t_value = /*val*/ ctx[16] + "";
    	let t;

    	const block = {
    		c: function create() {
    			td = element("td");
    			t = text(t_value);
    			attr_dev(td, "align", "right");
    			add_location(td, file$C, 93, 32, 2981);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*val*/ ctx[16] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$1.name,
    		type: "else",
    		source: "(93:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (91:28) {#if val[0] == 'i'}
    function create_if_block_2$5(ctx) {
    	let td;
    	let input;
    	let mounted;
    	let dispose;

    	function input_input_handler_1() {
    		/*input_input_handler_1*/ ctx[7].call(input, /*val*/ ctx[16]);
    	}

    	const block = {
    		c: function create() {
    			td = element("td");
    			input = element("input");
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "style", " width : 30px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$C, 91, 46, 2800);
    			attr_dev(td, "align", "right");
    			add_location(td, file$C, 91, 28, 2782);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, input);
    			set_input_value(input, /*answer*/ ctx[1][/*val*/ ctx[16][1]]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler_1);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*answer, task01*/ 3 && input.value !== /*answer*/ ctx[1][/*val*/ ctx[16][1]]) {
    				set_input_value(input, /*answer*/ ctx[1][/*val*/ ctx[16][1]]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$5.name,
    		type: "if",
    		source: "(91:28) {#if val[0] == 'i'}",
    		ctx
    	});

    	return block;
    }

    // (89:28) {#each value as val}
    function create_each_block_2$2(ctx) {
    	let if_block_anchor;

    	function select_block_type_2(ctx, dirty) {
    		if (/*val*/ ctx[16][0] == "i") return create_if_block_2$5;
    		return create_else_block_2$1;
    	}

    	let current_block_type = select_block_type_2(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$2.name,
    		type: "each",
    		source: "(89:28) {#each value as val}",
    		ctx
    	});

    	return block;
    }

    // (82:24) {:else}
    function create_else_block$x(ctx) {
    	let td;
    	let t_value = /*val*/ ctx[16] + "";
    	let t;

    	const block = {
    		c: function create() {
    			td = element("td");
    			t = text(t_value);
    			attr_dev(td, "align", "right");
    			add_location(td, file$C, 82, 28, 2431);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*val*/ ctx[16] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$x.name,
    		type: "else",
    		source: "(82:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (80:24) {#if val[0] == 'i'}
    function create_if_block_1$5(ctx) {
    	let td;
    	let input;
    	let mounted;
    	let dispose;

    	function input_input_handler() {
    		/*input_input_handler*/ ctx[6].call(input, /*val*/ ctx[16]);
    	}

    	const block = {
    		c: function create() {
    			td = element("td");
    			input = element("input");
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "style", " width : 30px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$C, 80, 42, 2258);
    			attr_dev(td, "align", "right");
    			add_location(td, file$C, 80, 24, 2240);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, input);
    			set_input_value(input, /*answer*/ ctx[1][/*val*/ ctx[16][1]]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*answer, task01*/ 3 && input.value !== /*answer*/ ctx[1][/*val*/ ctx[16][1]]) {
    				set_input_value(input, /*answer*/ ctx[1][/*val*/ ctx[16][1]]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(80:24) {#if val[0] == 'i'}",
    		ctx
    	});

    	return block;
    }

    // (78:24) {#each value as val}
    function create_each_block_1$5(ctx) {
    	let if_block_anchor;

    	function select_block_type_1(ctx, dirty) {
    		if (/*val*/ ctx[16][0] == "i") return create_if_block_1$5;
    		return create_else_block$x;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$5.name,
    		type: "each",
    		source: "(78:24) {#each value as val}",
    		ctx
    	});

    	return block;
    }

    // (73:20) {#each task01.displayValues as value , i}
    function create_each_block$z(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[15] == /*task01*/ ctx[0].displayValues.length - 1) return create_if_block$x;
    		return create_else_block_1$1;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$z.name,
    		type: "each",
    		source: "(73:20) {#each task01.displayValues as value , i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$D(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h20;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h21;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let div3;
    	let h5;
    	let t5;
    	let t6;
    	let div4;
    	let button0;
    	let t8;
    	let button1;
    	let t10;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].displayValues;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$z(get_each_context$z(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h20 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h21 = element("h2");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t5 = text(/*showPopUp*/ ctx[3]);
    			t6 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t8 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t10 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h20, "class", "text-center display-4 mb-0");
    			add_location(h20, file$C, 62, 10, 1543);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$C, 61, 6, 1493);
    			add_location(h21, file$C, 67, 12, 1719);
    			attr_dev(table, "width", "100");
    			add_location(table, file$C, 70, 16, 1799);
    			add_location(div1, file$C, 68, 12, 1758);
    			add_location(div2, file$C, 66, 8, 1700);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$C, 105, 12, 3311);
    			add_location(div3, file$C, 104, 8, 3293);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$C, 111, 12, 3450);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$C, 112, 12, 3546);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$C, 113, 12, 3642);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$C, 110, 8, 3419);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$C, 65, 6, 1628);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$C, 60, 5, 1445);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$C, 59, 1, 1411);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h20);
    			append_dev(h20, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h21);
    			append_dev(h21, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div5, t4);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t5);
    			append_dev(div5, t6);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t8);
    			append_dev(div4, button1);
    			append_dev(div4, t10);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01, answer*/ 3) {
    				each_value = /*task01*/ ctx[0].displayValues;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$z(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$z(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*showPopUp*/ 8) set_data_dev(t5, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const max$5 = 999;
    const min$5 = 1;
    const maxInputs$1 = 1;
    const numberofColumn$5 = 2;

    function instance$D($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G3_MS_D4", slots, []);
    	let question = "Fill in the missing number.";
    	let heading = "Complete the subtraction sentence - up to three digits";
    	let showSolution = false;
    	let maxandmin = MaxandMin$2(max$5, min$5, numberofColumn$5, heading, question, maxInputs$1);
    	let task01 = taskOne$K();
    	let answer = [];
    	let showNext = "none";
    	let showPopUp;
    	let tempString = "";

    	let CheckAnswer = function () {
    		for (let index = 0; index < task01.answer.length; index++) {
    			if (answer[index] != task01.answer[index]) {
    				$$invalidate(3, showPopUp = randomWrong());
    				$$invalidate(2, showNext = "inline-block");
    				showSolution = true;
    				return;
    			} else {
    				$$invalidate(3, showPopUp = randomCorrect());
    				$$invalidate(2, showNext = "inline-block");
    			}
    		}
    	};

    	let NextQuestion = function () {
    		showSolution = false;
    		$$invalidate(1, answer = []);
    		$$invalidate(0, task01 = taskOne$K());
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G3_MS_D4> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler(val) {
    		answer[val[1]] = this.value;
    		$$invalidate(1, answer);
    		$$invalidate(0, task01);
    	}

    	function input_input_handler_1(val) {
    		answer[val[1]] = this.value;
    		$$invalidate(1, answer);
    		$$invalidate(0, task01);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$K,
    		randomCorrect,
    		randomWrong,
    		MaxandMin: MaxandMin$2,
    		question,
    		heading,
    		max: max$5,
    		min: min$5,
    		maxInputs: maxInputs$1,
    		numberofColumn: numberofColumn$5,
    		showSolution,
    		maxandmin,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		tempString,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("question" in $$props) question = $$props.question;
    		if ("heading" in $$props) heading = $$props.heading;
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("maxandmin" in $$props) maxandmin = $$props.maxandmin;
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("tempString" in $$props) tempString = $$props.tempString;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler,
    		input_input_handler_1
    	];
    }

    class G3_MS_D4 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$D, create_fragment$D, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G3_MS_D4",
    			options,
    			id: create_fragment$D.name
    		});
    	}
    }

    let task01$w = {
      heading: "Balance addition equations - one digit",
      question:
        "Here are the ways to make 4. Find the pattern and type the missing addition number sentence.",
      questionValue: 0,
      valueArray: [],
      answer: 0,
      randomAnswer: 0,
      solutionArray: [],
      columns: 0,
    };

    const maxValue$j = 999;
    const minValue$j = 100;
    const findInMaxNumber = 1000;


    function taskOne$w() {
      task01$w.questionValue =
        Math.floor(Math.random() * (maxValue$j - minValue$j + 1)) + minValue$j;
      task01$w.question = "How do you make true?";
      task01$w.valueArray = [];
      task01$w.solutionArray = [];
      task01$w.columns = 2;
      let ans = [];
      for (let i = 0; i < findInMaxNumber; i++) {
        for (let j = 0; j < findInMaxNumber; j++) {
          let a = i + "-" + j;
          if (task01$w.questionValue == i - j) {
            ans.push(a);
          }
        }
      }

      let temparray = randomArrayNumbers(2, ans.length, 0, ans);
      for (let i = 0; i < temparray.length; i++) {
        task01$w.valueArray[i] = temparray[i].split("-").map(function (item) {
          return parseInt(item, 10);
        });
      }
      let RandomValue = Math.floor(Math.random() *  task01$w.valueArray.length);
      let randomINput = Math.floor(Math.random() *  task01$w.valueArray[RandomValue].length);
      task01$w.solutionArray = [...task01$w.valueArray[RandomValue]];
      task01$w.answer = task01$w.valueArray[RandomValue][randomINput];
     
      console.log(task01$w.answer);
      task01$w.valueArray[RandomValue][randomINput] = 'i';
      return task01$w;
    }

    /* src/components/taskComponents/G3_MS_D5.svelte generated by Svelte v3.37.0 */
    const file$B = "src/components/taskComponents/G3_MS_D5.svelte";

    function get_each_context$y(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	child_ctx[13] = i;
    	return child_ctx;
    }

    function get_each_context_1$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[14] = list[i];
    	child_ctx[13] = i;
    	return child_ctx;
    }

    // (74:36) {:else}
    function create_else_block$w(ctx) {
    	let t_value = /*a*/ ctx[14] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*a*/ ctx[14] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$w.name,
    		type: "else",
    		source: "(74:36) {:else}",
    		ctx
    	});

    	return block;
    }

    // (72:34) {#if a == 'i'}
    function create_if_block_2$4(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "style", " width : 60px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$B, 72, 34, 1810);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*answer*/ ctx[1]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[7]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$4.name,
    		type: "if",
    		source: "(72:34) {#if a == 'i'}",
    		ctx
    	});

    	return block;
    }

    // (77:34) {#if i < col.length-1}
    function create_if_block_1$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("-");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(77:34) {#if i < col.length-1}",
    		ctx
    	});

    	return block;
    }

    // (71:32) {#each col as a, i}
    function create_each_block_1$4(ctx) {
    	let t;
    	let if_block1_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*a*/ ctx[14] == "i") return create_if_block_2$4;
    		return create_else_block$w;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);
    	let if_block1 = /*i*/ ctx[13] < /*col*/ ctx[11].length - 1 && create_if_block_1$4(ctx);

    	const block = {
    		c: function create() {
    			if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(t.parentNode, t);
    				}
    			}

    			if (/*i*/ ctx[13] < /*col*/ ctx[11].length - 1) {
    				if (if_block1) ; else {
    					if_block1 = create_if_block_1$4(ctx);
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$4.name,
    		type: "each",
    		source: "(71:32) {#each col as a, i}",
    		ctx
    	});

    	return block;
    }

    // (81:32) {#if i < task01.valueArray.length-1}
    function create_if_block$w(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("=");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$w.name,
    		type: "if",
    		source: "(81:32) {#if i < task01.valueArray.length-1}",
    		ctx
    	});

    	return block;
    }

    // (69:20) {#each task01.valueArray as col, i }
    function create_each_block$y(ctx) {
    	let t;
    	let if_block_anchor;
    	let each_value_1 = /*col*/ ctx[11];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$4(get_each_context_1$4(ctx, each_value_1, i));
    	}

    	let if_block = /*i*/ ctx[13] < /*task01*/ ctx[0].valueArray.length - 1 && create_if_block$w(ctx);

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01, answer*/ 3) {
    				each_value_1 = /*col*/ ctx[11];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$4(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$4(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(t.parentNode, t);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}

    			if (/*i*/ ctx[13] < /*task01*/ ctx[0].valueArray.length - 1) {
    				if (if_block) ; else {
    					if_block = create_if_block$w(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$y.name,
    		type: "each",
    		source: "(69:20) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$C(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let tr;
    	let td;
    	let span;
    	let t4;
    	let h6;
    	let t5;
    	let t6_value = /*task01*/ ctx[0].answer + "";
    	let t6;
    	let t7;
    	let div3;
    	let h5;
    	let t8;
    	let t9;
    	let solution;
    	let t10;
    	let div4;
    	let button0;
    	let t12;
    	let button1;
    	let t14;
    	let button2;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$y(get_each_context$y(ctx, each_value, i));
    	}

    	solution = new AdditionSolution({
    			props: {
    				num_qnty: /*task01*/ ctx[0].columns,
    				usr_resp: /*answer*/ ctx[1],
    				num: /*task01*/ ctx[0].solutionArray,
    				ans_submit: /*showSolution*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");
    			tr = element("tr");
    			td = element("td");
    			span = element("span");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			h6 = element("h6");
    			t5 = text("answer ");
    			t6 = text(t6_value);
    			t7 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t8 = text(/*showPopUp*/ ctx[3]);
    			t9 = space();
    			create_component(solution.$$.fragment);
    			t10 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t12 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t14 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$B, 53, 8, 1226);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$B, 52, 4, 1178);
    			add_location(h4, file$B, 60, 10, 1394);
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$B, 66, 36, 1537);
    			attr_dev(td, "align", "right");
    			add_location(td, file$B, 66, 18, 1519);
    			add_location(tr, file$B, 65, 16, 1496);
    			attr_dev(table, "width", "400");
    			add_location(table, file$B, 64, 14, 1460);
    			add_location(h6, file$B, 89, 18, 2632);
    			add_location(div1, file$B, 62, 10, 1435);
    			add_location(div2, file$B, 57, 6, 1375);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$B, 94, 10, 2730);
    			add_location(div3, file$B, 93, 6, 2714);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$B, 98, 10, 2969);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$B, 99, 10, 3063);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$B, 100, 10, 3157);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$B, 97, 6, 2940);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$B, 56, 4, 1305);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$B, 51, 3, 1132);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$B, 50, 0, 1100);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);
    			append_dev(table, tr);
    			append_dev(tr, td);
    			append_dev(td, span);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(span, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, h6);
    			append_dev(h6, t5);
    			append_dev(h6, t6);
    			append_dev(div5, t7);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t8);
    			append_dev(div5, t9);
    			mount_component(solution, div5, null);
    			append_dev(div5, t10);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t12);
    			append_dev(div4, button1);
    			append_dev(div4, t14);
    			append_dev(div4, button2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*task01*/ 1) && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*task01*/ 1) && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01, answer*/ 3) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$y(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$y(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(span, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if ((!current || dirty & /*task01*/ 1) && t6_value !== (t6_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t6, t6_value);
    			if (!current || dirty & /*showPopUp*/ 8) set_data_dev(t8, /*showPopUp*/ ctx[3]);

    			if (!current || dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}

    			const solution_changes = {};
    			if (dirty & /*task01*/ 1) solution_changes.num_qnty = /*task01*/ ctx[0].columns;
    			if (dirty & /*answer*/ 2) solution_changes.usr_resp = /*answer*/ ctx[1];
    			if (dirty & /*task01*/ 1) solution_changes.num = /*task01*/ ctx[0].solutionArray;
    			if (dirty & /*showSolution*/ 16) solution_changes.ans_submit = /*showSolution*/ ctx[4];
    			solution.$set(solution_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			destroy_component(solution);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const max$4 = 10;
    const min$4 = 0;
    const numberofColumn$4 = 2;

    function instance$C($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G3_MS_D5", slots, []);
    	let heading = "Addition facts - sums up to 10";
    	let question = "Add :";
    	let maxandmin = MaxandMin$5(max$4, min$4, numberofColumn$4, heading, question);
    	let task01 = taskOne$w();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			$$invalidate(4, showSolution = true);
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$w());
    		$$invalidate(4, showSolution = false);
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G3_MS_D5> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$w,
    		randomCorrect,
    		randomWrong,
    		MaxandMin: MaxandMin$5,
    		Solution: AdditionSolution,
    		heading,
    		question,
    		max: max$4,
    		min: min$4,
    		numberofColumn: numberofColumn$4,
    		maxandmin,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("heading" in $$props) heading = $$props.heading;
    		if ("question" in $$props) question = $$props.question;
    		if ("maxandmin" in $$props) maxandmin = $$props.maxandmin;
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) $$invalidate(4, showSolution = $$props.showSolution);
    		if ("CheckAnswer" in $$props) $$invalidate(5, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(6, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G3_MS_D5 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$C, create_fragment$C, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G3_MS_D5",
    			options,
    			id: create_fragment$C.name
    		});
    	}
    }

    let task01$v = {
      question: "",
      valueArray: [],  
      Options: [1, 10, 100],
      variations: 0,
      randomAnswer: 0,
      answer : 0
    };
        const maxNumber$3 = 10;
        const minNumber$3 = 1;
        
    function taskOne$v() {

      task01$v.variations =  Math.floor(Math.random() * 3 - 1) + 1;
      task01$v.valueArray[0] = Math.floor(Math.random() * (maxNumber$3 - minNumber$3 + 1) ) + minNumber$3;
      task01$v.valueArray[1] = Math.floor(Math.random() * (task01$v.valueArray[0] - minNumber$3 + 1)) + minNumber$3;
      task01$v.valueArray[2] = task01$v.valueArray[0] - task01$v.valueArray[1];
      task01$v.question = "Complete the pattern:";  
      task01$v.answer = task01$v.valueArray[task01$v.variations];
      task01$v.valueArray[task01$v.variations] = 'i';
      console.log(task01$v.valueArray);
      console.log(task01$v.answer);
      return task01$v;
    }

    /* src/components/taskComponents/G3_MS_D6.svelte generated by Svelte v3.37.0 */

    const { console: console_1$2 } = globals;
    const file$A = "src/components/taskComponents/G3_MS_D6.svelte";

    function get_each_context$x(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	child_ctx[8] = list;
    	child_ctx[9] = i;
    	return child_ctx;
    }

    function get_each_context_1$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	child_ctx[12] = i;
    	return child_ctx;
    }

    // (59:24) {#if j == task01.valueArray.length - 1}
    function create_if_block_2$3(ctx) {
    	let h4;

    	const block = {
    		c: function create() {
    			h4 = element("h4");
    			h4.textContent = "=";
    			set_style(h4, "display", "inline");
    			add_location(h4, file$A, 59, 24, 1651);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h4, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h4);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(59:24) {#if j == task01.valueArray.length - 1}",
    		ctx
    	});

    	return block;
    }

    // (62:24) {#if j == task01.valueArray.length - 2 }
    function create_if_block_1$3(ctx) {
    	let h4;

    	const block = {
    		c: function create() {
    			h4 = element("h4");
    			h4.textContent = "-";
    			set_style(h4, "display", "inline");
    			add_location(h4, file$A, 62, 24, 1809);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h4, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h4);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(62:24) {#if j == task01.valueArray.length - 2 }",
    		ctx
    	});

    	return block;
    }

    // (68:24) {:else}
    function create_else_block$v(ctx) {
    	let h4;
    	let t_value = /*value*/ ctx[10] * /*optionValue*/ ctx[7] + "";
    	let t;

    	const block = {
    		c: function create() {
    			h4 = element("h4");
    			t = text(t_value);
    			set_style(h4, "display", "inline");
    			add_location(h4, file$A, 68, 24, 2073);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h4, anchor);
    			append_dev(h4, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 4 && t_value !== (t_value = /*value*/ ctx[10] * /*optionValue*/ ctx[7] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h4);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$v.name,
    		type: "else",
    		source: "(68:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (66:24) {#if value == 'i'}
    function create_if_block$v(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	function input_input_handler() {
    		/*input_input_handler*/ ctx[6].call(input, /*i*/ ctx[9]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			add_location(input, file$A, 66, 24, 1946);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*answer*/ ctx[3][/*i*/ ctx[9]]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*answer*/ 8 && input.value !== /*answer*/ ctx[3][/*i*/ ctx[9]]) {
    				set_input_value(input, /*answer*/ ctx[3][/*i*/ ctx[9]]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$v.name,
    		type: "if",
    		source: "(66:24) {#if value == 'i'}",
    		ctx
    	});

    	return block;
    }

    // (58:24) {#each  task01.valueArray as value,j }
    function create_each_block_1$3(ctx) {
    	let t0;
    	let t1;
    	let if_block2_anchor;
    	let if_block0 = /*j*/ ctx[12] == /*task01*/ ctx[2].valueArray.length - 1 && create_if_block_2$3(ctx);
    	let if_block1 = /*j*/ ctx[12] == /*task01*/ ctx[2].valueArray.length - 2 && create_if_block_1$3(ctx);

    	function select_block_type(ctx, dirty) {
    		if (/*value*/ ctx[10] == "i") return create_if_block$v;
    		return create_else_block$v;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block2 = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if_block2.c();
    			if_block2_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*j*/ ctx[12] == /*task01*/ ctx[2].valueArray.length - 1) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_2$3(ctx);
    					if_block0.c();
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*j*/ ctx[12] == /*task01*/ ctx[2].valueArray.length - 2) {
    				if (if_block1) ; else {
    					if_block1 = create_if_block_1$3(ctx);
    					if_block1.c();
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block2) {
    				if_block2.p(ctx, dirty);
    			} else {
    				if_block2.d(1);
    				if_block2 = current_block_type(ctx);

    				if (if_block2) {
    					if_block2.c();
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$3.name,
    		type: "each",
    		source: "(58:24) {#each  task01.valueArray as value,j }",
    		ctx
    	});

    	return block;
    }

    // (56:20) {#each  task01.Options as optionValue,i }
    function create_each_block$x(ctx) {
    	let div;
    	let t;
    	let each_value_1 = /*task01*/ ctx[2].valueArray;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			add_location(div, file$A, 56, 20, 1492);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*answer, task01*/ 12) {
    				each_value_1 = /*task01*/ ctx[2].valueArray;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$3(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, t);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$x.name,
    		type: "each",
    		source: "(56:20) {#each  task01.Options as optionValue,i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$B(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h20;
    	let t1;
    	let div5;
    	let div2;
    	let h21;
    	let t2_value = /*task01*/ ctx[2].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let t4;
    	let div3;
    	let h5;
    	let t5;
    	let t6;
    	let div4;
    	let button0;
    	let t8;
    	let button1;
    	let t10;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[2].Options;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$x(get_each_context$x(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h20 = element("h2");
    			h20.textContent = "Subtraction patterns over increasing place values";
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h21 = element("h2");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t5 = text(/*showPopUp*/ ctx[1]);
    			t6 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t8 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t10 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h20, "class", "text-center display-4 mb-0");
    			add_location(h20, file$A, 45, 10, 1136);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$A, 44, 6, 1086);
    			add_location(h21, file$A, 52, 12, 1347);
    			attr_dev(div1, "class", " p-2");
    			add_location(div1, file$A, 53, 12, 1387);
    			add_location(div2, file$A, 51, 8, 1328);
    			set_style(h5, "display", /*showNext*/ ctx[0]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$A, 78, 13, 2367);
    			add_location(div3, file$A, 77, 10, 2348);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$A, 81, 12, 2499);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$A, 82, 12, 2595);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$A, 83, 12, 2691);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$A, 80, 10, 2468);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$A, 49, 6, 1255);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$A, 43, 5, 1038);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$A, 42, 1, 1004);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h20);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h21);
    			append_dev(h21, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			append_dev(div5, t4);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t5);
    			append_dev(div5, t6);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t8);
    			append_dev(div4, button1);
    			append_dev(div4, t10);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 4 && t2_value !== (t2_value = /*task01*/ ctx[2].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01, answer*/ 12) {
    				each_value = /*task01*/ ctx[2].Options;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$x(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$x(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*showPopUp*/ 2) set_data_dev(t5, /*showPopUp*/ ctx[1]);

    			if (dirty & /*showNext*/ 1) {
    				set_style(h5, "display", /*showNext*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$B($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G3_MS_D6", slots, []);
    	let showNext = "none";
    	let showPopUp;
    	let task01 = taskOne$v();
    	let answer = [];

    	let CheckAnswer = function () {
    		for (let index = 0; index < answer.length; index++) {
    			if (answer[index] != task01.answer * task01.Options[index]) {
    				$$invalidate(1, showPopUp = randomWrong());
    				$$invalidate(0, showNext = "inline-block");
    				console.log("01");
    				break;
    			}

    			if (index == answer.length - 1) {
    				$$invalidate(1, showPopUp = randomCorrect());
    				$$invalidate(0, showNext = "inline-block");
    				console.log("02");
    			}
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(3, answer = []);
    		$$invalidate(2, task01 = taskOne$v());
    		$$invalidate(3, answer = new Array(task01.Options.length));
    		$$invalidate(0, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$2.warn(`<G3_MS_D6> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler(i) {
    		answer[i] = this.value;
    		$$invalidate(3, answer);
    	}

    	$$self.$capture_state = () => ({
    		randomCorrect,
    		randomWrong,
    		taskOne: taskOne$v,
    		showNext,
    		showPopUp,
    		task01,
    		answer,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("showNext" in $$props) $$invalidate(0, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(1, showPopUp = $$props.showPopUp);
    		if ("task01" in $$props) $$invalidate(2, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(3, answer = $$props.answer);
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		showNext,
    		showPopUp,
    		task01,
    		answer,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G3_MS_D6 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$B, create_fragment$B, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G3_MS_D6",
    			options,
    			id: create_fragment$B.name
    		});
    	}
    }

    /* src/components/taskComponents/G4_MS_C1.svelte generated by Svelte v3.37.0 */
    const file$z = "src/components/taskComponents/G4_MS_C1.svelte";

    function get_each_context$w(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	child_ctx[13] = i;
    	return child_ctx;
    }

    // (69:28) {:else}
    function create_else_block$u(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[11] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$z, 70, 32, 1979);
    			add_location(tr, file$z, 69, 28, 1942);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[11] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$u.name,
    		type: "else",
    		source: "(69:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (65:28) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$u(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[11] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$z, 66, 50, 1775);
    			attr_dev(td, "align", "right");
    			add_location(td, file$z, 66, 32, 1757);
    			add_location(tr, file$z, 65, 28, 1720);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[11] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$u.name,
    		type: "if",
    		source: "(65:28) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (64:24) {#each task01.valueArray as col, i }
    function create_each_block$w(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[13] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$u;
    		return create_else_block$u;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$w.name,
    		type: "each",
    		source: "(64:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$A(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$w(get_each_context$w(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$z, 50, 10, 1245);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$z, 49, 6, 1195);
    			add_location(h4, file$z, 57, 12, 1423);
    			attr_dev(table, "width", "100");
    			add_location(table, file$z, 61, 16, 1495);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$z, 75, 20, 2172);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$z, 76, 20, 2267);
    			add_location(h6, file$z, 77, 20, 2389);
    			add_location(div1, file$z, 59, 12, 1468);
    			add_location(div2, file$z, 54, 8, 1402);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$z, 82, 12, 2497);
    			add_location(div3, file$z, 81, 8, 2479);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$z, 86, 12, 2634);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$z, 87, 12, 2730);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$z, 88, 12, 2826);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$z, 85, 8, 2603);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$z, 53, 6, 1330);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$z, 48, 5, 1147);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$z, 47, 1, 1113);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t13);
    			append_dev(div4, button1);
    			append_dev(div4, t15);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$w(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$w(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const max$3 = 99999;
    const min$3 = 1;
    const numberofColumn$3 = 2;

    function instance$A($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G4_MS_C1", slots, []);
    	let heading = "Subtract numbers up to five digits";
    	let question = "Subtract.";
    	let maxandmin = MaxandMin$3(max$3, min$3, numberofColumn$3, heading, question);
    	let task01 = taskOne$T();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$T());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G4_MS_C1> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$T,
    		randomCorrect,
    		randomWrong,
    		MaxandMin: MaxandMin$3,
    		heading,
    		question,
    		max: max$3,
    		min: min$3,
    		numberofColumn: numberofColumn$3,
    		maxandmin,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("heading" in $$props) heading = $$props.heading;
    		if ("question" in $$props) question = $$props.question;
    		if ("maxandmin" in $$props) maxandmin = $$props.maxandmin;
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G4_MS_C1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$A, create_fragment$A, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G4_MS_C1",
    			options,
    			id: create_fragment$A.name
    		});
    	}
    }

    /* src/components/taskComponents/G4_MS_C2.svelte generated by Svelte v3.37.0 */
    const file$y = "src/components/taskComponents/G4_MS_C2.svelte";

    function create_fragment$z(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let input;
    	let t4;
    	let h6;
    	let t5;
    	let t6_value = /*task01*/ ctx[0].answer + "";
    	let t6;
    	let t7;
    	let div3;
    	let h5;
    	let t8;
    	let t9;
    	let div4;
    	let button0;
    	let t11;
    	let button1;
    	let t13;
    	let button2;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			input = element("input");
    			t4 = space();
    			h6 = element("h6");
    			t5 = text("answer ");
    			t6 = text(t6_value);
    			t7 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t8 = text(/*showPopUp*/ ctx[3]);
    			t9 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t11 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t13 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$y, 50, 10, 1284);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$y, 49, 6, 1234);
    			add_location(h4, file$y, 57, 12, 1462);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$y, 62, 20, 1539);
    			add_location(h6, file$y, 63, 20, 1661);
    			add_location(div1, file$y, 59, 12, 1507);
    			add_location(div2, file$y, 54, 8, 1441);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$y, 68, 12, 1769);
    			add_location(div3, file$y, 67, 8, 1751);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$y, 72, 12, 1906);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$y, 73, 12, 2002);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$y, 74, 12, 2098);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$y, 71, 8, 1875);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$y, 53, 6, 1369);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$y, 48, 5, 1186);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$y, 47, 1, 1152);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t4);
    			append_dev(div1, h6);
    			append_dev(h6, t5);
    			append_dev(h6, t6);
    			append_dev(div5, t7);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t11);
    			append_dev(div4, button1);
    			append_dev(div4, t13);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t6_value !== (t6_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t8, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const max$2 = 99999;
    const min$2 = 1;
    const numberofColumn$2 = 2;

    function instance$z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G4_MS_C2", slots, []);
    	let heading = "Subtract numbers up to five digits: word problems";
    	let question = "Subtract.";
    	let maxandmin = MaxandMin$1(max$2, min$2, numberofColumn$2, heading, question);
    	let task01 = taskOne$I();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$I());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G4_MS_C2> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$I,
    		randomCorrect,
    		randomWrong,
    		MaxandMin: MaxandMin$1,
    		heading,
    		question,
    		max: max$2,
    		min: min$2,
    		numberofColumn: numberofColumn$2,
    		maxandmin,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("heading" in $$props) heading = $$props.heading;
    		if ("question" in $$props) question = $$props.question;
    		if ("maxandmin" in $$props) maxandmin = $$props.maxandmin;
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G4_MS_C2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$z, create_fragment$z, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G4_MS_C2",
    			options,
    			id: create_fragment$z.name
    		});
    	}
    }

    /* src/components/taskComponents/G4_MS_C3.svelte generated by Svelte v3.37.0 */
    const file$x = "src/components/taskComponents/G4_MS_C3.svelte";

    function get_each_context$v(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	child_ctx[15] = i;
    	return child_ctx;
    }

    function get_each_context_2$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	child_ctx[19] = list;
    	child_ctx[20] = i;
    	return child_ctx;
    }

    function get_each_context_1$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	child_ctx[17] = list;
    	child_ctx[18] = i;
    	return child_ctx;
    }

    // (87:27) {:else}
    function create_else_block_1(ctx) {
    	let tr;
    	let t;
    	let each_value_2 = /*value*/ ctx[13];
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			attr_dev(tr, "class", "tablerow");
    			add_location(tr, file$x, 87, 27, 2619);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			append_dev(tr, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*answer, task01*/ 3) {
    				each_value_2 = /*value*/ ctx[13];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$1(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_2$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, t);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_2.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(87:27) {:else}",
    		ctx
    	});

    	return block;
    }

    // (75:23) {#if i == (task01.displayValues.length-1)}
    function create_if_block$t(ctx) {
    	let hr;
    	let t0;
    	let tr;
    	let t1;
    	let each_value_1 = /*value*/ ctx[13];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			hr = element("hr");
    			t0 = space();
    			tr = element("tr");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			add_location(hr, file$x, 75, 23, 2038);
    			attr_dev(tr, "class", "tablerow");
    			add_location(tr, file$x, 76, 23, 2066);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, hr, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, tr, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*answer, task01*/ 3) {
    				each_value_1 = /*value*/ ctx[13];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, t1);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(hr);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(tr);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$t.name,
    		type: "if",
    		source: "(75:23) {#if i == (task01.displayValues.length-1)}",
    		ctx
    	});

    	return block;
    }

    // (93:28) {:else}
    function create_else_block_2(ctx) {
    	let td;
    	let t_value = /*val*/ ctx[16] + "";
    	let t;

    	const block = {
    		c: function create() {
    			td = element("td");
    			t = text(t_value);
    			attr_dev(td, "align", "right");
    			add_location(td, file$x, 93, 32, 2966);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*val*/ ctx[16] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2.name,
    		type: "else",
    		source: "(93:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (91:28) {#if val[0] == 'i'}
    function create_if_block_2$2(ctx) {
    	let td;
    	let input;
    	let mounted;
    	let dispose;

    	function input_input_handler_1() {
    		/*input_input_handler_1*/ ctx[7].call(input, /*val*/ ctx[16]);
    	}

    	const block = {
    		c: function create() {
    			td = element("td");
    			input = element("input");
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "style", " width : 30px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$x, 91, 46, 2785);
    			attr_dev(td, "align", "right");
    			add_location(td, file$x, 91, 28, 2767);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, input);
    			set_input_value(input, /*answer*/ ctx[1][/*val*/ ctx[16][1]]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler_1);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*answer, task01*/ 3 && input.value !== /*answer*/ ctx[1][/*val*/ ctx[16][1]]) {
    				set_input_value(input, /*answer*/ ctx[1][/*val*/ ctx[16][1]]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(91:28) {#if val[0] == 'i'}",
    		ctx
    	});

    	return block;
    }

    // (89:28) {#each value as val}
    function create_each_block_2$1(ctx) {
    	let if_block_anchor;

    	function select_block_type_2(ctx, dirty) {
    		if (/*val*/ ctx[16][0] == "i") return create_if_block_2$2;
    		return create_else_block_2;
    	}

    	let current_block_type = select_block_type_2(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$1.name,
    		type: "each",
    		source: "(89:28) {#each value as val}",
    		ctx
    	});

    	return block;
    }

    // (82:24) {:else}
    function create_else_block$t(ctx) {
    	let td;
    	let t_value = /*val*/ ctx[16] + "";
    	let t;

    	const block = {
    		c: function create() {
    			td = element("td");
    			t = text(t_value);
    			attr_dev(td, "align", "right");
    			add_location(td, file$x, 82, 28, 2416);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*val*/ ctx[16] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$t.name,
    		type: "else",
    		source: "(82:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (80:24) {#if val[0] == 'i'}
    function create_if_block_1$2(ctx) {
    	let td;
    	let input;
    	let mounted;
    	let dispose;

    	function input_input_handler() {
    		/*input_input_handler*/ ctx[6].call(input, /*val*/ ctx[16]);
    	}

    	const block = {
    		c: function create() {
    			td = element("td");
    			input = element("input");
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "style", " width : 30px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$x, 80, 42, 2243);
    			attr_dev(td, "align", "right");
    			add_location(td, file$x, 80, 24, 2225);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, input);
    			set_input_value(input, /*answer*/ ctx[1][/*val*/ ctx[16][1]]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*answer, task01*/ 3 && input.value !== /*answer*/ ctx[1][/*val*/ ctx[16][1]]) {
    				set_input_value(input, /*answer*/ ctx[1][/*val*/ ctx[16][1]]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(80:24) {#if val[0] == 'i'}",
    		ctx
    	});

    	return block;
    }

    // (78:24) {#each value as val}
    function create_each_block_1$2(ctx) {
    	let if_block_anchor;

    	function select_block_type_1(ctx, dirty) {
    		if (/*val*/ ctx[16][0] == "i") return create_if_block_1$2;
    		return create_else_block$t;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$2.name,
    		type: "each",
    		source: "(78:24) {#each value as val}",
    		ctx
    	});

    	return block;
    }

    // (73:20) {#each task01.displayValues as value , i}
    function create_each_block$v(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[15] == /*task01*/ ctx[0].displayValues.length - 1) return create_if_block$t;
    		return create_else_block_1;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$v.name,
    		type: "each",
    		source: "(73:20) {#each task01.displayValues as value , i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$y(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h20;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h21;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let div3;
    	let h5;
    	let t5;
    	let t6;
    	let div4;
    	let button0;
    	let t8;
    	let button1;
    	let t10;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].displayValues;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$v(get_each_context$v(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h20 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h21 = element("h2");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t5 = text(/*showPopUp*/ ctx[3]);
    			t6 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t8 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t10 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h20, "class", "text-center display-4 mb-0");
    			add_location(h20, file$x, 62, 10, 1528);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$x, 61, 6, 1478);
    			add_location(h21, file$x, 67, 12, 1704);
    			attr_dev(table, "width", "100");
    			add_location(table, file$x, 70, 16, 1784);
    			add_location(div1, file$x, 68, 12, 1743);
    			add_location(div2, file$x, 66, 8, 1685);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$x, 105, 12, 3296);
    			add_location(div3, file$x, 104, 8, 3278);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$x, 111, 12, 3435);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$x, 112, 12, 3531);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$x, 113, 12, 3627);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$x, 110, 8, 3404);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$x, 65, 6, 1613);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$x, 60, 5, 1430);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$x, 59, 1, 1396);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h20);
    			append_dev(h20, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h21);
    			append_dev(h21, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div5, t4);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t5);
    			append_dev(div5, t6);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t8);
    			append_dev(div4, button1);
    			append_dev(div4, t10);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01, answer*/ 3) {
    				each_value = /*task01*/ ctx[0].displayValues;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$v(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$v(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*showPopUp*/ 8) set_data_dev(t5, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const max$1 = 999;
    const min$1 = 1;
    const maxInputs = 1;
    const numberofColumn$1 = 2;

    function instance$y($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G4_MS_C3", slots, []);
    	let question = "Fill in the missing number.";
    	let heading = "Subtraction: fill in the missing digits";
    	let showSolution = false;
    	let maxandmin = MaxandMin$2(max$1, min$1, numberofColumn$1, heading, question, maxInputs);
    	let task01 = taskOne$K();
    	let answer = [];
    	let showNext = "none";
    	let showPopUp;
    	let tempString = "";

    	let CheckAnswer = function () {
    		for (let index = 0; index < task01.answer.length; index++) {
    			if (answer[index] != task01.answer[index]) {
    				$$invalidate(3, showPopUp = randomWrong());
    				$$invalidate(2, showNext = "inline-block");
    				showSolution = true;
    				return;
    			} else {
    				$$invalidate(3, showPopUp = randomCorrect());
    				$$invalidate(2, showNext = "inline-block");
    			}
    		}
    	};

    	let NextQuestion = function () {
    		showSolution = false;
    		$$invalidate(1, answer = []);
    		$$invalidate(0, task01 = taskOne$K());
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G4_MS_C3> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler(val) {
    		answer[val[1]] = this.value;
    		$$invalidate(1, answer);
    		$$invalidate(0, task01);
    	}

    	function input_input_handler_1(val) {
    		answer[val[1]] = this.value;
    		$$invalidate(1, answer);
    		$$invalidate(0, task01);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$K,
    		randomCorrect,
    		randomWrong,
    		MaxandMin: MaxandMin$2,
    		question,
    		heading,
    		max: max$1,
    		min: min$1,
    		maxInputs,
    		numberofColumn: numberofColumn$1,
    		showSolution,
    		maxandmin,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		tempString,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("question" in $$props) question = $$props.question;
    		if ("heading" in $$props) heading = $$props.heading;
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("maxandmin" in $$props) maxandmin = $$props.maxandmin;
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("tempString" in $$props) tempString = $$props.tempString;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler,
    		input_input_handler_1
    	];
    }

    class G4_MS_C3 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$y, create_fragment$y, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G4_MS_C3",
    			options,
    			id: create_fragment$y.name
    		});
    	}
    }

    let task01$u = {
      question: "",
      valueArray: [],  
      Options: [1, 10, 100,1000],
      variations: 0,
      randomAnswer: 0,
      answer : 0
    };
        const maxNumber$2 = 10;
        const minNumber$2 = 1;
        
    function taskOne$u() {

      task01$u.variations =  Math.floor(Math.random() * 3 - 1) + 1;
      task01$u.valueArray[0] = Math.floor(Math.random() * (maxNumber$2 - minNumber$2 + 1) ) + minNumber$2;
      task01$u.valueArray[1] = Math.floor(Math.random() * (task01$u.valueArray[0] - minNumber$2 + 1)) + minNumber$2;
      task01$u.valueArray[2] = task01$u.valueArray[0] - task01$u.valueArray[1];
      task01$u.question = "Complete the pattern:";  
      task01$u.answer = task01$u.valueArray[task01$u.variations];
      task01$u.valueArray[task01$u.variations] = 'i';
      console.log(task01$u.valueArray);
      console.log(task01$u.answer);
      return task01$u;
    }

    /* src/components/taskComponents/G4_MS_C4.svelte generated by Svelte v3.37.0 */

    const { console: console_1$1 } = globals;
    const file$w = "src/components/taskComponents/G4_MS_C4.svelte";

    function get_each_context$u(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	child_ctx[8] = list;
    	child_ctx[9] = i;
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	child_ctx[12] = i;
    	return child_ctx;
    }

    // (59:24) {#if j == task01.valueArray.length - 1}
    function create_if_block_2$1(ctx) {
    	let h4;

    	const block = {
    		c: function create() {
    			h4 = element("h4");
    			h4.textContent = "=";
    			set_style(h4, "display", "inline");
    			add_location(h4, file$w, 59, 24, 1651);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h4, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h4);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(59:24) {#if j == task01.valueArray.length - 1}",
    		ctx
    	});

    	return block;
    }

    // (62:24) {#if j == task01.valueArray.length - 2 }
    function create_if_block_1$1(ctx) {
    	let h4;

    	const block = {
    		c: function create() {
    			h4 = element("h4");
    			h4.textContent = "-";
    			set_style(h4, "display", "inline");
    			add_location(h4, file$w, 62, 24, 1809);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h4, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h4);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(62:24) {#if j == task01.valueArray.length - 2 }",
    		ctx
    	});

    	return block;
    }

    // (68:24) {:else}
    function create_else_block$s(ctx) {
    	let h4;
    	let t_value = /*value*/ ctx[10] * /*optionValue*/ ctx[7] + "";
    	let t;

    	const block = {
    		c: function create() {
    			h4 = element("h4");
    			t = text(t_value);
    			set_style(h4, "display", "inline");
    			add_location(h4, file$w, 68, 24, 2073);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h4, anchor);
    			append_dev(h4, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 4 && t_value !== (t_value = /*value*/ ctx[10] * /*optionValue*/ ctx[7] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h4);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$s.name,
    		type: "else",
    		source: "(68:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (66:24) {#if value == 'i'}
    function create_if_block$s(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	function input_input_handler() {
    		/*input_input_handler*/ ctx[6].call(input, /*i*/ ctx[9]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			add_location(input, file$w, 66, 24, 1946);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*answer*/ ctx[3][/*i*/ ctx[9]]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*answer*/ 8 && input.value !== /*answer*/ ctx[3][/*i*/ ctx[9]]) {
    				set_input_value(input, /*answer*/ ctx[3][/*i*/ ctx[9]]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$s.name,
    		type: "if",
    		source: "(66:24) {#if value == 'i'}",
    		ctx
    	});

    	return block;
    }

    // (58:24) {#each  task01.valueArray as value,j }
    function create_each_block_1$1(ctx) {
    	let t0;
    	let t1;
    	let if_block2_anchor;
    	let if_block0 = /*j*/ ctx[12] == /*task01*/ ctx[2].valueArray.length - 1 && create_if_block_2$1(ctx);
    	let if_block1 = /*j*/ ctx[12] == /*task01*/ ctx[2].valueArray.length - 2 && create_if_block_1$1(ctx);

    	function select_block_type(ctx, dirty) {
    		if (/*value*/ ctx[10] == "i") return create_if_block$s;
    		return create_else_block$s;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block2 = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if_block2.c();
    			if_block2_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*j*/ ctx[12] == /*task01*/ ctx[2].valueArray.length - 1) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_2$1(ctx);
    					if_block0.c();
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*j*/ ctx[12] == /*task01*/ ctx[2].valueArray.length - 2) {
    				if (if_block1) ; else {
    					if_block1 = create_if_block_1$1(ctx);
    					if_block1.c();
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block2) {
    				if_block2.p(ctx, dirty);
    			} else {
    				if_block2.d(1);
    				if_block2 = current_block_type(ctx);

    				if (if_block2) {
    					if_block2.c();
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(58:24) {#each  task01.valueArray as value,j }",
    		ctx
    	});

    	return block;
    }

    // (56:20) {#each  task01.Options as optionValue,i }
    function create_each_block$u(ctx) {
    	let div;
    	let t;
    	let each_value_1 = /*task01*/ ctx[2].valueArray;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			add_location(div, file$w, 56, 20, 1492);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*answer, task01*/ 12) {
    				each_value_1 = /*task01*/ ctx[2].valueArray;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, t);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$u.name,
    		type: "each",
    		source: "(56:20) {#each  task01.Options as optionValue,i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$x(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h20;
    	let t1;
    	let div5;
    	let div2;
    	let h21;
    	let t2_value = /*task01*/ ctx[2].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let t4;
    	let div3;
    	let h5;
    	let t5;
    	let t6;
    	let div4;
    	let button0;
    	let t8;
    	let button1;
    	let t10;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[2].Options;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$u(get_each_context$u(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h20 = element("h2");
    			h20.textContent = "Subtraction patterns over increasing place values";
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h21 = element("h2");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t5 = text(/*showPopUp*/ ctx[1]);
    			t6 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t8 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t10 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h20, "class", "text-center display-4 mb-0");
    			add_location(h20, file$w, 45, 10, 1136);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$w, 44, 6, 1086);
    			add_location(h21, file$w, 52, 12, 1347);
    			attr_dev(div1, "class", " p-2");
    			add_location(div1, file$w, 53, 12, 1387);
    			add_location(div2, file$w, 51, 8, 1328);
    			set_style(h5, "display", /*showNext*/ ctx[0]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$w, 78, 13, 2367);
    			add_location(div3, file$w, 77, 10, 2348);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$w, 81, 12, 2499);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$w, 82, 12, 2595);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$w, 83, 12, 2691);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$w, 80, 10, 2468);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$w, 49, 6, 1255);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$w, 43, 5, 1038);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$w, 42, 1, 1004);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h20);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h21);
    			append_dev(h21, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			append_dev(div5, t4);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t5);
    			append_dev(div5, t6);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t8);
    			append_dev(div4, button1);
    			append_dev(div4, t10);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 4 && t2_value !== (t2_value = /*task01*/ ctx[2].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01, answer*/ 12) {
    				each_value = /*task01*/ ctx[2].Options;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$u(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$u(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*showPopUp*/ 2) set_data_dev(t5, /*showPopUp*/ ctx[1]);

    			if (dirty & /*showNext*/ 1) {
    				set_style(h5, "display", /*showNext*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$x($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G4_MS_C4", slots, []);
    	let showNext = "none";
    	let showPopUp;
    	let task01 = taskOne$u();
    	let answer = [];

    	let CheckAnswer = function () {
    		for (let index = 0; index < answer.length; index++) {
    			if (answer[index] != task01.answer * task01.Options[index]) {
    				$$invalidate(1, showPopUp = randomWrong());
    				$$invalidate(0, showNext = "inline-block");
    				console.log("01");
    				break;
    			}

    			if (index == answer.length - 1) {
    				$$invalidate(1, showPopUp = randomCorrect());
    				$$invalidate(0, showNext = "inline-block");
    				console.log("02");
    			}
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(3, answer = []);
    		$$invalidate(2, task01 = taskOne$u());
    		$$invalidate(3, answer = new Array(task01.Options.length));
    		$$invalidate(0, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$1.warn(`<G4_MS_C4> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler(i) {
    		answer[i] = this.value;
    		$$invalidate(3, answer);
    	}

    	$$self.$capture_state = () => ({
    		randomCorrect,
    		randomWrong,
    		taskOne: taskOne$u,
    		showNext,
    		showPopUp,
    		task01,
    		answer,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("showNext" in $$props) $$invalidate(0, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(1, showPopUp = $$props.showPopUp);
    		if ("task01" in $$props) $$invalidate(2, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(3, answer = $$props.answer);
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		showNext,
    		showPopUp,
    		task01,
    		answer,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G4_MS_C4 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$x, create_fragment$x, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G4_MS_C4",
    			options,
    			id: create_fragment$x.name
    		});
    	}
    }

    let task01$t = {    
        question: "Choose two numbers from the box to complete the subtraction number sentence.",
        ValueOne: 0,
        ValueTwo: 0,
        answer: 0,
        sum:'-',
        option : [0,0],
        displayValues : [],
        
      };
      let arraylenght = 8;
      
      function taskOne$t() {
        let arraySize =  Math.floor(Math.random() * (arraylenght - 4)) + 4;    task01$t.displayValues = randomNumbers(arraySize,1000,1);
        let temp = randomNumbers(task01$t.option.length,task01$t.displayValues.length,0);
        for (let i = 0; i < temp.length; i++) {
            task01$t.option[i]=task01$t.displayValues[temp[i]];
        }   

        task01$t.option = task01$t.option.sort((a, b) => b - a);
        
        task01$t.answer = (task01$t.option[0] - task01$t.option[1]);    
       
        return task01$t;
      }
      

      function randomNumbers(count, max , min){
        var stop = count;
        var numbers = [];
        for (let i = 0; i < stop; i++) {
        var n =  Math.floor(Math.random() * (max - min)) + min;
        var check = numbers.includes(n);
            
            if(check === false) {
                numbers.push(n);
            } else {
                while(check === true){
                n =  Math.floor(Math.random() * (max - min)) + min;
                check = numbers.includes(n);
                    if(check === false){
                    numbers.push(n);
                    }
                }
            }
            }
        return numbers;
      }

    /* src/components/taskComponents/G4_MS_C5.svelte generated by Svelte v3.37.0 */
    const file$v = "src/components/taskComponents/G4_MS_C5.svelte";

    function get_each_context$t(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    // (63:15) {#each task01.displayValues as displayValue}
    function create_each_block$t(ctx) {
    	let div;
    	let h1;
    	let t_value = /*displayValue*/ ctx[9] + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			h1 = element("h1");
    			t = text(t_value);
    			add_location(h1, file$v, 63, 24, 1453);
    			add_location(div, file$v, 63, 19, 1448);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h1);
    			append_dev(h1, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t_value !== (t_value = /*displayValue*/ ctx[9] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$t.name,
    		type: "each",
    		source: "(63:15) {#each task01.displayValues as displayValue}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$w(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h20;
    	let t0_value = /*task01*/ ctx[0].question + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let div1;
    	let t2;
    	let input0;
    	let t3;
    	let h21;
    	let t5;
    	let input1;
    	let t6;
    	let h22;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let t10;
    	let h23;
    	let t11_value = /*task01*/ ctx[0].option + "";
    	let t11;
    	let t12;
    	let t13;
    	let div3;
    	let h5;
    	let t14;
    	let t15;
    	let div4;
    	let button0;
    	let t17;
    	let button1;
    	let t19;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].displayValues;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$t(get_each_context$t(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h20 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t2 = space();
    			input0 = element("input");
    			t3 = space();
    			h21 = element("h2");
    			h21.textContent = "-";
    			t5 = space();
    			input1 = element("input");
    			t6 = space();
    			h22 = element("h2");
    			t7 = text("have a difference of ");
    			t8 = text(t8_value);
    			t9 = text(".");
    			t10 = space();
    			h23 = element("h2");
    			t11 = text(t11_value);
    			t12 = text(".");
    			t13 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t14 = text(/*showPopUp*/ ctx[4]);
    			t15 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t17 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t19 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h20, "class", "text-center display-4 mb-0");
    			add_location(h20, file$v, 55, 9, 1175);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$v, 54, 5, 1126);
    			attr_dev(input0, "type", "text");
    			set_style(input0, "margin-left", "5px");
    			add_location(input0, file$v, 65, 15, 1528);
    			add_location(h21, file$v, 66, 15, 1614);
    			attr_dev(input1, "type", "text");
    			set_style(input1, "margin-left", "5px");
    			add_location(input1, file$v, 67, 15, 1643);
    			add_location(h22, file$v, 68, 15, 1729);
    			add_location(h23, file$v, 69, 15, 1792);
    			add_location(div1, file$v, 61, 11, 1359);
    			add_location(div2, file$v, 59, 7, 1329);
    			set_style(h5, "display", /*showNext*/ ctx[3]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$v, 74, 8, 1879);
    			add_location(div3, file$v, 73, 7, 1865);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$v, 78, 8, 1997);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$v, 79, 8, 2089);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$v, 80, 8, 2181);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$v, 77, 4, 1970);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$v, 58, 5, 1258);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$v, 53, 4, 1079);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$v, 52, 1, 1046);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h20);
    			append_dev(h20, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			append_dev(div1, t2);
    			append_dev(div1, input0);
    			set_input_value(input0, /*answer01*/ ctx[1]);
    			append_dev(div1, t3);
    			append_dev(div1, h21);
    			append_dev(div1, t5);
    			append_dev(div1, input1);
    			set_input_value(input1, /*answer02*/ ctx[2]);
    			append_dev(div1, t6);
    			append_dev(div1, h22);
    			append_dev(h22, t7);
    			append_dev(h22, t8);
    			append_dev(h22, t9);
    			append_dev(div1, t10);
    			append_dev(div1, h23);
    			append_dev(h23, t11);
    			append_dev(h23, t12);
    			append_dev(div5, t13);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t14);
    			append_dev(div5, t15);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t17);
    			append_dev(div4, button1);
    			append_dev(div4, t19);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[7]),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[8]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].question + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].displayValues;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$t(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$t(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, t2);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer01*/ 2 && input0.value !== /*answer01*/ ctx[1]) {
    				set_input_value(input0, /*answer01*/ ctx[1]);
    			}

    			if (dirty & /*answer02*/ 4 && input1.value !== /*answer02*/ ctx[2]) {
    				set_input_value(input1, /*answer02*/ ctx[2]);
    			}

    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*task01*/ 1 && t11_value !== (t11_value = /*task01*/ ctx[0].option + "")) set_data_dev(t11, t11_value);
    			if (dirty & /*showPopUp*/ 16) set_data_dev(t14, /*showPopUp*/ ctx[4]);

    			if (dirty & /*showNext*/ 8) {
    				set_style(h5, "display", /*showNext*/ ctx[3]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G4_MS_C5", slots, []);
    	let task01 = taskOne$t();
    	let answer01, answer02;
    	let showNext = "none";
    	let showPopUp;

    	let CheckAnswer = function () {
    		if (answer01 == task01.option[0] && answer02 == task01.option[1]) {
    			$$invalidate(4, showPopUp = randomCorrect());
    			$$invalidate(3, showNext = "inline-block");
    		} else if (answer01 == task01.option[1] && answer02 == task01.option[0]) {
    			$$invalidate(4, showPopUp = randomCorrect());
    			$$invalidate(3, showNext = "inline-block");
    		} else {
    			$$invalidate(4, showPopUp = randomWrong());
    			$$invalidate(3, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer01 = null);
    		$$invalidate(2, answer02 = null);
    		$$invalidate(0, task01 = taskOne$t());
    		$$invalidate(3, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G4_MS_C5> was created with unknown prop '${key}'`);
    	});

    	function input0_input_handler() {
    		answer01 = this.value;
    		$$invalidate(1, answer01);
    	}

    	function input1_input_handler() {
    		answer02 = this.value;
    		$$invalidate(2, answer02);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$t,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer01,
    		answer02,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer01" in $$props) $$invalidate(1, answer01 = $$props.answer01);
    		if ("answer02" in $$props) $$invalidate(2, answer02 = $$props.answer02);
    		if ("showNext" in $$props) $$invalidate(3, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(4, showPopUp = $$props.showPopUp);
    		if ("CheckAnswer" in $$props) $$invalidate(5, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(6, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer01,
    		answer02,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input0_input_handler,
    		input1_input_handler
    	];
    }

    class G4_MS_C5 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$w, create_fragment$w, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G4_MS_C5",
    			options,
    			id: create_fragment$w.name
    		});
    	}
    }

    let task01$s = {
      question: "Estimate the difference by rounding each number to the nearest hundred and then subtracting.",
      displayValue: 0,
      displayValueTwo: 0,
      answer: 0,
      randomAnswer: 0,
      options: [1000, 10, 100],
      Disoptions: ["thousand", "ten", "hundred"],
      variation : 0,
      operatorNum : 0,
      qstOpt : "",
      displayOptions : []

    };

    const maxNumber$1 = 10000;
    const minNumber$1 = 100;

    function taskOne$s() {
        task01$s.randomAnswer = Math.floor(Math.random() * (task01$s.options.length));
        task01$s.variation = Math.floor(Math.random() * 2);
        task01$s.displayValue = Math.floor(Math.random() * (maxNumber$1 - minNumber$1)) + minNumber$1;
        task01$s.displayValueTwo = Math.floor(Math.random() * (task01$s.displayValue - minNumber$1)) + minNumber$1;
        
        task01$s.answer = roundUp(task01$s.displayValue,task01$s.options[task01$s.randomAnswer]) - roundUp(task01$s.displayValueTwo,task01$s.options[task01$s.randomAnswer]);
        task01$s.qstOpt = task01$s.displayValue + " - " + task01$s.displayValueTwo; 
        task01$s.question = "Estimate the sum by rounding each number to the nearest "+ task01$s.Disoptions[task01$s.randomAnswer] ;

        return task01$s;
    }

    /* src/components/taskComponents/G4_MS_C6.svelte generated by Svelte v3.37.0 */
    const file$u = "src/components/taskComponents/G4_MS_C6.svelte";

    function create_fragment$v(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h20;
    	let t0_value = /*task01*/ ctx[0].question + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h21;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let h40;
    	let t4_value = /*task01*/ ctx[0].qstOpt + "";
    	let t4;
    	let t5;
    	let h41;
    	let t7;
    	let input;
    	let t8;
    	let h6;
    	let t9;
    	let t10_value = /*task01*/ ctx[0].answer + "";
    	let t10;
    	let t11;
    	let div3;
    	let h5;
    	let t12;
    	let t13;
    	let div4;
    	let button0;
    	let t15;
    	let button1;
    	let t17;
    	let button2;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h20 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h21 = element("h2");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			h40 = element("h4");
    			t4 = text(t4_value);
    			t5 = space();
    			h41 = element("h4");
    			h41.textContent = "The difference is approximately";
    			t7 = space();
    			input = element("input");
    			t8 = space();
    			h6 = element("h6");
    			t9 = text("answer");
    			t10 = text(t10_value);
    			t11 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t12 = text(/*showPopUp*/ ctx[3]);
    			t13 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t15 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t17 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h20, "class", "text-center display-4 mb-0");
    			add_location(h20, file$u, 51, 10, 931);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$u, 50, 6, 881);
    			add_location(h21, file$u, 57, 12, 1110);
    			add_location(h40, file$u, 59, 16, 1175);
    			add_location(h41, file$u, 61, 16, 1235);
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$u, 62, 16, 1294);
    			add_location(h6, file$u, 64, 16, 1412);
    			add_location(div1, file$u, 58, 12, 1149);
    			add_location(div2, file$u, 56, 8, 1091);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$u, 70, 12, 1512);
    			add_location(div3, file$u, 69, 8, 1494);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$u, 74, 12, 1646);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$u, 75, 12, 1742);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$u, 76, 12, 1838);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$u, 73, 8, 1615);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$u, 54, 6, 1017);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$u, 49, 5, 833);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$u, 48, 1, 799);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h20);
    			append_dev(h20, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h21);
    			append_dev(h21, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, h40);
    			append_dev(h40, t4);
    			append_dev(div1, t5);
    			append_dev(div1, h41);
    			append_dev(div1, t7);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t8);
    			append_dev(div1, h6);
    			append_dev(h6, t9);
    			append_dev(h6, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t12);
    			append_dev(div5, t13);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t15);
    			append_dev(div4, button1);
    			append_dev(div4, t17);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].question + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*task01*/ 1 && t4_value !== (t4_value = /*task01*/ ctx[0].qstOpt + "")) set_data_dev(t4, t4_value);

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t10_value !== (t10_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t10, t10_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t12, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$v($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G4_MS_C6", slots, []);
    	let task01 = taskOne$s();
    	let answer;
    	let showNext = "none";
    	let showPopUp;

    	let CheckAnswer = function () {
    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			$$invalidate(2, showNext = "inline-block");
    			return;
    		} else {
    			$$invalidate(3, showPopUp = randomWrong());
    			$$invalidate(2, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$s());
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G4_MS_C6> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$s,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G4_MS_C6 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$v, create_fragment$v, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G4_MS_C6",
    			options,
    			id: create_fragment$v.name
    		});
    	}
    }

    let task01$r = {
      question: "There were originally 987 houses in Columbia County. During a housing boom, developers built 820 more. About how many houses are there now in Columbia County? Choose the better estimate.",
      displayValue: 0,
      displayValueTwo: 0,
      answer: 0,
      randomAnswer: 0,
      options: [10, 100],
      Disoptions: [ "ten", "hundred"],

      operatorNum : [0,0],
      qstOpt : ""
        
    };
    const maxNumber = 1000;
    const minNumber = 10;

    function taskOne$r() {
        task01$r.randomAnswer = Math.floor(Math.random() * (task01$r.options.length));
        task01$r.displayValue = Math.floor(Math.random() * (maxNumber - minNumber)) + minNumber;   
        task01$r.displayValueTwo = Math.floor(Math.random() *(task01$r.displayValue - minNumber)) + minNumber;
        task01$r.operatorNum[0] = roundUp(task01$r.displayValue,task01$r.options[task01$r.randomAnswer]) + roundUp(task01$r.displayValueTwo,task01$r.options[task01$r.randomAnswer]);
        task01$r.operatorNum[1] = Math.abs(roundUp(task01$r.displayValue,task01$r.options[task01$r.randomAnswer]) - roundUp(task01$r.displayValueTwo,task01$r.options[task01$r.randomAnswer]));  
        task01$r.answer = roundUp(task01$r.displayValue,task01$r.options[task01$r.randomAnswer]) - roundUp(task01$r.displayValueTwo,task01$r.options[task01$r.randomAnswer]);
        task01$r.question = "There were originally "+ task01$r.displayValue + " houses in Columbia County. During a housing boom, developers built " + task01$r.displayValueTwo +" more. About how many houses are there now in Columbia County? Choose the better estimate.";
        return task01$r;
    }

    /* src/components/taskComponents/G4_MS_C7.svelte generated by Svelte v3.37.0 */
    const file$t = "src/components/taskComponents/G4_MS_C7.svelte";

    function create_fragment$u(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h20;
    	let t1;
    	let div5;
    	let div2;
    	let h21;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let h4;
    	let t5;
    	let button0;
    	let t6_value = /*task01*/ ctx[0].operatorNum[0] + "";
    	let t6;
    	let t7;
    	let button1;
    	let t8_value = /*task01*/ ctx[0].operatorNum[1] + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button2;
    	let t13;
    	let button3;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h20 = element("h2");
    			h20.textContent = "Estimate sums : word problems";
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h21 = element("h2");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			h4 = element("h4");
    			h4.textContent = "The sum is approximately";
    			t5 = space();
    			button0 = element("button");
    			t6 = text(t6_value);
    			t7 = space();
    			button1 = element("button");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[2]);
    			t11 = space();
    			div4 = element("div");
    			button2 = element("button");
    			button2.textContent = "Rerun";
    			t13 = space();
    			button3 = element("button");
    			button3.textContent = "Exit This Skill";
    			attr_dev(h20, "class", "text-center display-4 mb-0");
    			add_location(h20, file$t, 55, 10, 1033);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$t, 54, 6, 983);
    			add_location(h21, file$t, 60, 12, 1222);
    			add_location(h4, file$t, 64, 16, 1320);
    			attr_dev(button0, "class", "btn btn-outline-success");
    			add_location(button0, file$t, 65, 16, 1372);
    			attr_dev(button1, "class", "btn btn-outline-success");
    			add_location(button1, file$t, 66, 16, 1509);
    			add_location(div1, file$t, 61, 12, 1261);
    			add_location(div2, file$t, 59, 8, 1203);
    			set_style(h5, "display", /*showNext*/ ctx[1]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$t, 72, 12, 1713);
    			add_location(div3, file$t, 71, 8, 1695);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$t, 76, 12, 1847);
    			attr_dev(button3, "type", "button");
    			attr_dev(button3, "class", "btn toggle-btn");
    			add_location(button3, file$t, 77, 12, 1943);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$t, 75, 8, 1816);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$t, 58, 6, 1131);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$t, 53, 5, 935);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$t, 52, 1, 901);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h20);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h21);
    			append_dev(h21, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, h4);
    			append_dev(div1, t5);
    			append_dev(div1, button0);
    			append_dev(button0, t6);
    			append_dev(div1, t7);
    			append_dev(div1, button1);
    			append_dev(button1, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button2);
    			append_dev(div4, t13);
    			append_dev(div4, button3);

    			if (!mounted) {
    				dispose = [
    					listen_dev(
    						button0,
    						"click",
    						function () {
    							if (is_function(/*handleClick*/ ctx[4](/*task01*/ ctx[0].operatorNum[0]))) /*handleClick*/ ctx[4](/*task01*/ ctx[0].operatorNum[0]).apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						button1,
    						"click",
    						function () {
    							if (is_function(/*handleClick*/ ctx[4](/*task01*/ ctx[0].operatorNum[1]))) /*handleClick*/ ctx[4](/*task01*/ ctx[0].operatorNum[1]).apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(button2, "click", /*NextQuestion*/ ctx[3], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*task01*/ 1 && t6_value !== (t6_value = /*task01*/ ctx[0].operatorNum[0] + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].operatorNum[1] + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 4) set_data_dev(t10, /*showPopUp*/ ctx[2]);

    			if (dirty & /*showNext*/ 2) {
    				set_style(h5, "display", /*showNext*/ ctx[1]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$u($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G4_MS_C7", slots, []);
    	let task01 = taskOne$r();
    	let answer;
    	let showNext = "none";
    	let showPopUp;

    	let CheckAnswer = function () {
    		if (answer == task01.answer) {
    			$$invalidate(2, showPopUp = randomCorrect());
    			$$invalidate(1, showNext = "inline-block");
    			return;
    		} else {
    			$$invalidate(2, showPopUp = randomWrong());
    			$$invalidate(1, showNext = "inline-block");
    		}
    	};

    	let NextQuestion = function () {
    		answer = null;
    		$$invalidate(0, task01 = taskOne$r());
    		$$invalidate(1, showNext = "none");
    	};

    	const handleClick = parameter => () => {
    		answer = parameter;
    		CheckAnswer();
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G4_MS_C7> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$r,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		handleClick
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) answer = $$props.answer;
    		if ("showNext" in $$props) $$invalidate(1, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(2, showPopUp = $$props.showPopUp);
    		if ("CheckAnswer" in $$props) CheckAnswer = $$props.CheckAnswer;
    		if ("NextQuestion" in $$props) $$invalidate(3, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [task01, showNext, showPopUp, NextQuestion, handleClick];
    }

    class G4_MS_C7 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$u, create_fragment$u, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G4_MS_C7",
    			options,
    			id: create_fragment$u.name
    		});
    	}
    }

    let task01$q = {
      heading : "",
      question: "",
      valueArray: [], 
      answer: 0, 
      operator: "+",
      columns: 0
    };

    const additionvalue$9 = 1;
    const maxValue$i = 18;
    const minValue$i = 1;

    function taskOne$q() {
      task01$q.heading = "Adding 1";
      task01$q.question = "Add:";
      task01$q.answer = 0;
      task01$q.columns = 2;
      task01$q.valueArray = [];
      task01$q.valueArray[0] = Math.floor(Math.random() * (maxValue$i + minValue$i + 1) + minValue$i ) ;   
      task01$q.valueArray[1] = additionvalue$9;   
     

      task01$q.answer = task01$q.valueArray[0] + minValue$i;

      return task01$q;
    }

    /* src/components/taskComponents/G1_MA_D1.svelte generated by Svelte v3.37.0 */
    const file$s = "src/components/taskComponents/G1_MA_D1.svelte";

    function get_each_context$s(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (63:28) {:else}
    function create_else_block$r(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[8] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$s, 64, 32, 1715);
    			add_location(tr, file$s, 63, 28, 1678);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task02*/ 1 && t0_value !== (t0_value = /*col*/ ctx[8] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$r.name,
    		type: "else",
    		source: "(63:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (59:28) {#if i == (task02.valueArray.length - 1) }
    function create_if_block$r(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task02*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[8] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$s, 60, 50, 1511);
    			attr_dev(td, "align", "right");
    			add_location(td, file$s, 60, 32, 1493);
    			add_location(tr, file$s, 59, 28, 1456);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task02*/ 1 && t0_value !== (t0_value = /*task02*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task02*/ 1 && t1_value !== (t1_value = /*col*/ ctx[8] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$r.name,
    		type: "if",
    		source: "(59:28) {#if i == (task02.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (58:24) {#each task02.valueArray as col, i }
    function create_each_block$s(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[10] == /*task02*/ ctx[0].valueArray.length - 1) return create_if_block$r;
    		return create_else_block$r;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$s.name,
    		type: "each",
    		source: "(58:24) {#each task02.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$t(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task02*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task02*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task02*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task02*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$s(get_each_context$s(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$s, 43, 10, 968);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$s, 42, 6, 918);
    			add_location(h4, file$s, 50, 12, 1146);
    			attr_dev(table, "width", "100");
    			add_location(table, file$s, 55, 16, 1231);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$s, 69, 20, 1908);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$s, 70, 20, 2003);
    			add_location(h6, file$s, 71, 20, 2125);
    			add_location(div1, file$s, 53, 12, 1204);
    			add_location(div2, file$s, 47, 8, 1125);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$s, 76, 12, 2233);
    			add_location(div3, file$s, 75, 8, 2215);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$s, 80, 12, 2370);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$s, 81, 12, 2466);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$s, 82, 12, 2562);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$s, 79, 8, 2339);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$s, 46, 6, 1053);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$s, 41, 5, 870);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$s, 40, 1, 836);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t13);
    			append_dev(div4, button1);
    			append_dev(div4, t15);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task02*/ 1 && t0_value !== (t0_value = /*task02*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task02*/ 1 && t2_value !== (t2_value = /*task02*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task02*/ 1) {
    				each_value = /*task02*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$s(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$s(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task02*/ 1 && t8_value !== (t8_value = /*task02*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$t($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MA_D1", slots, []);
    	let task02 = taskOne$q();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task02.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task02 = taskOne$q());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MA_D1> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$q,
    		randomCorrect,
    		randomWrong,
    		task02,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task02" in $$props) $$invalidate(0, task02 = $$props.task02);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task02,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G1_MA_D1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$t, create_fragment$t, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MA_D1",
    			options,
    			id: create_fragment$t.name
    		});
    	}
    }

    let task01$p = {
      heading : "",
      question: "",
      valueArray: [], 
      answer: 0, 
      operator: "+",
      columns: 0
    };

    const additionvalue$8 = 2;
    const maxValue$h = 18;
    const minValue$h = 2;

    function taskOne$p() {
      task01$p.heading = "Adding 2";
      task01$p.question = "Add:";
      task01$p.answer = 0;
      task01$p.columns = 2;
      task01$p.valueArray = [];
      task01$p.valueArray[0] = Math.floor(Math.random() * (maxValue$h + minValue$h + 1) + minValue$h ) ;   
      task01$p.valueArray[1] = additionvalue$8;   

      task01$p.answer = task01$p.valueArray[0] + minValue$h;

      return task01$p;
    }

    /* src/components/taskComponents/G1_MA_D2.svelte generated by Svelte v3.37.0 */
    const file$r = "src/components/taskComponents/G1_MA_D2.svelte";

    function get_each_context$r(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (63:28) {:else}
    function create_else_block$q(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[8] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$r, 64, 32, 1715);
    			add_location(tr, file$r, 63, 28, 1678);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[8] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$q.name,
    		type: "else",
    		source: "(63:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (59:28) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$q(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[8] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$r, 60, 50, 1511);
    			attr_dev(td, "align", "right");
    			add_location(td, file$r, 60, 32, 1493);
    			add_location(tr, file$r, 59, 28, 1456);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[8] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$q.name,
    		type: "if",
    		source: "(59:28) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (58:24) {#each task01.valueArray as col, i }
    function create_each_block$r(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[10] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$q;
    		return create_else_block$q;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$r.name,
    		type: "each",
    		source: "(58:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$s(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$r(get_each_context$r(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$r, 43, 10, 968);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$r, 42, 6, 918);
    			add_location(h4, file$r, 50, 12, 1146);
    			attr_dev(table, "width", "100");
    			add_location(table, file$r, 55, 16, 1231);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$r, 69, 20, 1908);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$r, 70, 20, 2003);
    			add_location(h6, file$r, 71, 20, 2125);
    			add_location(div1, file$r, 53, 12, 1204);
    			add_location(div2, file$r, 47, 8, 1125);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$r, 76, 12, 2233);
    			add_location(div3, file$r, 75, 8, 2215);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$r, 80, 12, 2370);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$r, 81, 12, 2466);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$r, 82, 12, 2562);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$r, 79, 8, 2339);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$r, 46, 6, 1053);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$r, 41, 5, 870);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$r, 40, 1, 836);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t13);
    			append_dev(div4, button1);
    			append_dev(div4, t15);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$r(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$r(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$s($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MA_D2", slots, []);
    	let task01 = taskOne$p();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$p());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MA_D2> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$p,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G1_MA_D2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$s, create_fragment$s, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MA_D2",
    			options,
    			id: create_fragment$s.name
    		});
    	}
    }

    let task01$o = {
        heading : "",
        question: "",
        valueArray: [], 
        answer: 0, 
        operator: "+",
        columns: 0
      };
      
      const additionvalue$7 = 3;
      const maxValue$g = 18;
      const minValue$g = 1;
      
      function taskOne$o() {
        task01$o.heading = "Adding 3";
        task01$o.question = "Add:";
        task01$o.answer = 0;
        task01$o.columns = 2;
        task01$o.valueArray = [];
        task01$o.valueArray[0] = Math.floor(Math.random() * (maxValue$g + minValue$g + 1) + minValue$g ) ;   
        task01$o.valueArray[1] = additionvalue$7;   
      
        task01$o.answer = task01$o.valueArray[0] + 3;
      
        return task01$o;
      }

    /* src/components/taskComponents/G1_MA_D3.svelte generated by Svelte v3.37.0 */
    const file$q = "src/components/taskComponents/G1_MA_D3.svelte";

    function get_each_context$q(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (63:28) {:else}
    function create_else_block$p(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[8] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$q, 64, 32, 1715);
    			add_location(tr, file$q, 63, 28, 1678);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[8] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$p.name,
    		type: "else",
    		source: "(63:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (59:28) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$p(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[8] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$q, 60, 50, 1511);
    			attr_dev(td, "align", "right");
    			add_location(td, file$q, 60, 32, 1493);
    			add_location(tr, file$q, 59, 28, 1456);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[8] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$p.name,
    		type: "if",
    		source: "(59:28) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (58:24) {#each task01.valueArray as col, i }
    function create_each_block$q(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[10] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$p;
    		return create_else_block$p;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$q.name,
    		type: "each",
    		source: "(58:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$r(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$q(get_each_context$q(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$q, 43, 10, 968);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$q, 42, 6, 918);
    			add_location(h4, file$q, 50, 12, 1146);
    			attr_dev(table, "width", "100");
    			add_location(table, file$q, 55, 16, 1231);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$q, 69, 20, 1908);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$q, 70, 20, 2003);
    			add_location(h6, file$q, 71, 20, 2125);
    			add_location(div1, file$q, 53, 12, 1204);
    			add_location(div2, file$q, 47, 8, 1125);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$q, 76, 12, 2233);
    			add_location(div3, file$q, 75, 8, 2215);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$q, 80, 12, 2370);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$q, 81, 12, 2466);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$q, 82, 12, 2562);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$q, 79, 8, 2339);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$q, 46, 6, 1053);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$q, 41, 5, 870);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$q, 40, 1, 836);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t13);
    			append_dev(div4, button1);
    			append_dev(div4, t15);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$q(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$q(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MA_D3", slots, []);
    	let task01 = taskOne$o();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$o());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MA_D3> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$o,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G1_MA_D3 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$r, create_fragment$r, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MA_D3",
    			options,
    			id: create_fragment$r.name
    		});
    	}
    }

    let task01$n = {
        heading : "",
        question: "",
        valueArray: [], 
        answer: 0, 
        operator: "+",
        columns: 0
      };
      
      const additionvalue$6 = 4;
      const maxValue$f = 18;
      const minValue$f = 1;
      
      function taskOne$n() {
        task01$n.heading = "Adding 4";
        task01$n.question = "Add:";
        task01$n.answer = 0;
        task01$n.columns = 2;
        task01$n.valueArray = [];
        task01$n.valueArray[0] = Math.floor(Math.random() * (maxValue$f + minValue$f + 1) + minValue$f ) ;   
        task01$n.valueArray[1] = additionvalue$6;   
      
        task01$n.answer = task01$n.valueArray[0] + 4;
      
        return task01$n;
      }

    /* src/components/taskComponents/G1_MA_D4.svelte generated by Svelte v3.37.0 */
    const file$p = "src/components/taskComponents/G1_MA_D4.svelte";

    function get_each_context$p(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (63:28) {:else}
    function create_else_block$o(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[8] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$p, 64, 32, 1715);
    			add_location(tr, file$p, 63, 28, 1678);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[8] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$o.name,
    		type: "else",
    		source: "(63:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (59:28) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$o(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[8] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$p, 60, 50, 1511);
    			attr_dev(td, "align", "right");
    			add_location(td, file$p, 60, 32, 1493);
    			add_location(tr, file$p, 59, 28, 1456);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[8] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$o.name,
    		type: "if",
    		source: "(59:28) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (58:24) {#each task01.valueArray as col, i }
    function create_each_block$p(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[10] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$o;
    		return create_else_block$o;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$p.name,
    		type: "each",
    		source: "(58:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$q(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$p(get_each_context$p(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$p, 43, 10, 968);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$p, 42, 6, 918);
    			add_location(h4, file$p, 50, 12, 1146);
    			attr_dev(table, "width", "100");
    			add_location(table, file$p, 55, 16, 1231);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$p, 69, 20, 1908);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$p, 70, 20, 2003);
    			add_location(h6, file$p, 71, 20, 2125);
    			add_location(div1, file$p, 53, 12, 1204);
    			add_location(div2, file$p, 47, 8, 1125);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$p, 76, 12, 2233);
    			add_location(div3, file$p, 75, 8, 2215);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$p, 80, 12, 2370);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$p, 81, 12, 2466);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$p, 82, 12, 2562);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$p, 79, 8, 2339);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$p, 46, 6, 1053);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$p, 41, 5, 870);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$p, 40, 1, 836);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t13);
    			append_dev(div4, button1);
    			append_dev(div4, t15);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$p(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$p(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MA_D4", slots, []);
    	let task01 = taskOne$n();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$n());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MA_D4> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$n,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G1_MA_D4 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$q, create_fragment$q, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MA_D4",
    			options,
    			id: create_fragment$q.name
    		});
    	}
    }

    let task01$m = {
        heading : "",
        question: "",
        valueArray: [], 
        answer: 0, 
        operator: "+",
        columns: 0
      };
      
      const additionvalue$5 = 5;
      const maxValue$e = 18;
      const minValue$e = 1;
      
      function taskOne$m() {
        task01$m.heading = "Adding 5";
        task01$m.question = "Add:";
        task01$m.answer = 0;
        task01$m.columns = 2;
        task01$m.valueArray = [];
        task01$m.valueArray[0] = Math.floor(Math.random() * (maxValue$e + minValue$e + 1) + minValue$e ) ;   
        task01$m.valueArray[1] = additionvalue$5;   
      
        task01$m.answer = task01$m.valueArray[0] + 5;
      
        return task01$m;
      }

    /* src/components/taskComponents/G1_MA_D5.svelte generated by Svelte v3.37.0 */
    const file$o = "src/components/taskComponents/G1_MA_D5.svelte";

    function get_each_context$o(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (63:28) {:else}
    function create_else_block$n(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[8] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$o, 64, 32, 1715);
    			add_location(tr, file$o, 63, 28, 1678);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[8] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$n.name,
    		type: "else",
    		source: "(63:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (59:28) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$n(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[8] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$o, 60, 50, 1511);
    			attr_dev(td, "align", "right");
    			add_location(td, file$o, 60, 32, 1493);
    			add_location(tr, file$o, 59, 28, 1456);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[8] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$n.name,
    		type: "if",
    		source: "(59:28) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (58:24) {#each task01.valueArray as col, i }
    function create_each_block$o(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[10] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$n;
    		return create_else_block$n;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$o.name,
    		type: "each",
    		source: "(58:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$p(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$o(get_each_context$o(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$o, 43, 10, 968);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$o, 42, 6, 918);
    			add_location(h4, file$o, 50, 12, 1146);
    			attr_dev(table, "width", "100");
    			add_location(table, file$o, 55, 16, 1231);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$o, 69, 20, 1908);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$o, 70, 20, 2003);
    			add_location(h6, file$o, 71, 20, 2125);
    			add_location(div1, file$o, 53, 12, 1204);
    			add_location(div2, file$o, 47, 8, 1125);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$o, 76, 12, 2233);
    			add_location(div3, file$o, 75, 8, 2215);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$o, 80, 12, 2370);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$o, 81, 12, 2466);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$o, 82, 12, 2562);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$o, 79, 8, 2339);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$o, 46, 6, 1053);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$o, 41, 5, 870);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$o, 40, 1, 836);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t13);
    			append_dev(div4, button1);
    			append_dev(div4, t15);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$o(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$o(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$p($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MA_D5", slots, []);
    	let task01 = taskOne$m();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$m());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MA_D5> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$m,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G1_MA_D5 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$p, create_fragment$p, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MA_D5",
    			options,
    			id: create_fragment$p.name
    		});
    	}
    }

    let task01$l = {
        heading : "",
        question: "",
        valueArray: [], 
        answer: 0, 
        operator: "+",
        columns: 0
      };
      
      const additionvalue$4 = 6;
      const maxValue$d = 18;
      const minValue$d = 1;
      
      function taskOne$l() {
        task01$l.heading = "Adding 6";
        task01$l.question = "Add:";
        task01$l.answer = 0;
        task01$l.columns = 2;
        task01$l.valueArray = [];
        task01$l.valueArray[0] = Math.floor(Math.random() * (maxValue$d + minValue$d + 1) + minValue$d ) ;   
        task01$l.valueArray[1] = additionvalue$4;   
      
        task01$l.answer = task01$l.valueArray[0] + 6;
      
        return task01$l;
      }

    /* src/components/taskComponents/G1_MA_D6.svelte generated by Svelte v3.37.0 */
    const file$n = "src/components/taskComponents/G1_MA_D6.svelte";

    function get_each_context$n(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (63:28) {:else}
    function create_else_block$m(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[8] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$n, 64, 32, 1715);
    			add_location(tr, file$n, 63, 28, 1678);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[8] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$m.name,
    		type: "else",
    		source: "(63:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (59:28) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$m(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[8] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$n, 60, 50, 1511);
    			attr_dev(td, "align", "right");
    			add_location(td, file$n, 60, 32, 1493);
    			add_location(tr, file$n, 59, 28, 1456);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[8] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$m.name,
    		type: "if",
    		source: "(59:28) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (58:24) {#each task01.valueArray as col, i }
    function create_each_block$n(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[10] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$m;
    		return create_else_block$m;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$n.name,
    		type: "each",
    		source: "(58:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$o(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$n(get_each_context$n(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$n, 43, 10, 968);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$n, 42, 6, 918);
    			add_location(h4, file$n, 50, 12, 1146);
    			attr_dev(table, "width", "100");
    			add_location(table, file$n, 55, 16, 1231);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$n, 69, 20, 1908);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$n, 70, 20, 2003);
    			add_location(h6, file$n, 71, 20, 2125);
    			add_location(div1, file$n, 53, 12, 1204);
    			add_location(div2, file$n, 47, 8, 1125);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$n, 76, 12, 2233);
    			add_location(div3, file$n, 75, 8, 2215);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$n, 80, 12, 2370);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$n, 81, 12, 2466);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$n, 82, 12, 2562);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$n, 79, 8, 2339);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$n, 46, 6, 1053);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$n, 41, 5, 870);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$n, 40, 1, 836);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t13);
    			append_dev(div4, button1);
    			append_dev(div4, t15);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$n(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$n(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MA_D6", slots, []);
    	let task01 = taskOne$l();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$l());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MA_D6> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$l,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G1_MA_D6 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$o, create_fragment$o, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MA_D6",
    			options,
    			id: create_fragment$o.name
    		});
    	}
    }

    let task01$k = {
        heading : "",
        question: "",
        valueArray: [], 
        answer: 0, 
        operator: "+",
        columns: 0
      };
      
      const additionvalue$3 = 7;
      const maxValue$c = 18;
      const minValue$c = 1;
      
      function taskOne$k() {
        task01$k.heading = "Adding 7";
        task01$k.question = "Add:";
        task01$k.answer = 0;
        task01$k.columns = 2;
        task01$k.valueArray = [];
        task01$k.valueArray[0] = Math.floor(Math.random() * (maxValue$c + minValue$c + 1) + minValue$c ) ;   
        task01$k.valueArray[1] = additionvalue$3;   
      
        task01$k.answer = task01$k.valueArray[0] + 7;
      
        return task01$k;
      }

    /* src/components/taskComponents/G1_MA_D7.svelte generated by Svelte v3.37.0 */
    const file$m = "src/components/taskComponents/G1_MA_D7.svelte";

    function get_each_context$m(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (63:28) {:else}
    function create_else_block$l(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[8] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$m, 64, 32, 1715);
    			add_location(tr, file$m, 63, 28, 1678);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[8] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$l.name,
    		type: "else",
    		source: "(63:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (59:28) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$l(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[8] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$m, 60, 50, 1511);
    			attr_dev(td, "align", "right");
    			add_location(td, file$m, 60, 32, 1493);
    			add_location(tr, file$m, 59, 28, 1456);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[8] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$l.name,
    		type: "if",
    		source: "(59:28) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (58:24) {#each task01.valueArray as col, i }
    function create_each_block$m(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[10] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$l;
    		return create_else_block$l;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$m.name,
    		type: "each",
    		source: "(58:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$n(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$m(get_each_context$m(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$m, 43, 10, 968);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$m, 42, 6, 918);
    			add_location(h4, file$m, 50, 12, 1146);
    			attr_dev(table, "width", "100");
    			add_location(table, file$m, 55, 16, 1231);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$m, 69, 20, 1908);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$m, 70, 20, 2003);
    			add_location(h6, file$m, 71, 20, 2125);
    			add_location(div1, file$m, 53, 12, 1204);
    			add_location(div2, file$m, 47, 8, 1125);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$m, 76, 12, 2233);
    			add_location(div3, file$m, 75, 8, 2215);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$m, 80, 12, 2370);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$m, 81, 12, 2466);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$m, 82, 12, 2562);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$m, 79, 8, 2339);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$m, 46, 6, 1053);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$m, 41, 5, 870);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$m, 40, 1, 836);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t13);
    			append_dev(div4, button1);
    			append_dev(div4, t15);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$m(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$m(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MA_D7", slots, []);
    	let task01 = taskOne$k();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$k());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MA_D7> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$k,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G1_MA_D7 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$n, create_fragment$n, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MA_D7",
    			options,
    			id: create_fragment$n.name
    		});
    	}
    }

    let task01$j = {
        heading : "",
        question: "",
        valueArray: [], 
        answer: 0, 
        operator: "+",
        columns: 0
      };
      
      const additionvalue$2 = 8;
      const maxValue$b = 18;
      const minValue$b = 1;
      
      function taskOne$j() {
        task01$j.heading = "Adding 8";
        task01$j.question = "Add:";
        task01$j.answer = 0;
        task01$j.columns = 2;
        task01$j.valueArray = [];
        task01$j.valueArray[0] = Math.floor(Math.random() * (maxValue$b + minValue$b + 1) + minValue$b ) ;   
        task01$j.valueArray[1] = additionvalue$2;   
      
        task01$j.answer = task01$j.valueArray[0] + 8;
      
        return task01$j;
      }

    /* src/components/taskComponents/G1_MA_D8.svelte generated by Svelte v3.37.0 */
    const file$l = "src/components/taskComponents/G1_MA_D8.svelte";

    function get_each_context$l(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (63:28) {:else}
    function create_else_block$k(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[8] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$l, 64, 32, 1715);
    			add_location(tr, file$l, 63, 28, 1678);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[8] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$k.name,
    		type: "else",
    		source: "(63:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (59:28) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$k(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[8] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$l, 60, 50, 1511);
    			attr_dev(td, "align", "right");
    			add_location(td, file$l, 60, 32, 1493);
    			add_location(tr, file$l, 59, 28, 1456);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[8] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$k.name,
    		type: "if",
    		source: "(59:28) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (58:24) {#each task01.valueArray as col, i }
    function create_each_block$l(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[10] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$k;
    		return create_else_block$k;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$l.name,
    		type: "each",
    		source: "(58:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$m(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$l(get_each_context$l(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$l, 43, 10, 968);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$l, 42, 6, 918);
    			add_location(h4, file$l, 50, 12, 1146);
    			attr_dev(table, "width", "100");
    			add_location(table, file$l, 55, 16, 1231);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$l, 69, 20, 1908);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$l, 70, 20, 2003);
    			add_location(h6, file$l, 71, 20, 2125);
    			add_location(div1, file$l, 53, 12, 1204);
    			add_location(div2, file$l, 47, 8, 1125);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$l, 76, 12, 2233);
    			add_location(div3, file$l, 75, 8, 2215);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$l, 80, 12, 2370);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$l, 81, 12, 2466);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$l, 82, 12, 2562);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$l, 79, 8, 2339);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$l, 46, 6, 1053);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$l, 41, 5, 870);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$l, 40, 1, 836);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t13);
    			append_dev(div4, button1);
    			append_dev(div4, t15);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$l(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$l(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MA_D8", slots, []);
    	let task01 = taskOne$j();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$j());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MA_D8> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$j,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G1_MA_D8 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$m, create_fragment$m, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MA_D8",
    			options,
    			id: create_fragment$m.name
    		});
    	}
    }

    let task01$i = {
        heading : "",
        question: "",
        valueArray: [], 
        answer: 0, 
        operator: "+",
        columns: 0
      };
      
      const additionvalue$1 = 9;
      const maxValue$a = 18;
      const minValue$a = 1;
      
      function taskOne$i() {
        task01$i.heading = "Adding 9";
        task01$i.question = "Add:";
        task01$i.answer = 0;
        task01$i.columns = 2;
        task01$i.valueArray = [];
        task01$i.valueArray[0] = Math.floor(Math.random() * (maxValue$a + minValue$a + 1) + minValue$a ) ;   
        task01$i.valueArray[1] = additionvalue$1;   
      
        task01$i.answer = task01$i.valueArray[0] + 9;
      
        return task01$i;
      }

    /* src/components/taskComponents/G1_MA_D9.svelte generated by Svelte v3.37.0 */
    const file$k = "src/components/taskComponents/G1_MA_D9.svelte";

    function get_each_context$k(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (63:28) {:else}
    function create_else_block$j(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[8] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$k, 64, 32, 1715);
    			add_location(tr, file$k, 63, 28, 1678);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[8] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$j.name,
    		type: "else",
    		source: "(63:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (59:28) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$j(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[8] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$k, 60, 50, 1511);
    			attr_dev(td, "align", "right");
    			add_location(td, file$k, 60, 32, 1493);
    			add_location(tr, file$k, 59, 28, 1456);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[8] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$j.name,
    		type: "if",
    		source: "(59:28) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (58:24) {#each task01.valueArray as col, i }
    function create_each_block$k(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[10] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$j;
    		return create_else_block$j;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$k.name,
    		type: "each",
    		source: "(58:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$l(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$k(get_each_context$k(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$k, 43, 10, 968);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$k, 42, 6, 918);
    			add_location(h4, file$k, 50, 12, 1146);
    			attr_dev(table, "width", "100");
    			add_location(table, file$k, 55, 16, 1231);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$k, 69, 20, 1908);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$k, 70, 20, 2003);
    			add_location(h6, file$k, 71, 20, 2125);
    			add_location(div1, file$k, 53, 12, 1204);
    			add_location(div2, file$k, 47, 8, 1125);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$k, 76, 12, 2233);
    			add_location(div3, file$k, 75, 8, 2215);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$k, 80, 12, 2370);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$k, 81, 12, 2466);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$k, 82, 12, 2562);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$k, 79, 8, 2339);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$k, 46, 6, 1053);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$k, 41, 5, 870);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$k, 40, 1, 836);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t13);
    			append_dev(div4, button1);
    			append_dev(div4, t15);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$k(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$k(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MA_D9", slots, []);
    	let task01 = taskOne$i();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$i());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MA_D9> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$i,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G1_MA_D9 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$l, create_fragment$l, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MA_D9",
    			options,
    			id: create_fragment$l.name
    		});
    	}
    }

    let task01$h = {
        heading : "",
        question: "",
        valueArray: [], 
        answer: 0, 
        operator: "+",
        columns: 0
      };
      
      const additionvalue = 0;
      const maxValue$9 = 18;
      const minValue$9 = 1;
      
      function taskOne$h() {
        task01$h.heading = "Adding 0";
        task01$h.question = "Add:";
        task01$h.answer = 0;
        task01$h.columns = 2;
        task01$h.valueArray = [];
        task01$h.valueArray[0] = Math.floor(Math.random() * (maxValue$9 + minValue$9 + 1) + minValue$9 ) ;   
        task01$h.valueArray[1] = additionvalue;   
      
        task01$h.answer = task01$h.valueArray[0] ;
      
        return task01$h;
      }

    /* src/components/taskComponents/G1_MA_D10.svelte generated by Svelte v3.37.0 */
    const file$j = "src/components/taskComponents/G1_MA_D10.svelte";

    function get_each_context$j(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (63:28) {:else}
    function create_else_block$i(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[8] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$j, 64, 32, 1716);
    			add_location(tr, file$j, 63, 28, 1679);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[8] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$i.name,
    		type: "else",
    		source: "(63:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (59:28) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$i(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[8] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$j, 60, 50, 1512);
    			attr_dev(td, "align", "right");
    			add_location(td, file$j, 60, 32, 1494);
    			add_location(tr, file$j, 59, 28, 1457);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[8] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$i.name,
    		type: "if",
    		source: "(59:28) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (58:24) {#each task01.valueArray as col, i }
    function create_each_block$j(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[10] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$i;
    		return create_else_block$i;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$j.name,
    		type: "each",
    		source: "(58:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$k(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$j(get_each_context$j(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$j, 43, 10, 969);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$j, 42, 6, 919);
    			add_location(h4, file$j, 50, 12, 1147);
    			attr_dev(table, "width", "100");
    			add_location(table, file$j, 55, 16, 1232);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$j, 69, 20, 1909);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$j, 70, 20, 2004);
    			add_location(h6, file$j, 71, 20, 2126);
    			add_location(div1, file$j, 53, 12, 1205);
    			add_location(div2, file$j, 47, 8, 1126);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$j, 76, 12, 2234);
    			add_location(div3, file$j, 75, 8, 2216);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$j, 80, 12, 2371);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$j, 81, 12, 2467);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$j, 82, 12, 2563);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$j, 79, 8, 2340);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$j, 46, 6, 1054);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$j, 41, 5, 871);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$j, 40, 1, 837);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t13);
    			append_dev(div4, button1);
    			append_dev(div4, t15);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$j(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$j(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MA_D10", slots, []);
    	let task01 = taskOne$h();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$h());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MA_D10> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$h,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G1_MA_D10 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$k, create_fragment$k, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MA_D10",
    			options,
    			id: create_fragment$k.name
    		});
    	}
    }

    let task01$g = {
        heading : "",
        question: "",
        valueArray: [], 
        answer: 0, 
        operator: "+",
        columns: 0
       
      };

      function taskOne$g() {
        task01$g.heading = "Add Doubles";
        task01$g.question = "Add the doubles.";
        task01$g.answer = 0;
        task01$g.columns = 2;
        task01$g.valueArray = [];
        
        task01$g.valueArray[0] = Math.floor(Math.random() * 10  + 1  ) ;   
        task01$g.valueArray[1] = Math.floor(Math.random() * 10  + 1  )  ;   
        task01$g.answer = task01$g.valueArray[0]  =  task01$g.valueArray[1] ;
        
        task01$g.answer = task01$g.valueArray[0] + task01$g.valueArray[1]  ;
        return task01$g;
      }

    /* src/components/taskComponents/G1_MA_F1.svelte generated by Svelte v3.37.0 */
    const file$i = "src/components/taskComponents/G1_MA_F1.svelte";

    function get_each_context$i(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (63:28) {:else}
    function create_else_block$h(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[8] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$i, 64, 32, 1715);
    			add_location(tr, file$i, 63, 28, 1678);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[8] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$h.name,
    		type: "else",
    		source: "(63:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (59:28) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$h(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[8] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$i, 60, 50, 1511);
    			attr_dev(td, "align", "right");
    			add_location(td, file$i, 60, 32, 1493);
    			add_location(tr, file$i, 59, 28, 1456);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[8] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$h.name,
    		type: "if",
    		source: "(59:28) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (58:24) {#each task01.valueArray as col, i }
    function create_each_block$i(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[10] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$h;
    		return create_else_block$h;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$i.name,
    		type: "each",
    		source: "(58:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$j(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$i(get_each_context$i(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$i, 43, 10, 968);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$i, 42, 6, 918);
    			add_location(h4, file$i, 50, 12, 1146);
    			attr_dev(table, "width", "100");
    			add_location(table, file$i, 55, 16, 1231);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$i, 69, 20, 1908);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$i, 70, 20, 2003);
    			add_location(h6, file$i, 71, 20, 2125);
    			add_location(div1, file$i, 53, 12, 1204);
    			add_location(div2, file$i, 47, 8, 1125);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$i, 76, 12, 2233);
    			add_location(div3, file$i, 75, 8, 2215);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$i, 80, 12, 2370);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$i, 81, 12, 2466);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$i, 82, 12, 2562);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$i, 79, 8, 2339);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$i, 46, 6, 1053);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$i, 41, 5, 870);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$i, 40, 1, 836);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t13);
    			append_dev(div4, button1);
    			append_dev(div4, t15);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$i(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$i(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MA_F1", slots, []);
    	let task01 = taskOne$g();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$g());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MA_F1> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$g,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G1_MA_F1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$j, create_fragment$j, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MA_F1",
    			options,
    			id: create_fragment$j.name
    		});
    	}
    }

    let task01$f = {
        heading : "",
        question: "",
        valueArray: [], 
        answer: 0, 
        operator: "+",
        columns: 0
       
      };

      function taskOne$f() {
        task01$f.heading = "Add using double plus 1 one";
        task01$f.question = "Add the near doubles.";
        task01$f.answer = 0;
        task01$f.columns = 2;
        task01$f.valueArray = [];
        
        task01$f.valueArray[0] = Math.floor(Math.random() * 10  + 1  ) ;   
        task01$f.valueArray[1] = Math.floor(Math.random() * 10  + 1  )  ;   
        task01$f.answer = task01$f.valueArray[1]  =  task01$f.valueArray[0] + 1 ;
        
        task01$f.answer = task01$f.valueArray[0] + task01$f.valueArray[1]  ;
        return task01$f;
      }

    /* src/components/taskComponents/G1_MA_F2.svelte generated by Svelte v3.37.0 */
    const file$h = "src/components/taskComponents/G1_MA_F2.svelte";

    function get_each_context$h(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (63:28) {:else}
    function create_else_block$g(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[8] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$h, 64, 32, 1715);
    			add_location(tr, file$h, 63, 28, 1678);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[8] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$g.name,
    		type: "else",
    		source: "(63:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (59:28) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$g(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[8] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$h, 60, 50, 1511);
    			attr_dev(td, "align", "right");
    			add_location(td, file$h, 60, 32, 1493);
    			add_location(tr, file$h, 59, 28, 1456);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[8] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$g.name,
    		type: "if",
    		source: "(59:28) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (58:24) {#each task01.valueArray as col, i }
    function create_each_block$h(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[10] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$g;
    		return create_else_block$g;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$h.name,
    		type: "each",
    		source: "(58:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$i(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$h(get_each_context$h(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$h, 43, 10, 968);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$h, 42, 6, 918);
    			add_location(h4, file$h, 50, 12, 1146);
    			attr_dev(table, "width", "100");
    			add_location(table, file$h, 55, 16, 1231);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$h, 69, 20, 1908);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$h, 70, 20, 2003);
    			add_location(h6, file$h, 71, 20, 2125);
    			add_location(div1, file$h, 53, 12, 1204);
    			add_location(div2, file$h, 47, 8, 1125);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$h, 76, 12, 2233);
    			add_location(div3, file$h, 75, 8, 2215);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$h, 80, 12, 2370);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$h, 81, 12, 2466);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$h, 82, 12, 2562);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$h, 79, 8, 2339);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$h, 46, 6, 1053);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$h, 41, 5, 870);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$h, 40, 1, 836);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t13);
    			append_dev(div4, button1);
    			append_dev(div4, t15);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$h(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$h(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MA_F2", slots, []);
    	let task01 = taskOne$f();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$f());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MA_F2> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$f,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G1_MA_F2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$i, create_fragment$i, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MA_F2",
    			options,
    			id: create_fragment$i.name
    		});
    	}
    }

    let task01$e = {
        heading : "",
        question: "",
        valueArray: [], 
        answer: 0, 
        operator: "+",
        columns: 0
       
      };

      function taskOne$e() {
        task01$e.heading = "Add using doubles minus one ";
        task01$e.question = "Add the near doubles.";
        task01$e.answer = 0;
        task01$e.columns = 2;
        task01$e.valueArray = [];
        
        task01$e.valueArray[0] = Math.floor(Math.random() * 10  + 1  ) ;   
        task01$e.valueArray[1] = Math.floor(Math.random() * 10  + 1  )  ;  
       
        task01$e.answer = task01$e.valueArray[1]  =  task01$e.valueArray[0] - 1 ;
        
        task01$e.answer = task01$e.valueArray[0] + task01$e.valueArray[1]  ;
        return task01$e;
      }

    /* src/components/taskComponents/G1_MA_F3.svelte generated by Svelte v3.37.0 */
    const file$g = "src/components/taskComponents/G1_MA_F3.svelte";

    function get_each_context$g(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (63:28) {:else}
    function create_else_block$f(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[8] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$g, 64, 32, 1715);
    			add_location(tr, file$g, 63, 28, 1678);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[8] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$f.name,
    		type: "else",
    		source: "(63:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (59:28) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$f(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[8] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$g, 60, 50, 1511);
    			attr_dev(td, "align", "right");
    			add_location(td, file$g, 60, 32, 1493);
    			add_location(tr, file$g, 59, 28, 1456);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[8] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$f.name,
    		type: "if",
    		source: "(59:28) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (58:24) {#each task01.valueArray as col, i }
    function create_each_block$g(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[10] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$f;
    		return create_else_block$f;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$g.name,
    		type: "each",
    		source: "(58:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$h(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$g(get_each_context$g(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$g, 43, 10, 968);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$g, 42, 6, 918);
    			add_location(h4, file$g, 50, 12, 1146);
    			attr_dev(table, "width", "100");
    			add_location(table, file$g, 55, 16, 1231);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$g, 69, 20, 1908);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$g, 70, 20, 2003);
    			add_location(h6, file$g, 71, 20, 2125);
    			add_location(div1, file$g, 53, 12, 1204);
    			add_location(div2, file$g, 47, 8, 1125);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$g, 76, 12, 2233);
    			add_location(div3, file$g, 75, 8, 2215);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$g, 80, 12, 2370);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$g, 81, 12, 2466);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$g, 82, 12, 2562);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$g, 79, 8, 2339);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$g, 46, 6, 1053);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$g, 41, 5, 870);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$g, 40, 1, 836);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t13);
    			append_dev(div4, button1);
    			append_dev(div4, t15);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$g(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$g(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MA_F3", slots, []);
    	let task01 = taskOne$e();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$e());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MA_F3> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$e,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G1_MA_F3 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$h, create_fragment$h, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MA_F3",
    			options,
    			id: create_fragment$h.name
    		});
    	}
    }

    let task01$d = {
        heading : "",
        question: "",
        valueArray: [], 
        answer: 0, 
        operator: "+",
        columns: 0
       
      };
      
     
      //const Value = 10;

      function taskOne$d() {
        task01$d.heading = "Add three numbers - use doubles ";
        task01$d.question = "Add:";
        task01$d.answer = 0;
        task01$d.columns = 2;
        task01$d.valueArray = [];
        
        task01$d.valueArray[0] = Math.floor(Math.random() * 5 + 1  ) ;   
        task01$d.valueArray[1] = Math.floor(Math.random() * 5  + 1  )  ;  
        task01$d.valueArray[2] = Math.floor(Math.random() * 5  + 1  )  ;  
       
        task01$d.answer = task01$d.valueArray[0]  =  task01$d.valueArray[2]  ;
        
        task01$d.answer = task01$d.valueArray[0] + task01$d.valueArray[1] + task01$d.valueArray[2];
        return task01$d;
      }

    /* src/components/taskComponents/G1_MA_F4.svelte generated by Svelte v3.37.0 */
    const file$f = "src/components/taskComponents/G1_MA_F4.svelte";

    function get_each_context$f(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (63:28) {:else}
    function create_else_block$e(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[8] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$f, 64, 32, 1715);
    			add_location(tr, file$f, 63, 28, 1678);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[8] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$e.name,
    		type: "else",
    		source: "(63:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (59:28) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$e(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[8] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$f, 60, 50, 1511);
    			attr_dev(td, "align", "right");
    			add_location(td, file$f, 60, 32, 1493);
    			add_location(tr, file$f, 59, 28, 1456);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[8] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$e.name,
    		type: "if",
    		source: "(59:28) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (58:24) {#each task01.valueArray as col, i }
    function create_each_block$f(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[10] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$e;
    		return create_else_block$e;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$f.name,
    		type: "each",
    		source: "(58:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$g(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$f(get_each_context$f(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$f, 43, 10, 968);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$f, 42, 6, 918);
    			add_location(h4, file$f, 50, 12, 1146);
    			attr_dev(table, "width", "100");
    			add_location(table, file$f, 55, 16, 1231);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$f, 69, 20, 1908);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$f, 70, 20, 2003);
    			add_location(h6, file$f, 71, 20, 2125);
    			add_location(div1, file$f, 53, 12, 1204);
    			add_location(div2, file$f, 47, 8, 1125);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$f, 76, 12, 2233);
    			add_location(div3, file$f, 75, 8, 2215);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$f, 80, 12, 2370);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$f, 81, 12, 2466);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$f, 82, 12, 2562);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$f, 79, 8, 2339);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$f, 46, 6, 1053);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$f, 41, 5, 870);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$f, 40, 1, 836);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t13);
    			append_dev(div4, button1);
    			append_dev(div4, t15);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$f(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$f(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MA_F4", slots, []);
    	let task01 = taskOne$d();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$d());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MA_F4> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$d,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G1_MA_F4 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$g, create_fragment$g, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MA_F4",
    			options,
    			id: create_fragment$g.name
    		});
    	}
    }

    let task01$c = {
        heading : "",
        question: "",
        valueArray: [], 
        answer: 0, 
        operator: "+",
        columns: 0
       
      };
      
     
      //const Value = 10;

      function taskOne$c() {
        task01$c.heading = "Add three numbers - make ten ";
        task01$c.question = "Add:";
        task01$c.answer = 0;
        task01$c.columns = 2;
        task01$c.valueArray = [];
        
        task01$c.valueArray[0] = 5 ;   
        task01$c.valueArray[1] = 5  ;  
        task01$c.valueArray[2] = Math.floor(Math.random() * 5 ) + 1   ;  
       
        task01$c.answer = task01$c.valueArray[0]  =  task01$c.valueArray[1]  ;
        
        task01$c.answer = task01$c.valueArray[0] + task01$c.valueArray[1] + task01$c.valueArray[2] ;
        return task01$c;
      }

    /* src/components/taskComponents/G1_MA_F6.svelte generated by Svelte v3.37.0 */
    const file$e = "src/components/taskComponents/G1_MA_F6.svelte";

    function get_each_context$e(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (63:28) {:else}
    function create_else_block$d(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[8] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$e, 64, 32, 1715);
    			add_location(tr, file$e, 63, 28, 1678);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[8] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$d.name,
    		type: "else",
    		source: "(63:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (59:28) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$d(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[8] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$e, 60, 50, 1511);
    			attr_dev(td, "align", "right");
    			add_location(td, file$e, 60, 32, 1493);
    			add_location(tr, file$e, 59, 28, 1456);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[8] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(59:28) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (58:24) {#each task01.valueArray as col, i }
    function create_each_block$e(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[10] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$d;
    		return create_else_block$d;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$e.name,
    		type: "each",
    		source: "(58:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$f(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$e(get_each_context$e(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$e, 43, 10, 968);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$e, 42, 6, 918);
    			add_location(h4, file$e, 50, 12, 1146);
    			attr_dev(table, "width", "100");
    			add_location(table, file$e, 55, 16, 1231);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$e, 69, 20, 1908);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$e, 70, 20, 2003);
    			add_location(h6, file$e, 71, 20, 2125);
    			add_location(div1, file$e, 53, 12, 1204);
    			add_location(div2, file$e, 47, 8, 1125);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$e, 76, 12, 2233);
    			add_location(div3, file$e, 75, 8, 2215);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$e, 80, 12, 2370);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$e, 81, 12, 2466);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$e, 82, 12, 2562);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$e, 79, 8, 2339);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$e, 46, 6, 1053);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$e, 41, 5, 870);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$e, 40, 1, 836);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t13);
    			append_dev(div4, button1);
    			append_dev(div4, t15);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$e(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$e(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MA_F6", slots, []);
    	let task01 = taskOne$c();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$c());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MA_F6> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$c,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G1_MA_F6 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$f, create_fragment$f, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MA_F6",
    			options,
    			id: create_fragment$f.name
    		});
    	}
    }

    let task01$b = {
        heading : "",
        question: "",
        valueArray: [], 
        answer: 0, 
        operator: "+",
        columns: 0
       
      };
      
     
      //const Value = 10;

      function taskOne$b() {
        task01$b.heading = "Add two multiples of ten ";
        task01$b.question = "Add:";
        task01$b.answer = 0;
        task01$b.columns = 2;
        task01$b.valueArray = [];
        
        task01$b.valueArray[0] = Math.floor(Math.random()* 5 + 1 ) * 10  ;   
        task01$b.valueArray[1] = Math.floor(Math.random()* 5 + 1 ) * 10  ;  
          
       
        //task01.answer = task01.valueArray[0]  =  task01.valueArray[1]  ;
        
        task01$b.answer = task01$b.valueArray[0] + task01$b.valueArray[1]  ;
        return task01$b;
      }

    /* src/components/taskComponents/G1_MA_F7.svelte generated by Svelte v3.37.0 */
    const file$d = "src/components/taskComponents/G1_MA_F7.svelte";

    function get_each_context$d(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (63:28) {:else}
    function create_else_block$c(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[8] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$d, 64, 32, 1715);
    			add_location(tr, file$d, 63, 28, 1678);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[8] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$c.name,
    		type: "else",
    		source: "(63:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (59:28) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$c(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[8] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$d, 60, 50, 1511);
    			attr_dev(td, "align", "right");
    			add_location(td, file$d, 60, 32, 1493);
    			add_location(tr, file$d, 59, 28, 1456);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[8] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(59:28) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (58:24) {#each task01.valueArray as col, i }
    function create_each_block$d(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[10] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$c;
    		return create_else_block$c;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$d.name,
    		type: "each",
    		source: "(58:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$d(get_each_context$d(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$d, 43, 10, 968);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$d, 42, 6, 918);
    			add_location(h4, file$d, 50, 12, 1146);
    			attr_dev(table, "width", "100");
    			add_location(table, file$d, 55, 16, 1231);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$d, 69, 20, 1908);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$d, 70, 20, 2003);
    			add_location(h6, file$d, 71, 20, 2125);
    			add_location(div1, file$d, 53, 12, 1204);
    			add_location(div2, file$d, 47, 8, 1125);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$d, 76, 12, 2233);
    			add_location(div3, file$d, 75, 8, 2215);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$d, 80, 12, 2370);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$d, 81, 12, 2466);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$d, 82, 12, 2562);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$d, 79, 8, 2339);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$d, 46, 6, 1053);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$d, 41, 5, 870);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$d, 40, 1, 836);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t13);
    			append_dev(div4, button1);
    			append_dev(div4, t15);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$d(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$d(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MA_F7", slots, []);
    	let task01 = taskOne$b();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$b());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MA_F7> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$b,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G1_MA_F7 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$e, create_fragment$e, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MA_F7",
    			options,
    			id: create_fragment$e.name
    		});
    	}
    }

    let task01$a = {
        heading : "",
        question: "",
        valueArray: [], 
        answer: 0, 
        operator: "+",
        columns: 0
       
      };
      
     
      //const Value = 10;

      function taskOne$a() {
        task01$a.heading = "Add a multiple of ten ";
        task01$a.question = "Add:";
        task01$a.answer = 0;
        task01$a.columns = 2;
        task01$a.valueArray = [];
        
        task01$a.valueArray[0] = Math.floor(Math.random()* 7 + 1 ) * 10  ;   
        task01$a.valueArray[1] = Math.floor(Math.random()* 30 + 1 )  ;  
          
       
        //task01.answer = task01.valueArray[0]  =  task01.valueArray[1]  ;
        
        task01$a.answer = task01$a.valueArray[0] + task01$a.valueArray[1]  ;
        return task01$a;
      }

    /* src/components/taskComponents/G1_MA_F8.svelte generated by Svelte v3.37.0 */
    const file$c = "src/components/taskComponents/G1_MA_F8.svelte";

    function get_each_context$c(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (63:28) {:else}
    function create_else_block$b(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[8] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$c, 64, 32, 1715);
    			add_location(tr, file$c, 63, 28, 1678);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[8] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$b.name,
    		type: "else",
    		source: "(63:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (59:28) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$b(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[8] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$c, 60, 50, 1511);
    			attr_dev(td, "align", "right");
    			add_location(td, file$c, 60, 32, 1493);
    			add_location(tr, file$c, 59, 28, 1456);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[8] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(59:28) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (58:24) {#each task01.valueArray as col, i }
    function create_each_block$c(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[10] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$b;
    		return create_else_block$b;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$c.name,
    		type: "each",
    		source: "(58:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$c(get_each_context$c(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$c, 43, 10, 968);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$c, 42, 6, 918);
    			add_location(h4, file$c, 50, 12, 1146);
    			attr_dev(table, "width", "100");
    			add_location(table, file$c, 55, 16, 1231);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$c, 69, 20, 1908);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$c, 70, 20, 2003);
    			add_location(h6, file$c, 71, 20, 2125);
    			add_location(div1, file$c, 53, 12, 1204);
    			add_location(div2, file$c, 47, 8, 1125);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$c, 76, 12, 2233);
    			add_location(div3, file$c, 75, 8, 2215);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$c, 80, 12, 2370);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$c, 81, 12, 2466);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$c, 82, 12, 2562);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$c, 79, 8, 2339);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$c, 46, 6, 1053);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$c, 41, 5, 870);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$c, 40, 1, 836);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t13);
    			append_dev(div4, button1);
    			append_dev(div4, t15);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$c(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$c(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MA_F8", slots, []);
    	let task01 = taskOne$a();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$a());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MA_F8> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$a,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G1_MA_F8 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$d, create_fragment$d, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MA_F8",
    			options,
    			id: create_fragment$d.name
    		});
    	}
    }

    let task01$9 = {
        heading : "",
        question: "",
        valueArray: [], 
        answer: 0, 
        operator: "+",
        columns: 0
       
      };
      
     
      //const Value = 10;

      function taskOne$9() {
        task01$9.heading = "Add three numbers  ";
        task01$9.question = "Add:";
        task01$9.answer = 0;
        task01$9.columns = 2;
        task01$9.valueArray = [];
        
        task01$9.valueArray[0] = Math.floor(Math.random() * 5  +  1  )  ;   
        task01$9.valueArray[1] = Math.floor(Math.random() * 5  +  1  )  ;  
        task01$9.valueArray[2] = Math.floor(Math.random() * 5  +  1  )  ;  
       
        task01$9.answer = task01$9.valueArray[0]  =  task01$9.valueArray[1]  ;
        
        task01$9.answer = task01$9.valueArray[0] + task01$9.valueArray[1] + task01$9.valueArray[2];
        return task01$9;
      }

    /* src/components/taskComponents/G1_MA_F9.svelte generated by Svelte v3.37.0 */
    const file$b = "src/components/taskComponents/G1_MA_F9.svelte";

    function get_each_context$b(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (63:28) {:else}
    function create_else_block$a(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[8] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$b, 64, 32, 1715);
    			add_location(tr, file$b, 63, 28, 1678);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[8] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$a.name,
    		type: "else",
    		source: "(63:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (59:28) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$a(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[8] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$b, 60, 50, 1511);
    			attr_dev(td, "align", "right");
    			add_location(td, file$b, 60, 32, 1493);
    			add_location(tr, file$b, 59, 28, 1456);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[8] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(59:28) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (58:24) {#each task01.valueArray as col, i }
    function create_each_block$b(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[10] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$a;
    		return create_else_block$a;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$b.name,
    		type: "each",
    		source: "(58:24) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$b(get_each_context$b(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$b, 43, 10, 968);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$b, 42, 6, 918);
    			add_location(h4, file$b, 50, 12, 1146);
    			attr_dev(table, "width", "100");
    			add_location(table, file$b, 55, 16, 1231);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$b, 69, 20, 1908);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$b, 70, 20, 2003);
    			add_location(h6, file$b, 71, 20, 2125);
    			add_location(div1, file$b, 53, 12, 1204);
    			add_location(div2, file$b, 47, 8, 1125);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$b, 76, 12, 2233);
    			add_location(div3, file$b, 75, 8, 2215);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$b, 80, 12, 2370);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$b, 81, 12, 2466);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$b, 82, 12, 2562);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$b, 79, 8, 2339);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$b, 46, 6, 1053);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$b, 41, 5, 870);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$b, 40, 1, 836);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t13);
    			append_dev(div4, button1);
    			append_dev(div4, t15);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$b(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$b(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MA_F9", slots, []);
    	let task01 = taskOne$9();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$9());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MA_F9> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$9,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G1_MA_F9 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$c, create_fragment$c, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MA_F9",
    			options,
    			id: create_fragment$c.name
    		});
    	}
    }

    let task01$8 = {
        heading : "",
        question: "",
        valueArray: [], 
        answer: 0, 
        operator: "-",
        columns: 0
      };
      
      const substractionvalue$7 = 2;
      const maxValue$8 = 18;
      const minValue$8 = 2;
      
      function taskOne$8() {
        task01$8.heading = "Subtracting 2";
        task01$8.question = "Subtract:";
        task01$8.answer = 0;
        task01$8.columns = 2;
        task01$8.valueArray = [];
        task01$8.valueArray[0] = Math.floor(Math.random() * (maxValue$8 - minValue$8 + 1) + minValue$8 ) ;   
        task01$8.valueArray[1] = substractionvalue$7;   
      
        task01$8.answer = task01$8.valueArray[0] - minValue$8;
      
        return task01$8;
      }

    /* src/components/taskComponents/G1_MS_H2.svelte generated by Svelte v3.37.0 */
    const file$a = "src/components/taskComponents/G1_MS_H2.svelte";

    function get_each_context$a(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (67:27) {:else}
    function create_else_block$9(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[8] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$a, 68, 31, 1501);
    			add_location(tr, file$a, 67, 27, 1465);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[8] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$9.name,
    		type: "else",
    		source: "(67:27) {:else}",
    		ctx
    	});

    	return block;
    }

    // (63:27) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$9(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[8] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$a, 64, 49, 1301);
    			attr_dev(td, "align", "right");
    			add_location(td, file$a, 64, 31, 1283);
    			add_location(tr, file$a, 63, 27, 1247);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[8] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(63:27) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (62:23) {#each task01.valueArray as col, i }
    function create_each_block$a(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[10] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$9;
    		return create_else_block$9;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$a.name,
    		type: "each",
    		source: "(62:23) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$b(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$a, 47, 9, 772);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$a, 46, 5, 723);
    			add_location(h4, file$a, 54, 11, 945);
    			attr_dev(table, "width", "100");
    			add_location(table, file$a, 59, 15, 1026);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$a, 73, 19, 1689);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$a, 74, 19, 1783);
    			add_location(h6, file$a, 75, 19, 1904);
    			add_location(div1, file$a, 57, 11, 1000);
    			add_location(div2, file$a, 51, 7, 925);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$a, 80, 11, 2007);
    			add_location(div3, file$a, 79, 7, 1990);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$a, 84, 11, 2140);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$a, 85, 11, 2235);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$a, 86, 11, 2330);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$a, 83, 7, 2110);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$a, 50, 5, 854);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$a, 45, 4, 676);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$a, 44, 0, 643);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t13);
    			append_dev(div4, button1);
    			append_dev(div4, t15);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$a(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$a(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MS_H2", slots, []);
    	let task01 = taskOne$8();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if ($$invalidate(1, answer = task01.answer)) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$8());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MS_H2> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$8,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G1_MS_H2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$b, create_fragment$b, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MS_H2",
    			options,
    			id: create_fragment$b.name
    		});
    	}
    }

    let task01$7 = {
        heading : "",
        question: "",
        valueArray: [], 
        answer: 0, 
        operator: "-",
        columns: 0
      };
      
      const substractionvalue$6 = 3;
      const maxValue$7 = 18;
      const minValue$7 = 3;
      
      function taskOne$7() {
        task01$7.heading = "Subtracting 3";
        task01$7.question = "Subtract:";
        task01$7.answer = 0;
        task01$7.columns = 2;
        task01$7.valueArray = [];
        task01$7.valueArray[0] = Math.floor(Math.random() * (maxValue$7 - minValue$7 + 1) + minValue$7 ) ;   
        task01$7.valueArray[1] = substractionvalue$6;   
      
        task01$7.answer = task01$7.valueArray[0] - minValue$7;
      
        return task01$7;
      }

    /* src/components/taskComponents/G1_MS_H3.svelte generated by Svelte v3.37.0 */
    const file$9 = "src/components/taskComponents/G1_MS_H3.svelte";

    function get_each_context$9(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (67:31) {:else}
    function create_else_block$8(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[8] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$9, 68, 35, 1769);
    			add_location(tr, file$9, 67, 31, 1729);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[8] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$8.name,
    		type: "else",
    		source: "(67:31) {:else}",
    		ctx
    	});

    	return block;
    }

    // (63:31) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$8(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[8] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$9, 64, 53, 1553);
    			attr_dev(td, "align", "right");
    			add_location(td, file$9, 64, 35, 1535);
    			add_location(tr, file$9, 63, 31, 1495);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[8] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(63:31) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (62:27) {#each task01.valueArray as col, i }
    function create_each_block$9(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[10] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$8;
    		return create_else_block$8;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$9.name,
    		type: "each",
    		source: "(62:27) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$a(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$9, 47, 13, 956);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$9, 46, 9, 903);
    			add_location(h4, file$9, 54, 15, 1157);
    			attr_dev(table, "width", "100");
    			add_location(table, file$9, 59, 19, 1258);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$9, 73, 23, 1977);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$9, 74, 23, 2075);
    			add_location(h6, file$9, 75, 23, 2200);
    			add_location(div1, file$9, 57, 15, 1224);
    			add_location(div2, file$9, 51, 11, 1125);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$9, 80, 15, 2323);
    			add_location(div3, file$9, 79, 11, 2302);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$9, 84, 15, 2472);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$9, 85, 15, 2571);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$9, 86, 15, 2670);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$9, 83, 11, 2438);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$9, 50, 9, 1050);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$9, 45, 8, 852);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$9, 44, 4, 815);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t13);
    			append_dev(div4, button1);
    			append_dev(div4, t15);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$9(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$9(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MS_H3", slots, []);
    	let task01 = taskOne$7();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if ($$invalidate(1, answer = task01.answer)) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$7());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MS_H3> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$7,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G1_MS_H3 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$a, create_fragment$a, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MS_H3",
    			options,
    			id: create_fragment$a.name
    		});
    	}
    }

    let task01$6 = {
        heading : "",
        question: "",
        valueArray: [], 
        answer: 0, 
        operator: "-",
        columns: 0
      };
      
      const substractionvalue$5 = 4;
      const maxValue$6 = 19;
      const minValue$6 = 4;
      
      function taskOne$6() {
        task01$6.heading = "Subtracting 4";
        task01$6.question = "Subtract:";
        task01$6.answer = 0;
        task01$6.columns = 2;
        task01$6.valueArray = [];
        task01$6.valueArray[0] = Math.floor(Math.random() * (maxValue$6 - minValue$6 + 1) + minValue$6 ) ;   
        task01$6.valueArray[1] = substractionvalue$5;   
      
        task01$6.answer = task01$6.valueArray[0] - minValue$6;
      
        return task01$6;
      }

    /* src/components/taskComponents/G1_MS_H4.svelte generated by Svelte v3.37.0 */
    const file$8 = "src/components/taskComponents/G1_MS_H4.svelte";

    function get_each_context$8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (67:31) {:else}
    function create_else_block$7(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[8] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$8, 68, 35, 1769);
    			add_location(tr, file$8, 67, 31, 1729);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[8] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$7.name,
    		type: "else",
    		source: "(67:31) {:else}",
    		ctx
    	});

    	return block;
    }

    // (63:31) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$7(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[8] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$8, 64, 53, 1553);
    			attr_dev(td, "align", "right");
    			add_location(td, file$8, 64, 35, 1535);
    			add_location(tr, file$8, 63, 31, 1495);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[8] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(63:31) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (62:27) {#each task01.valueArray as col, i }
    function create_each_block$8(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[10] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$7;
    		return create_else_block$7;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$8.name,
    		type: "each",
    		source: "(62:27) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$9(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$8, 47, 13, 956);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$8, 46, 9, 903);
    			add_location(h4, file$8, 54, 15, 1157);
    			attr_dev(table, "width", "100");
    			add_location(table, file$8, 59, 19, 1258);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$8, 73, 23, 1977);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$8, 74, 23, 2075);
    			add_location(h6, file$8, 75, 23, 2200);
    			add_location(div1, file$8, 57, 15, 1224);
    			add_location(div2, file$8, 51, 11, 1125);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$8, 80, 15, 2323);
    			add_location(div3, file$8, 79, 11, 2302);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$8, 84, 15, 2472);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$8, 85, 15, 2571);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$8, 86, 15, 2670);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$8, 83, 11, 2438);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$8, 50, 9, 1050);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$8, 45, 8, 852);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$8, 44, 4, 815);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t13);
    			append_dev(div4, button1);
    			append_dev(div4, t15);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$8(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$8(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MS_H4", slots, []);
    	let task01 = taskOne$6();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if ($$invalidate(1, answer = task01.answer)) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$6());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MS_H4> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$6,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G1_MS_H4 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MS_H4",
    			options,
    			id: create_fragment$9.name
    		});
    	}
    }

    let task01$5 = {
        heading : "",
        question: "",
        valueArray: [], 
        answer: 0, 
        operator: "-",
        columns: 0
      };
      
      const substractionvalue$4 = 5;
      const maxValue$5 = 20;
      const minValue$5 = 5;
      
      function taskOne$5() {
        task01$5.heading = "Subtracting 5";
        task01$5.question = "Subtract:";
        task01$5.answer = 0;
        task01$5.columns = 2;
        task01$5.valueArray = [];
        task01$5.valueArray[0] = Math.floor(Math.random() * (maxValue$5 - minValue$5 + 1) + minValue$5 ) ;   
        task01$5.valueArray[1] = substractionvalue$4;   
      
        task01$5.answer = task01$5.valueArray[0] - minValue$5;
      
        return task01$5;
      }

    /* src/components/taskComponents/G1_MS_H5.svelte generated by Svelte v3.37.0 */
    const file$7 = "src/components/taskComponents/G1_MS_H5.svelte";

    function get_each_context$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (68:31) {:else}
    function create_else_block$6(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[8] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$7, 69, 35, 1770);
    			add_location(tr, file$7, 68, 31, 1730);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[8] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(68:31) {:else}",
    		ctx
    	});

    	return block;
    }

    // (64:31) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$6(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[8] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$7, 65, 53, 1554);
    			attr_dev(td, "align", "right");
    			add_location(td, file$7, 65, 35, 1536);
    			add_location(tr, file$7, 64, 31, 1496);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[8] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(64:31) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (63:27) {#each task01.valueArray as col, i }
    function create_each_block$7(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[10] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$6;
    		return create_else_block$6;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$7.name,
    		type: "each",
    		source: "(63:27) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$8(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$7, 48, 13, 957);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$7, 47, 9, 904);
    			add_location(h4, file$7, 55, 15, 1158);
    			attr_dev(table, "width", "100");
    			add_location(table, file$7, 60, 19, 1259);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$7, 74, 23, 1978);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$7, 75, 23, 2076);
    			add_location(h6, file$7, 76, 23, 2201);
    			add_location(div1, file$7, 58, 15, 1225);
    			add_location(div2, file$7, 52, 11, 1126);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$7, 81, 15, 2324);
    			add_location(div3, file$7, 80, 11, 2303);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$7, 85, 15, 2473);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$7, 86, 15, 2572);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$7, 87, 15, 2671);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$7, 84, 11, 2439);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$7, 51, 9, 1051);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$7, 46, 8, 853);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$7, 45, 4, 816);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t13);
    			append_dev(div4, button1);
    			append_dev(div4, t15);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$7(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$7(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MS_H5", slots, []);
    	let task01 = taskOne$5();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if ($$invalidate(1, answer = task01.answer)) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$5());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MS_H5> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$5,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G1_MS_H5 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MS_H5",
    			options,
    			id: create_fragment$8.name
    		});
    	}
    }

    let task01$4 = {
        heading : "",
        question: "",
        valueArray: [], 
        answer: 0, 
        operator: "-",
        columns: 0
      };
      
      const substractionvalue$3 = 6;
      const maxValue$4 = 20;
      const minValue$4 = 6;
      
      function taskOne$4() {
        task01$4.heading = "Subtracting 6";
        task01$4.question = "Subtract:";
        task01$4.answer = 0;
        task01$4.columns = 2;
        task01$4.valueArray = [];
        task01$4.valueArray[0] = Math.floor(Math.random() * (maxValue$4 - minValue$4 + 1) + minValue$4 ) ;   
        task01$4.valueArray[1] = substractionvalue$3;   
      
        task01$4.answer = task01$4.valueArray[0] - minValue$4;
      
        return task01$4;
      }

    /* src/components/taskComponents/G1_MS_H6.svelte generated by Svelte v3.37.0 */
    const file$6 = "src/components/taskComponents/G1_MS_H6.svelte";

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (68:31) {:else}
    function create_else_block$5(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[8] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$6, 69, 35, 1770);
    			add_location(tr, file$6, 68, 31, 1730);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[8] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(68:31) {:else}",
    		ctx
    	});

    	return block;
    }

    // (64:31) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$5(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[8] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$6, 65, 53, 1554);
    			attr_dev(td, "align", "right");
    			add_location(td, file$6, 65, 35, 1536);
    			add_location(tr, file$6, 64, 31, 1496);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[8] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(64:31) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (63:27) {#each task01.valueArray as col, i }
    function create_each_block$6(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[10] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$5;
    		return create_else_block$5;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$6.name,
    		type: "each",
    		source: "(63:27) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$7(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$6, 48, 13, 957);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$6, 47, 9, 904);
    			add_location(h4, file$6, 55, 15, 1158);
    			attr_dev(table, "width", "100");
    			add_location(table, file$6, 60, 19, 1259);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$6, 74, 23, 1978);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$6, 75, 23, 2076);
    			add_location(h6, file$6, 76, 23, 2201);
    			add_location(div1, file$6, 58, 15, 1225);
    			add_location(div2, file$6, 52, 11, 1126);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$6, 81, 15, 2324);
    			add_location(div3, file$6, 80, 11, 2303);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$6, 85, 15, 2473);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$6, 86, 15, 2572);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$6, 87, 15, 2671);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$6, 84, 11, 2439);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$6, 51, 9, 1051);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$6, 46, 8, 853);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$6, 45, 4, 816);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t13);
    			append_dev(div4, button1);
    			append_dev(div4, t15);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$6(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$6(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MS_H6", slots, []);
    	let task01 = taskOne$4();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if ($$invalidate(1, answer = task01.answer)) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$4());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MS_H6> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$4,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G1_MS_H6 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MS_H6",
    			options,
    			id: create_fragment$7.name
    		});
    	}
    }

    let task01$3 = {
        heading : "",
        question: "",
        valueArray: [], 
        answer: 0, 
        operator: "-",
        columns: 0
      };
      
      const substractionvalue$2 = 7;
      const maxValue$3 = 23;
      const minValue$3 = 7;
      
      function taskOne$3() {
        task01$3.heading = "Subtracting 7";
        task01$3.question = "Subtract:";
        task01$3.answer = 0;
        task01$3.columns = 2;
        task01$3.valueArray = [];
        task01$3.valueArray[0] = Math.floor(Math.random() * (maxValue$3 - minValue$3 + 1) + minValue$3 ) ;   
        task01$3.valueArray[1] = substractionvalue$2;   
      
        task01$3.answer = task01$3.valueArray[0] - minValue$3;
      
        return task01$3;
      }

    /* src/components/taskComponents/G1_MS_H7.svelte generated by Svelte v3.37.0 */
    const file$5 = "src/components/taskComponents/G1_MS_H7.svelte";

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (68:31) {:else}
    function create_else_block$4(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[8] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$5, 69, 35, 1770);
    			add_location(tr, file$5, 68, 31, 1730);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[8] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(68:31) {:else}",
    		ctx
    	});

    	return block;
    }

    // (64:31) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$4(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[8] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$5, 65, 53, 1554);
    			attr_dev(td, "align", "right");
    			add_location(td, file$5, 65, 35, 1536);
    			add_location(tr, file$5, 64, 31, 1496);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[8] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(64:31) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (63:27) {#each task01.valueArray as col, i }
    function create_each_block$5(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[10] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$4;
    		return create_else_block$4;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$5.name,
    		type: "each",
    		source: "(63:27) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$5, 48, 13, 957);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$5, 47, 9, 904);
    			add_location(h4, file$5, 55, 15, 1158);
    			attr_dev(table, "width", "100");
    			add_location(table, file$5, 60, 19, 1259);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$5, 74, 23, 1978);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$5, 75, 23, 2076);
    			add_location(h6, file$5, 76, 23, 2201);
    			add_location(div1, file$5, 58, 15, 1225);
    			add_location(div2, file$5, 52, 11, 1126);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$5, 81, 15, 2324);
    			add_location(div3, file$5, 80, 11, 2303);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$5, 85, 15, 2473);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$5, 86, 15, 2572);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$5, 87, 15, 2671);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$5, 84, 11, 2439);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$5, 51, 9, 1051);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$5, 46, 8, 853);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$5, 45, 4, 816);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t13);
    			append_dev(div4, button1);
    			append_dev(div4, t15);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$5(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$5(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MS_H7", slots, []);
    	let task01 = taskOne$3();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if ($$invalidate(1, answer = task01.answer)) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$3());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MS_H7> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$3,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G1_MS_H7 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MS_H7",
    			options,
    			id: create_fragment$6.name
    		});
    	}
    }

    let task01$2 = {
        heading : "",
        question: "",
        valueArray: [], 
        answer: 0, 
        operator: "-",
        columns: 0
      };
      
      const substractionvalue$1 = 8;
      const maxValue$2 = 23;
      const minValue$2 = 8;
      
      function taskOne$2() {
        task01$2.heading = "Subtracting 8";
        task01$2.question = "Subtract:";
        task01$2.answer = 0;
        task01$2.columns = 2;
        task01$2.valueArray = [];
        task01$2.valueArray[0] = Math.floor(Math.random() * (maxValue$2 - minValue$2 + 1) + minValue$2 ) ;   
        task01$2.valueArray[1] = substractionvalue$1;   
      
        task01$2.answer = task01$2.valueArray[0] - minValue$2;
      
        return task01$2;
      }

    /* src/components/taskComponents/G1_MS_H8.svelte generated by Svelte v3.37.0 */
    const file$4 = "src/components/taskComponents/G1_MS_H8.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (68:31) {:else}
    function create_else_block$3(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[8] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$4, 69, 35, 1770);
    			add_location(tr, file$4, 68, 31, 1730);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[8] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(68:31) {:else}",
    		ctx
    	});

    	return block;
    }

    // (64:31) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$3(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[8] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$4, 65, 53, 1554);
    			attr_dev(td, "align", "right");
    			add_location(td, file$4, 65, 35, 1536);
    			add_location(tr, file$4, 64, 31, 1496);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[8] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(64:31) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (63:27) {#each task01.valueArray as col, i }
    function create_each_block$4(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[10] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$3;
    		return create_else_block$3;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(63:27) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$4, 48, 13, 957);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$4, 47, 9, 904);
    			add_location(h4, file$4, 55, 15, 1158);
    			attr_dev(table, "width", "100");
    			add_location(table, file$4, 60, 19, 1259);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$4, 74, 23, 1978);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$4, 75, 23, 2076);
    			add_location(h6, file$4, 76, 23, 2201);
    			add_location(div1, file$4, 58, 15, 1225);
    			add_location(div2, file$4, 52, 11, 1126);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$4, 81, 15, 2324);
    			add_location(div3, file$4, 80, 11, 2303);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$4, 85, 15, 2473);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$4, 86, 15, 2572);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$4, 87, 15, 2671);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$4, 84, 11, 2439);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$4, 51, 9, 1051);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$4, 46, 8, 853);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$4, 45, 4, 816);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t13);
    			append_dev(div4, button1);
    			append_dev(div4, t15);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MS_H8", slots, []);
    	let task01 = taskOne$2();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if ($$invalidate(1, answer = task01.answer)) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$2());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MS_H8> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$2,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G1_MS_H8 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MS_H8",
    			options,
    			id: create_fragment$5.name
    		});
    	}
    }

    let task01$1 = {
        heading : "",
        question: "",
        valueArray: [], 
        answer: 0, 
        operator: "-",
        columns: 0
      };
      
      const substractionvalue = 9;
      const maxValue$1 = 25;
      const minValue$1 = 9;
      
      function taskOne$1() {
        task01$1.heading = "Subtracting 9";
        task01$1.question = "Subtract:";
        task01$1.answer = 0;
        task01$1.columns = 2;
        task01$1.valueArray = [];
        task01$1.valueArray[0] = Math.floor(Math.random() * (maxValue$1 - minValue$1 + 1) + minValue$1 ) ;   
        task01$1.valueArray[1] = substractionvalue;   
      
        task01$1.answer = task01$1.valueArray[0] - minValue$1;
      
        return task01$1;
      }

    /* src/components/taskComponents/G1_MS_H9.svelte generated by Svelte v3.37.0 */
    const file$3 = "src/components/taskComponents/G1_MS_H9.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (68:31) {:else}
    function create_else_block$2(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[8] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$3, 69, 35, 1770);
    			add_location(tr, file$3, 68, 31, 1730);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[8] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(68:31) {:else}",
    		ctx
    	});

    	return block;
    }

    // (64:31) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$2(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[8] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$3, 65, 53, 1554);
    			attr_dev(td, "align", "right");
    			add_location(td, file$3, 65, 35, 1536);
    			add_location(tr, file$3, 64, 31, 1496);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[8] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(64:31) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (63:27) {#each task01.valueArray as col, i }
    function create_each_block$3(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[10] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$2;
    		return create_else_block$2;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(63:27) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$4(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$3, 48, 13, 957);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$3, 47, 9, 904);
    			add_location(h4, file$3, 55, 15, 1158);
    			attr_dev(table, "width", "100");
    			add_location(table, file$3, 60, 19, 1259);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$3, 74, 23, 1978);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$3, 75, 23, 2076);
    			add_location(h6, file$3, 76, 23, 2201);
    			add_location(div1, file$3, 58, 15, 1225);
    			add_location(div2, file$3, 52, 11, 1126);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$3, 81, 15, 2324);
    			add_location(div3, file$3, 80, 11, 2303);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$3, 85, 15, 2473);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$3, 86, 15, 2572);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$3, 87, 15, 2671);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$3, 84, 11, 2439);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$3, 51, 9, 1051);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$3, 46, 8, 853);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$3, 45, 4, 816);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t13);
    			append_dev(div4, button1);
    			append_dev(div4, t15);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MS_H9", slots, []);
    	let task01 = taskOne$1();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if ($$invalidate(1, answer = task01.answer)) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne$1());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MS_H9> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne: taskOne$1,
    		randomCorrect,
    		randomWrong,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G1_MS_H9 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MS_H9",
    			options,
    			id: create_fragment$4.name
    		});
    	}
    }

    let task01 = {
      heading : "",
      question: "",
      valueArray: [], 
      answer: 0, 
      operator: "+",
      columns: 0
    };

    let columns = 3;
    let maxValue = 10;
    let minValue = 0;
    let heading = "";
    let question = "";


    function MaxandMin(max, min,col,headingtext,qst) {
      minValue = min;
      maxValue = max;
      columns = col;
      heading = headingtext;
      question = qst;
    }

    function taskOne() {
      task01.heading = heading;
      task01.question = question;
      task01.answer = 0;
      task01.columns = columns;
      task01.valueArray = [];
      
      for (let i = 0; i < columns; i++) {
        task01.valueArray[i] = Math.floor(Math.random() * (maxValue - minValue + 1) ) + minValue;  
        task01.answer += task01.valueArray[i];   
      }
      while(task01.answer > maxValue){
        console.log('enter');
          task01.answer = 0;
        for (let i = 0; i < columns; i++) {
          task01.valueArray[i] = Math.floor(Math.random() * (maxValue - minValue + 1) ) + minValue; 
          task01.answer += task01.valueArray[i];        
        }
      }

    return task01;
    }

    /* src/components/taskComponents/G1_MA_E1.svelte generated by Svelte v3.37.0 */
    const file$2 = "src/components/taskComponents/G1_MA_E1.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	child_ctx[13] = i;
    	return child_ctx;
    }

    // (69:32) {:else}
    function create_else_block$1(ctx) {
    	let tr;
    	let td;
    	let t0_value = /*col*/ ctx[11] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(td, "align", "right");
    			add_location(td, file$2, 70, 36, 2250);
    			add_location(tr, file$2, 69, 32, 2209);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*col*/ ctx[11] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(69:32) {:else}",
    		ctx
    	});

    	return block;
    }

    // (65:32) {#if i == (task01.valueArray.length - 1) }
    function create_if_block$1(ctx) {
    	let tr;
    	let td;
    	let span;
    	let t0_value = /*task01*/ ctx[0].operator + "";
    	let t0;
    	let t1_value = /*col*/ ctx[11] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			set_style(span, "margin-right", "20px");
    			add_location(span, file$2, 66, 54, 2030);
    			attr_dev(td, "align", "right");
    			add_location(td, file$2, 66, 36, 2012);
    			add_location(tr, file$2, 65, 32, 1971);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, span);
    			append_dev(span, t0);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].operator + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t1_value !== (t1_value = /*col*/ ctx[11] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(65:32) {#if i == (task01.valueArray.length - 1) }",
    		ctx
    	});

    	return block;
    }

    // (64:28) {#each task01.valueArray as col, i }
    function create_each_block$2(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[13] == /*task01*/ ctx[0].valueArray.length - 1) return create_if_block$1;
    		return create_else_block$1;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(64:28) {#each task01.valueArray as col, i }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let h2;
    	let t0_value = /*task01*/ ctx[0].heading + "";
    	let t0;
    	let t1;
    	let div5;
    	let div2;
    	let h4;
    	let t2_value = /*task01*/ ctx[0].question + "";
    	let t2;
    	let t3;
    	let div1;
    	let table;
    	let t4;
    	let hr;
    	let t5;
    	let input;
    	let t6;
    	let h6;
    	let t7;
    	let t8_value = /*task01*/ ctx[0].answer + "";
    	let t8;
    	let t9;
    	let div3;
    	let h5;
    	let t10;
    	let t11;
    	let div4;
    	let button0;
    	let t13;
    	let button1;
    	let t15;
    	let button2;
    	let mounted;
    	let dispose;
    	let each_value = /*task01*/ ctx[0].valueArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div2 = element("div");
    			h4 = element("h4");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			table = element("table");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			h6 = element("h6");
    			t7 = text("answer ");
    			t8 = text(t8_value);
    			t9 = space();
    			div3 = element("div");
    			h5 = element("h5");
    			t10 = text(/*showPopUp*/ ctx[3]);
    			t11 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t13 = space();
    			button1 = element("button");
    			button1.textContent = "Rerun";
    			t15 = space();
    			button2 = element("button");
    			button2.textContent = "Exit This Skill";
    			attr_dev(h2, "class", "text-center display-4 mb-0");
    			add_location(h2, file$2, 50, 14, 1436);
    			attr_dev(div0, "class", "bg-info rounded-top p-2");
    			add_location(div0, file$2, 49, 10, 1382);
    			add_location(h4, file$2, 57, 16, 1642);
    			attr_dev(table, "width", "100");
    			add_location(table, file$2, 61, 20, 1730);
    			set_style(hr, "width", "100px");
    			set_style(hr, "text-align", "left");
    			set_style(hr, "margin-left", "5px");
    			set_style(hr, "border", "1px solid");
    			add_location(hr, file$2, 75, 24, 2463);
    			attr_dev(input, "class", "input-user");
    			attr_dev(input, "type", "text");
    			set_style(input, "margin-left", "5px");
    			attr_dev(input, "maxlength", "7");
    			add_location(input, file$2, 76, 24, 2562);
    			add_location(h6, file$2, 77, 24, 2688);
    			add_location(div1, file$2, 59, 16, 1695);
    			add_location(div2, file$2, 54, 12, 1609);
    			set_style(h5, "display", /*showNext*/ ctx[2]);
    			attr_dev(h5, "class", "mt-5");
    			add_location(h5, file$2, 82, 16, 2816);
    			add_location(div3, file$2, 81, 12, 2794);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn toggle-btn");
    			add_location(button0, file$2, 86, 16, 2969);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn toggle-btn");
    			add_location(button1, file$2, 87, 16, 3069);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn toggle-btn");
    			add_location(button2, file$2, 88, 16, 3169);
    			attr_dev(div4, "class", "mt-3");
    			add_location(div4, file$2, 85, 12, 2934);
    			attr_dev(div5, "class", " bg-light rounded-bottom p-3 pb-5 pt-5");
    			add_location(div5, file$2, 53, 10, 1533);
    			attr_dev(div6, "class", "shadow-sm  bg-white rounded");
    			add_location(div6, file$2, 48, 9, 1330);
    			attr_dev(div7, "class", "container mt-5");
    			add_location(div7, file$2, 47, 5, 1292);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, h4);
    			append_dev(h4, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, hr);
    			append_dev(div1, t5);
    			append_dev(div1, input);
    			set_input_value(input, /*answer*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, h6);
    			append_dev(h6, t7);
    			append_dev(h6, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, h5);
    			append_dev(h5, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div4, t13);
    			append_dev(div4, button1);
    			append_dev(div4, t15);
    			append_dev(div4, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button0, "click", /*CheckAnswer*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*NextQuestion*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*task01*/ 1 && t0_value !== (t0_value = /*task01*/ ctx[0].heading + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*task01*/ 1 && t2_value !== (t2_value = /*task01*/ ctx[0].question + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*task01*/ 1) {
    				each_value = /*task01*/ ctx[0].valueArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*answer*/ 2 && input.value !== /*answer*/ ctx[1]) {
    				set_input_value(input, /*answer*/ ctx[1]);
    			}

    			if (dirty & /*task01*/ 1 && t8_value !== (t8_value = /*task01*/ ctx[0].answer + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*showPopUp*/ 8) set_data_dev(t10, /*showPopUp*/ ctx[3]);

    			if (dirty & /*showNext*/ 4) {
    				set_style(h5, "display", /*showNext*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const max = 10;
    const min = 0;
    const numberofColumn = 2;

    function instance$3($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("G1_MA_E1", slots, []);
    	let heading = "Subtraction facts - numbers up to 10";
    	let question = "Subtract.";
    	let maxandmin = MaxandMin(max, min, numberofColumn, heading, question);
    	let task01 = taskOne();
    	let answer;
    	let showNext = "none";
    	let showPopUp;
    	let showSolution = false;

    	let CheckAnswer = function () {
    		$$invalidate(2, showNext = "inline-block");

    		if (answer == task01.answer) {
    			$$invalidate(3, showPopUp = randomCorrect());
    			return;
    		} else {
    			showSolution = true;
    			$$invalidate(3, showPopUp = randomWrong());
    		}
    	};

    	let NextQuestion = function () {
    		$$invalidate(1, answer = null);
    		$$invalidate(0, task01 = taskOne());
    		showSolution = false;
    		$$invalidate(2, showNext = "none");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<G1_MA_E1> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		answer = this.value;
    		$$invalidate(1, answer);
    	}

    	$$self.$capture_state = () => ({
    		taskOne,
    		randomCorrect,
    		randomWrong,
    		MaxandMin,
    		heading,
    		question,
    		max,
    		min,
    		numberofColumn,
    		maxandmin,
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		showSolution,
    		CheckAnswer,
    		NextQuestion
    	});

    	$$self.$inject_state = $$props => {
    		if ("heading" in $$props) heading = $$props.heading;
    		if ("question" in $$props) question = $$props.question;
    		if ("maxandmin" in $$props) maxandmin = $$props.maxandmin;
    		if ("task01" in $$props) $$invalidate(0, task01 = $$props.task01);
    		if ("answer" in $$props) $$invalidate(1, answer = $$props.answer);
    		if ("showNext" in $$props) $$invalidate(2, showNext = $$props.showNext);
    		if ("showPopUp" in $$props) $$invalidate(3, showPopUp = $$props.showPopUp);
    		if ("showSolution" in $$props) showSolution = $$props.showSolution;
    		if ("CheckAnswer" in $$props) $$invalidate(4, CheckAnswer = $$props.CheckAnswer);
    		if ("NextQuestion" in $$props) $$invalidate(5, NextQuestion = $$props.NextQuestion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		task01,
    		answer,
    		showNext,
    		showPopUp,
    		CheckAnswer,
    		NextQuestion,
    		input_input_handler
    	];
    }

    class G1_MA_E1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "G1_MA_E1",
    			options,
    			id: create_fragment$3.name
    		});
    	}
    }

    const act_list = {
      LKG: {
        A: {
          subject: "Maths",
          catType: "Shapes",
          category: "A",
          components: [
            {
              act_text: "Name the shape",
              comp: null,
            },
            {
              act_text: "Circles",
              comp: null,
            },
            {
              act_text: "Squares",
              comp: null,
            },
            {
              act_text: "	Triangles",
              comp: null,
            },
            {
              act_text: "Rectangles",
              comp: null,
            },
            {
              act_text: "Circles, squares and triangles",
              comp: null,
            },
          ],
        },
        B: {
          subject: "Maths",
          category: "B",
          catType: "Count of 3",
          components: [
            {
              act_text: "	Learn to count - up to 3",
              comp: null,
            },
            {
              act_text: "	Count objects - up to 3",
              comp: null,
            },
            {
              act_text: "	Count dots - up to 3",
              comp: null,
            },
            {
              act_text: "Count shapes - up to 3",
              comp: null,
            },
            {
              act_text: "Count on ten frames - up to 3",
              comp: null,
            },
            {
              act_text: "	Show numbers on ten frames - up to 3",
              comp: null,
            },
            {
              act_text: "Represent numbers - up to 3",
              comp: null,
            },
          ],
        },
        C: {
          subject: "Maths",
          category: "C",
          catType: "Count of 5",
          components: [
            {
              act_text: "	Learn to count - up to 5",
              comp: null,
            },
            {
              act_text: "	Count objects - up to 5",
              comp: null,
            },
            {
              act_text: "	Count dots - up to 5",
              comp: null,
            },
            {
              act_text: "Count shapes - up to 5",
              comp: null,
            },
            {
              act_text: "Count on ten frames - up to 5",
              comp: null,
            },
            {
              act_text: "	Show numbers on ten frames - up to 5",
              comp: null,
            },
            {
              act_text: "Represent numbers - up to 5",
              comp: null,
            },
          ],
        },
        D: {
          subject: "Maths",
          category: "D",
          catType: "Count of 10",
          components: [
            {
              act_text: "	Learn to count - up to 10",
              comp: null,
            },
            {
              act_text: "	Count objects - up to 10",
              comp: null,
            },
            {
              act_text: "	Count dots - up to 10",
              comp: null,
            },
            {
              act_text: "Count shapes - up to 10",
              comp: null,
            },
            {
              act_text: "Count on ten frames - up to 10",
              comp: null,
            },
            {
              act_text: "	Show numbers on ten frames - up to 10",
              comp: null,
            },
            {
              act_text: "Represent numbers - up to 10",
              comp: null,
            },
          ],
        },
        E: {
          subject: "Maths",
          category: "E",
          catType: "Comparing",
          components: [
            {
              act_text: "	Are there enough?",
              comp: null,
            },
            {
              act_text: "More",
              comp: null,
            },
            {
              act_text: "Fewer",
              comp: null,
            },
            {
              act_text: "Fewer and more - compare by counting",
              comp: null,
            },
            {
              act_text: "Compare in a mixed group",
              comp: null,
            },
          ],
        },
        F: {
          subject: "Maths",
          category: "F",
          catType: "Positions",
          components: [
            {
              act_text: "Inside and outside",
              comp: null,
            },
            {
              act_text: "Above and below",
              comp: null,
            },
            {
              act_text: "	Beside and next to",
              comp: null,
            },
            {
              act_text: "	Left and right",
              comp: null,
            },
            {
              act_text: "	Left, middle and right",
              comp: null,
            },
            {
              act_text: "Top and bottom",
              comp: null,
            },
            {
              act_text: "	Top, middle and bottom",
              comp: null,
            },
          ],
        },
        G: {
          subject: "Maths",
          category: "G",
          catType: "Classify",
          components: [
            {
              act_text: "Same",
              comp: null,
            },
            {
              act_text: "Different",
              comp: null,
            },
            {
              act_text: "Same and Different",
              comp: null,
            },
            {
              act_text: "Classify shapes by colour",
              comp: null,
            },
            {
              act_text: "	Classify and sort by colourt",
              comp: null,
            },
            {
              act_text: "	Classify and sort by shape",
              comp: null,
            },
          ],
        },
        H: {
          subject: "Maths",
          category: "H",
          catType: "Paterns",
          components: [
            {
              act_text: "Colour patterns",
              comp: null,
            },
            {
              act_text: "size patterns",
              comp: null,
            },
            {
              act_text: "Shape patterns",
              comp: null,
            },
            {
              act_text: "What comes next?",
              comp: null,
            },
          ],
        },
        I: {
          subject: "Maths",
          category: "I",
          catType: "Size",
          components: [
            {
              act_text: "Long and Short",
              comp: null,
            },
            {
              act_text: "Tall and short",
              comp: null,
            },
            {
              act_text: "Wide and narrow",
              comp: null,
            },
            {
              act_text: "Light and heavy",
              comp: null,
            },
          ],
        },
        J: {
          subject: "Maths",
          category: "J",
          catType: "Money",
          components: [
            {
              act_text: "Coin values",
              comp: null,
            },
            {
              act_text: "Count 1-rupee coins",
              comp: null,
            },
          ],
        },
      },
      UKG: {
        A: {
          subject: "Maths",
          category: "A",
          catType: "Numbers and Counting of 3",
          components: [
            {
              act_text: "	Learn to count - up to 3",
              comp: null,
            },
            {
              act_text: "	Count to 3",
              comp: null,
            },
            {
              act_text: "	Count using stickers - up to 3",
              comp: null,
            },
            {
              act_text: "Count on ten frames - up to 3",
              comp: null,
            },
            {
              act_text: "	Show numbers on ten frames - up to 3",
              comp: null,
            },
            {
              act_text: "Represent numbers - up to 3",
              comp: null,
            },
          ],
        },
        B: {
          subject: "Maths",
          category: "B",
          catType: "Numbers and Counting of 5",
          components: [
            {
              act_text: "	Learn to count - up to 5",
              comp: null,
            },
            {
              act_text: "	Count to 5",
              comp: null,
            },
            {
              act_text: "	Count using stickers - up to 5",
              comp: null,
            },
            {
              act_text: "Count on ten frames - up to 5",
              comp: null,
            },
            {
              act_text: "	Show numbers on ten frames - up to 5",
              comp: null,
            },
            {
              act_text: "Represent numbers - up to 5",
              comp: null,
            },
            {
              act_text: "One more - up to 5",
              comp: null,
            },
            {
              act_text: "Count one more - up to 5",
              comp: null,
            },
            {
              act_text: "One less - up to 5",
              comp: null,
            },
            {
              act_text: "Count one less - up to 5",
              comp: null,
            },
          ],
        },
        C: {
          subject: "Maths",
          category: "C",
          catType: "Numbers and Counting of 10",
          components: [
            {
              act_text: "	Learn to count - up to 10",
              comp: null,
            },
            {
              act_text: "	Count to 10",
              comp: null,
            },
            {
              act_text: "	Count using stickers - up to 10",
              comp: null,
            },
            {
              act_text: "Count on ten frames - up to 10",
              comp: null,
            },
            {
              act_text: "	Show numbers on ten frames - up to 10",
              comp: null,
            },
            {
              act_text: "Represent numbers - up to 10",
              comp: null,
            },
            {
              act_text: "One more - up to 10",
              comp: null,
            },
            {
              act_text: "Count one more - up to 10",
              comp: null,
            },
            {
              act_text: "One less - up to 10",
              comp: null,
            },
            {
              act_text: "Count one less - up to 10",
              comp: null,
            },
            {
              act_text: "One more and less - up to 10",
              comp: null,
            },
            {
              act_text: "Count One more and less - up to 10",
              comp: null,
            },
            {
              act_text: "Count up and down - up to 10",
              comp: null,
            },
            {
              act_text: "Count to fill a ten frame",
              comp: null,
            },
            {
              act_text: "Tally marks - up to 10",
              comp: null,
            },
            {
              act_text: "Number lines - up to 10",
              comp: null,
            },
            {
              act_text: "	Before, after and between - up to 10",
              comp: null,
            },
            {
              act_text: "	Count forward and backward - up to 10",
              comp: null,
            },
            {
              act_text: "	Names of numbers- up to 10",
              comp: null,
            },
            {
              act_text: "Complete a sequence - up to 10",
              comp: null,
            },
          ],
        },
        D: {
          subject: "Maths",
          category: "D",
          catType: "Numbers and Counting of 20",
          components: [
            {
              act_text: "	Count to 20",
              comp: null,
            },
            {
              act_text: "Count on ten frames - up to 20",
              comp: null,
            },
            {
              act_text: "	Show numbers on ten frames - up to 20",
              comp: null,
            },
            {
              act_text: "Represent numbers - up to 20",
              comp: null,
            },
            {
              act_text: "Count up and down",
              comp: null,
            },
            {
              act_text: "Tally marks - up to 20",
              comp: null,
            },
            {
              act_text: "Number lines - up to 20",
              comp: null,
            },
            {
              act_text: "	Before, after and between - up to 20",
              comp: null,
            },
            {
              act_text: "	Count forward and backward - up to 20",
              comp: null,
            },
            {
              act_text: "	Names of numbers- up to 20",
              comp: null,
            },
            {
              act_text: "Complete a sequence - up to 20",
              comp: null,
            },
            {
              act_text: "Count tens anad ones- up to 20",
              comp: null,
            },
            {
              act_text: "	Learn to skip-count by twos",
              comp: null,
            },
            {
              act_text: "Skip-count by twos",
              comp: null,
            },
            {
              act_text: "Skip-count by twos on ten frames",
              comp: null,
            },
          ],
        },
        E: {
          subject: "Maths",
          category: "E",
          catType: "Comparing",
          components: [
            {
              act_text: "Are there enough?",
              comp: null,
            },
            {
              act_text: "	Fewer and more - compare by matching",
              comp: null,
            },
            {
              act_text: "Fewer and more - compare by counting",
              comp: null,
            },
            {
              act_text: "Fewer and more - compare in a mixed group",
              comp: null,
            },
            {
              act_text: "	Fewer, more and same",
              comp: null,
            },
            {
              act_text: "Compare two numbers - up to 10",
              comp: null,
            },
            {
              act_text: "	Compare three numbers - up to 10",
              comp: null,
            },
          ],
        },
        F: {
          subject: "Maths",
          category: "F",
          catType: "Patterns",
          components: [
            {
              act_text: "Colour patterns",
              comp: null,
            },
            {
              act_text: "size patterns",
              comp: null,
            },
            {
              act_text: "shape patterns",
              comp: null,
            },
            {
              act_text: "Find the next shape in a pattern",
              comp: null,
            },
            {
              act_text: "Complete a pattern",
              comp: null,
            },
            {
              act_text: "Growing patterns",
              comp: null,
            },
            {
              act_text: "Find the next shape in a growing pattern",
              comp: null,
            },

            {
              act_text: "Find the next row in a growing pattern",
              comp: null,
            },
          ],
        },
        G: {
          subject: "Maths",
          category: "G",
          catType: "Positions",
          components: [
            {
              act_text: "Inside and outside",
              comp: null,
            },
            {
              act_text: "Above and below",
              comp: null,
            },
            {
              act_text: "	Above and below - find solid figures",
              comp: null,
            },
            {
              act_text: "	Beside and next to",
              comp: null,
            },
            {
              act_text: "	Beside and next to - find solid figures",
              comp: null,
            },
            {
              act_text: "Left, middle and right",
              comp: null,
            },
            {
              act_text: "Top, middle and bottom",
              comp: null,
            },

            {
              act_text: "	Location in a grid",
              comp: null,
            },
          ],
        },
        H: {
          subject: "Maths",
          category: "H",
          catType: "Addition up to 5",
          components: [
            {
              act_text: "Add with pictures - sums up to 5",
              comp: null,
            },
            {
              act_text: "Addition sentences - sums up to 5",
              comp: null,
            },
            {
              act_text: "	Make a number using addition - sums up to 5",
              comp: null,
            },
            {
              act_text: "Add two numbers - sums up to 5",
              comp: null,
            },
            {
              act_text: "Complete the addition sentence - sums up to 5",
              comp: null,
            },
            {
              act_text: "Addition word problems - sums up to 5",
              comp: null,
            },
          ],
        },
        I: {
          subject: "Maths",
          category: "I",
          catType: "Addition up to 10",
          components: [
            {
              act_text: "	Add with pictures - sums up to 10",
              comp: null,
            },
            {
              act_text: "Addition sentences - sums up to 10",
              comp: null,
            },
            {
              act_text: "	Make a number using addition - sums up to 10",
              comp: null,
            },
            {
              act_text: "	Add two numbers - sums up to 10",
              comp: null,
            },
            {
              act_text: "	Complete the addition sentence - sums up to 10",
              comp: null,
            },
            {
              act_text: "	Complete the addition sentence - make 10",
              comp: null,
            },
            {
              act_text: "	Write addition sentences",
              comp: null,
            },
            {
              act_text: "	Addition word problems - sums up to 10",
              comp: null,
            },
          ],
        },
        J: {
          subject: "Maths",
          category: "J",
          catType: "Subtraction up to 5",
          components: [
            {
              act_text: "Subtraction with pictures - sums up to 5",
              comp: null,
            },
            {
              act_text: "Subtraction sentences - sums up to 5",
              comp: null,
            },
            {
              act_text: "Subtraction- sums up to 5",
              comp: null,
            },
            {
              act_text: "Complete the Subtraction sentence - sums up to 5",
              comp: null,
            },
            {
              act_text: "Subtraction word problems - sums up to 5",
              comp: null,
            },
          ],
        },
        K: {
          subject: "Maths",
          category: "K",
          catType: "Subtraction up to 10",
          components: [
            {
              act_text: "	Subtract with pictures - sums up to 10",
              comp: null,
            },
            {
              act_text: "Subtraction sentences - sums up to 10",
              comp: null,
            },
            {
              act_text: "	Make a number using Subtraction- sums up to 10",
              comp: null,
            },
            {
              act_text: "Subtract - sums up to 10",
              comp: null,
            },
            {
              act_text: "	Complete the Subtractionsentence - sums up to 10",
              comp: null,
            },
            {
              act_text: "	Write Subtraction sentences",
              comp: null,
            },
            {
              act_text: "Subtraction word problems - sums up to 10",
              comp: null,
            },
          ],
        },
        L: {
          subject: "Maths",
          category: "L",
          catType: "Sorting, ordering and classifying",
          components: [
            {
              act_text: "Same",
              comp: null,
            },
            {
              act_text: "Different",
              comp: null,
            },
            {
              act_text: "Same and Different",
              comp: null,
            },
            {
              act_text: "	Classify shapes by colour",
              comp: null,
            },
            {
              act_text: "	Classify and sort by colour",
              comp: null,
            },
            {
              act_text: "	Classify and sort by shape",
              comp: null,
            },
            {
              act_text: "Classify and sort",
              comp: null,
            },
            {
              act_text: "	Sort shapes into a Venn diagram",
              comp: null,
            },
            {
              act_text: "	Count shapes in a Venn diagram",
              comp: null,
            },
            {
              act_text: "Put numbers up to 10 in order",
              comp: null,
            },
            {
              act_text: "Put numbers up to 20 in order",
              comp: null,
            },
          ],
        },
        M: {
          subject: "Maths",
          category: "M",
          catType: "Data and graphs",
          components: [
            {
              act_text: "	Which picture graph is correct?",
              comp: null,
            },
          ],
        },
        N: {
          subject: "Maths",
          category: "N",
          catType: "Probability",
          components: [
            {
              act_text: "More or less likely",
              comp: null,
            },
          ],
        },
        O: {
          subject: "Maths",
          category: "O",
          catType: "Measurement",
          components: [
            {
              act_text: "Long and short",
              comp: null,
            },
            {
              act_text: "Tall and short",
              comp: null,
            },
            {
              act_text: "Wide and narrow",
              comp: null,
            },
            {
              act_text: "Light and heavy",
              comp: null,
            },
          ],
        },
        P: {
          subject: "Maths",
          category: "P",
          catType: "Money",
          components: [
            {
              act_text: "Coin values",
              comp: null,
            },
            {
              act_text: "Count money - 1-rupee coins only",
              comp: null,
            },
            {
              act_text: "Count money - 1- and 2-rupee coins",
              comp: null,
            },
            {
              act_text: "Count money - 1-, 2- and 5-rupee coins",
              comp: null,
            },
            {
              act_text: "	Equivalent groups of coins",
              comp: null,
            },
            {
              act_text: "	Compare two groups of coins",
              comp: null,
            },
          ],
        },
        Q: {
          subject: "Maths",
          category: "Q",
          catType: "Two-dimensional shapes",
          components: [
            {
              act_text: "Name the two-dimensional shape",
              comp: null,
            },
            {
              act_text: "Circles",
              comp: null,
            },
            {
              act_text: "Triangles",
              comp: null,
            },
            {
              act_text: "Squares and rectangles",
              comp: null,
            },
            {
              act_text: "Hexagons",
              comp: null,
            },
            {
              act_text: "Select two-dimensional shapes",
              comp: null,
            },
            {
              act_text: "Count sides and corners",
              comp: null,
            },
            {
              act_text: "Compare sides and corners",
              comp: null,
            },
            {
              act_text: "	Introduction to symmetry",
              comp: null,
            },
            {
              act_text: "Identify pictures with symmetry",
              comp: null,
            },
          ],
        },
        R: {
          subject: "Maths",
          category: "R",
          catType: "Three-dimensional shapes",
          components: [
            {
              act_text: "	Two-dimensional and three-dimensional shapes",
              comp: null,
            },
            {
              act_text: "	Name the three-dimensional shape",
              comp: null,
            },
            {
              act_text: "Spheres",
              comp: null,
            },
            {
              act_text: "	Cubes",
              comp: null,
            },
            {
              act_text: "	Cones",
              comp: null,
            },
            {
              act_text: "	Cylinders",
              comp: null,
            },
            {
              act_text: "	Select three-dimensional shapes",
              comp: null,
            },
            {
              act_text: "	Identify shapes traced from solids",
              comp: null,
            },
            {
              act_text: "Shapes of everyday objects I",
              comp: null,
            },
            {
              act_text: "Shapes of everyday objects II",
              comp: null,
            },
          ],
        },
        S: {
          subject: "Maths",
          category: "S",
          catType: "Vocbulory",
          components: [
            {
              act_text: "Sun and difference",
              comp: null,
            },
          ],
        },
      },
      Class1: {
        A: {
          subject: "Maths",
          category: "A",
          catType: "Counting and number patterns",
          components: [
            {
              act_text: "Counting review - up to 10",
              comp: Rough12,
            },
            {
              act_text: "Count to fill a ten frame",
              comp: G1_MA_A2,
            },
            {
              act_text: "Counting review - up to 20",
              comp: null,
            },
            {
              act_text: "Counting tens and ones - up to 30",
              comp: null,
            },
            {
              act_text: "Count on ten frames - up to 40",
              comp: null,
            },
            {
              act_text: "Counting - up to 100",
              comp: null,
            },
            {
              act_text: "Counting tens and ones - up to 99",
              comp: null,
            },
            {
              act_text: "	Counting by twos, fives and tens with pictures",
              comp: null,
            },
            {
              act_text: "Counting by twos, fives and tens",
              comp: null,
            },
            {
              act_text: "Counting forward and backward",
              comp: null,
            },
            {
              act_text: "Number lines - up to 100",
              comp: null,
            },
            {
              act_text: "Hundred chart",
              comp: null,
            },
            {
              act_text: "Even or odd",
              comp: null,
            },
            {
              act_text: "	Identify numbers as even or odd",
              comp: null,
            },
            {
              act_text: "Even or odd numbers on number lines",
              comp: null,
            },
            {
              act_text: "Which even or odd number comes before or after?",
              comp: null,
            },
            {
              act_text: "Skip-counting patterns - with tables",
              comp: null,
            },
            {
              act_text: "Sequences - count up and down by 1, 2, 3, 5 and 10",
              comp: null,
            },
            {
              act_text: "	Sequences - count up and down by 100",
              comp: null,
            },
            {
              act_text: "	Ordinal numbers",
              comp: null,
            },
            {
              act_text: "Wriritng numbers in words",
              comp: null,
            },
          ],
        },
        B: {
          subject: "Maths",
          category: "B",
          catType: "Place values",
          components: [
            {
              act_text: "Place value models - tens and ones",
              comp: null,
            },
            {
              act_text: "Place value models - up to hundreds",
              comp: null,
            },
            {
              act_text: "Write tens and ones - up to 30",
              comp: null,
            },
            {
              act_text: "Write tens and ones - up to 100",
              comp: null,
            },
          ],
        },
        C: {
          subject: "Maths",
          category: "C",
          catType: "Understand addition",
          components: [
            {
              act_text: "Add with pictures - sums up to 10",
              comp: null,
            },
            {
              act_text: "	Addition sentences - sums up to 10",
              comp: null,
            },
            {
              act_text: "Addition sentences using number lines - sums up to 10",
              comp: null,
            },
            {
              act_text: "Adding zero",
              comp: null,
            },
          ],
        },
        D: {
          subject: "Maths",
          category: "D",
          catType: "Addition skill builders",
          components: [
            {
              act_text: "Adding 1",
              comp: G1_MA_D1,
            },
            {
              act_text: "Adding 2",
              comp: G1_MA_D2,
            },
            {
              act_text: "Adding 3",
              comp: G1_MA_D3,
            },
            {
              act_text: "Adding 4",
              comp: G1_MA_D4,
            },
            {
              act_text: "Adding 5",
              comp: G1_MA_D5,
            },
            {
              act_text: "Adding 6",
              comp: G1_MA_D6,
            },
            {
              act_text: "Adding 7",
              comp: G1_MA_D7,
            },
            {
              act_text: "Adding 8",
              comp: G1_MA_D8,
            },
            {
              act_text: "Adding 9",
              comp: G1_MA_D9,
            },
            {
              act_text: "Adding 0",
              comp: G1_MA_D10,
            },
          ],
        },
        E: {
          subject: "Maths",
          category: "E",
          catType: "Addition",
          components: [
            {
              act_text: "Addition facts - sums up to 10",
              comp: G1_MA_E1,
            },
            {
              act_text: "Ways to make a number - addition sentences",
              comp: GI_MA_E2,
            },
            {
              act_text: "Make a number using addition - sums up to 10",
              comp: GI_MA_E3,
            },
            {
              act_text: "	Complete the addition sentence - sums up to 10",
              comp: GI_MA_E4,
            },
            {
              act_text: "	Addition word problems - sums up to 10",
              comp: GI_MA_E5,
            },
            {
              act_text: "	Addition sentences for word problems - sums up to 10",
              comp: GI_MA_E6,
            },
            {
              act_text: "Addition facts - sums up to 18",
              comp: GI_MA_E7,
            },
            {
              act_text: "Addition sentences using number lines - sums up to 18",
              comp: GI_MA_E8,
            },
            {
              act_text: "	Addition word problems - sums up to 18",
              comp: GI_MA_E9,
            },
            {
              act_text: "Addition sentences for word problems - sums up to 18",
              comp: GI_MA_E10,
            },
            {
              act_text: "Addition facts - sums up to 20",
              comp: GI_MA_E11,
            },
            {
              act_text: "Make a number using addition - sums up to 20",
              comp: GI_MA_E12,
            },
            {
              act_text: "	Addition sentences for word problems - sums up to 20",
              comp: GI_MA_E13,
            },
            {
              act_text: "	Related addition facts",
              comp: GI_MA_E14,
            },
            {
              act_text: "Addition sentences: true or false?",
              comp: GI_MA_E15,
            },
            {
              act_text:
                "Add a one-digit number to a two-digit number - without regrouping",
              comp: GI_MA_E16,
            },
            {
              act_text:
                "Add a one-digit number to a two-digit number - with regrouping",
              comp: GI_MA_E17,
            },
          ],
        },
        F: {
          subject: "Maths",
          category: "F",
          catType: "Addition strategies",
          components: [
            {
              act_text: "	Add doubles",
              comp: G1_MA_F1,
            },
            {
              act_text: "Add using doubles plus one",
              comp: G1_MA_F2,
            },
            {
              act_text: "Add using doubles minus one",
              comp: G1_MA_F3,
            },
            {
              act_text: "Add three numbers - use doubles",
              comp: G1_MA_F4,
            },
            {
              act_text: "	Complete the addition sentence - make ten",
              comp: null,
            },
            {
              act_text: "Add three numbers - make ten",
              comp: G1_MA_F6,
            },
            {
              act_text: "Add two multiples of ten",
              comp: G1_MA_F7,
            },
            {
              act_text: "Add a multiple of ten",
              comp: G1_MA_F8,
            },
            {
              act_text: "	Add three numbers",
              comp: G1_MA_F9,
            },
            {
              act_text: "Add three numbers - word problems",
              comp: null,
            },
          ],
        },
        G: {
          subject: "Maths",
          category: "G",
          catType: "Understand subtraction",
          components: [
            {
              act_text: "	Subtract with pictures - numbers up to 10",
              comp: null,
            },
            {
              act_text: "Subtraction sentences - numbers up to 10",
              comp: null,
            },
            {
              act_text:
                "Subtraction sentences using number lines - numbers up to 10",
              comp: null,
            },
            {
              act_text: "Subtract zero and all",
              comp: null,
            },
          ],
        },

        H: {
          subject: "Maths",
          category: "H",
          catType: "Subtraction skill builders",
          components: [
            {
              act_text: "Subtraction 1",
              comp: G1_MS_H1,
            },
            {
              act_text: "Subtraction 2",
              comp:G1_MS_H2,
            },
            {
              act_text: "Subtraction 3",
              comp: G1_MS_H3,
            },
            {
              act_text: "Subtraction 4",
              comp: G1_MS_H4,
            },
            {
              act_text: "Subtraction 5",
              comp: G1_MS_H5,
            },
            {
              act_text: "Subtraction 6",
              comp: G1_MS_H6,
            },
            {
              act_text: "Subtraction 7",
              comp: G1_MS_H7,
            },
            {
              act_text: "Subtraction 8",
              comp: G1_MS_H8,
            },
            {
              act_text: "Subtraction 9",
              comp: G1_MS_H9,
            },
            {
              act_text: "Subtraction 0",
              comp: G1_MS_H10,
            },
          ],
        },
        I: {
          subject: "Maths",
          category: "I",
          catType: "Subtraction",
          components: [
            {
              act_text: "Subtraction facts - sums up to 10",
              comp: G1_MS_I1,
            },
            {
              act_text: "Ways to make a number - Subtraction sentences",
              comp: G1_MS_I2,
            },
            {
              act_text:
                "Ways to make a subtract from a number - Subtraction sentences",
              comp: G1_MS_I3,
            },
            {
              act_text: "	Make a number using subtraction - numbers up to 10",
              comp: G1_MS_I4,
            },
            {
              act_text: "Complete the subtraction sentence",
              comp: G1_MS_I5,
            },
            {
              act_text: "Subtraction word problems - numbers up to 10",
              comp: G1_MS_I6,
            },
            {
              act_text:
                "Subtraction sentences for word problems - numbers up to 10",
              comp: G1_MS_I7,
            },
            {
              act_text: "Subtraction facts - numbers up to 18",
              comp: G1_MS_I8,
            },
            {
              act_text:
                "Subtraction sentences using number lines - numbers up to 18",
              comp: G1_MS_I9,
            },
            {
              act_text: "	Subtraction word problems - numbers up to 18",
              comp: G1_MS_I10,
            },
            {
              act_text:
                "Subtraction sentences for word problems - numbers up to 18",
              comp: G1_MS_I11,
            },
            {
              act_text: "Make a number using Subtraction - numbers up to 20",
              comp: G1_MS_I12,
            },
            {
              act_text: "	Related Subtraction facts",
              comp: G1_MS_I13,
            },
            {
              act_text: "Subtraction sentences: true or false?",
              comp: G1_MS_I14,
            },
            {
              act_text:
                "Subtract a one-digit number to a two-digit number - without regrouping",
              comp: G1_MS_I15,
            },
            {
              act_text:
                "Subtract a one-digit number to a two-digit number - with regrouping",
              comp: G1_MS_I16,
            },
          ],
        },

        J: {
          subject: "Maths",
          category: "J",
          catType: "Subtraction subtraction",
          components: [
            {
              act_text: "Relate addition and subtraction sentences",
              comp: null,
            },
            {
              act_text: "Subtract doubles",
              comp: null,
            },
            {
              act_text: "Subtract multiples of 10",
              comp: null,
            },
            {
              act_text: "Subtract a multiple of 10",
              comp: null,
            },
          ],
        },

        K: {
          subject: "Maths",
          category: "K",
          catType: "Comparing",
          components: [
            {
              act_text: "Comparing - review",
              comp: null,
            },
            {
              act_text: "	Comparing numbers up to 10",
              comp: null,
            },
            {
              act_text: "Comparing numbers up to 100",
              comp: null,
            },
            {
              act_text: "Comparison word problems",
              comp: null,
            },
          ],
        },

        L: {
          subject: "Maths",
          category: "L",
          catType: "Estimnation",
          components: [
            {
              act_text: "	Estimate to the nearest ten",
              comp: null,
            },
          ],
        },

        M: {
          subject: "Maths",
          category: "M",
          catType: "Two-dimensional shapes",
          components: [
            {
              act_text: "Name the two-dimensional shape",
              comp: G1_MD_M1,
            },
            {
              act_text: "Select two-dimensional shapes",
              comp: G1_MD_M2,
            },
            {
              act_text: "Count sides and vertices",
              comp: G1_MD_M3,
            },
            {
              act_text: "Compare sides and vertices",
              comp: G1_MD_M4,
            },
            {
              act_text: "Open and closed shapes",
              comp: G1_MD_M5,
            },
            {
              act_text: "Flip, turn and slide",
              comp: null,
            },
            {
              act_text: "Symmetry",
              comp: G1_MD_M7,
            },
          ],
        },

        N: {
          subject: "Maths",
          category: "N",
          catType: "Three-dimensional shapes",
          components: [
            {
              act_text: "	Two-dimensional and three-dimensional shapes",
              comp: null,
            },
            {
              act_text: "Name the three-dimensional shape",
              comp: null,
            },
            {
              act_text: "Cubes and rectangular prisms",
              comp: null,
            },
            {
              act_text: "Select three-dimensional shapes",
              comp: null,
            },
            {
              act_text: "Count vertices, edges and faces",
              comp: null,
            },
            {
              act_text: "Compare vertices, edges and faces",
              comp: null,
            },
            {
              act_text: "	Identify shapes traced from solids",
              comp: null,
            },
            {
              act_text: "	Identify faces of three-dimensional shapes",
              comp: null,
            },
            {
              act_text: "Shapes of everyday objects I",
              comp: null,
            },
            {
              act_text: "Shapes of everyday objects II",
              comp: null,
            },
          ],
        },

        O: {
          subject: "Maths",
          category: "M",
          catType: "Spatial sense",
          components: [
            {
              act_text: "	Above and below",
              comp: null,
            },
            {
              act_text: "Beside and next to",
              comp: null,
            },
            {
              act_text: "Left, middle and right",
              comp: null,
            },
            {
              act_text: "Top, middle and bottom",
              comp: null,
            },
            {
              act_text: "Location in a grid",
              comp: null,
            },
          ],
        },
        P: {
          subject: "Maths",
          category: "P",
          catType: "Data and graphs",
          components: [
            {
              act_text: "	Which picture graph is correct?",
              comp: null,
            },
            {
              act_text: "	Interpret picture graphs",
              comp: null,
            },
            {
              act_text: "Which tally chart is correct?",
              comp: null,
            },
            {
              act_text: "Interpret tally charts",
              comp: null,
            },
            {
              act_text: "Which table is correct?",
              comp: null,
            },
            {
              act_text: "	Interpret data in tables",
              comp: null,
            },
          ],
        },
        Q: {
          subject: "Maths",
          category: "Q",
          catType: "Measurement",
          components: [
            {
              act_text: "	Long and short",
              comp: null,
            },
            {
              act_text: "	Tall and short",
              comp: null,
            },
            {
              act_text: "	Light and heavy",
              comp: null,
            },
            {
              act_text: "Compare size and weight",
              comp: null,
            },
          ],
        },
        R: {
          subject: "Maths",
          category: "R",
          catType: "Money",
          components: [
            {
              act_text: "	Coin values",
              comp: null,
            },
            {
              act_text: "Count coins",
              comp: null,
            },
            {
              act_text: "	Count notes",
              comp: null,
            },
          ],
        },
        S: {
          subject: "Maths",
          category: "S",
          catType: "Patterns",
          components: [
            {
              act_text: "Introduction to patterns",
              comp: null,
            },
            {
              act_text: "Find the next shape in a pattern",
              comp: null,
            },
            {
              act_text: "	Complete a pattern",
              comp: null,
            },
            {
              act_text: "Make a pattern",
              comp: null,
            },
            {
              act_text: "	Growing patterns",
              comp: null,
            },
            {
              act_text: "Find the next shape in a growing pattern",
              comp: null,
            },
            {
              act_text: "	Find the next row in a growing pattern",
              comp: null,
            },
          ],
        },
        T: {
          subject: "Maths",
          category: "T",
          catType: "Probability",
          components: [
            {
              act_text: "More, less and equally likely",
              comp: null,
            },
            {
              act_text: "Certain, probable, unlikely and impossible",
              comp: null,
            },
          ],
        },
        U: {
          subject: "Maths",
          category: "U",
          catType: "Sorting, ordering and classifying",
          components: [
            {
              act_text: "Sort shapes into a Venn diagram",
              comp: null,
            },
            {
              act_text: "	Count shapes in a Venn diagram",
              comp: null,
            },
            {
              act_text: "	Put numbers in order",
              comp: null,
            },
          ],
        },
        V: {
          subject: "Maths",
          category: "V",
          catType: "Time",
          components: [
            {
              act_text: "Days of the week",
              comp: null,
            },
            {
              act_text: "	Seasons of the year",
              comp: null,
            },
            {
              act_text: "	Read a calendar",
              comp: null,
            },
            {
              act_text: "Months of the year",
              comp: null,
            },
            {
              act_text: "A.M. or P.M.",
              comp: null,
            },
          ],
        },
        W: {
          subject: "Maths",
          category: "W",
          catType: "Mixed operations",
          components: [
            {
              act_text: "Addition and subtraction - ways to make a number",
              comp: null,
            },
            {
              act_text: "Which sign makes the number sentence true?",
              comp: null,
            },
            {
              act_text: "Fact families",
              comp: null,
            },
            {
              act_text: "Addition and subtraction facts - numbers up to 10",
              comp: null,
            },
            {
              act_text: "Addition and subtraction facts - numbers up to 18",
              comp: null,
            },
            {
              act_text: "Addition and subtraction word problems",
              comp: null,
            },
            {
              act_text: "Addition and subtraction terms",
              comp: null,
            },
          ],
        },
      },
      Class2: {
        A: {
          subject: "Maths",
          category: "A",
          catType: "Counting and number patterns",
          components: [
            {
              act_text: "Skip-counting",
              comp: null,
            },
            {
              act_text: "Skip-counting sequencese",
              comp: null,
            },
            {
              act_text: "Counting patterns - up to 100",
              comp: null,
            },
            {
              act_text: "Number lines - up to 100",
              comp: null,
            },
            {
              act_text: "Hundreds chart",
              comp: null,
            },
            {
              act_text: "Even or odd",
              comp: null,
            },
            {
              act_text: "	Identify numbers as even or odd",
              comp: null,
            },
            {
              act_text: "	Select even or odd numbers",
              comp: null,
            },
            {
              act_text: "Even or odd numbers on number lines",
              comp: null,
            },
            {
              act_text: "	Which even or odd number comes before or after?",
              comp: null,
            },
            {
              act_text: "	Skip-counting stories",
              comp: null,
            },
            {
              act_text: "	Skip-counting puzzles",
              comp: null,
            },
          ],
        },
        B: {
          subject: "Maths",
          category: "B",
          catType: "Comparing and ordering",
          components: [
            {
              act_text: "Comparing numbers up to 100",
              comp: null,
            },
            {
              act_text: "	Put numbers up to 100 in order",
              comp: null,
            },
            {
              act_text: "Greatest and least - word problems - up to 100",
              comp: null,
            },
          ],
        },
        C: {
          subject: "Maths",
          category: "C",
          catType: "Names of numbers",
          components: [
            {
              act_text: "Ordinal numbers up to 10th",
              comp: null,
            },
            {
              act_text: "Ordinal numbers up to 100th",
              comp: null,
            },
            {
              act_text: "Writing numbers up to 100 in words",
              comp: null,
            },
            {
              act_text: "Distinguishing ordinal and cardinal numbers",
              comp: null,
            },
          ],
        },
        D: {
          subject: "Maths",
          category: "D",
          catType: "Patterns",
          components: [
            {
              act_text: "Repeating patterns",
              comp: null,
            },
            {
              act_text: "Growing patterns",
              comp: null,
            },
            {
              act_text: "Find the next shape in a pattern",
              comp: null,
            },
            {
              act_text: "Complete a repeating pattern",
              comp: null,
            },
            {
              act_text: "Make a repeating pattern",
              comp: null,
            },
            {
              act_text: "Find the next row in a growing pattern",
              comp: null,
            },
          ],
        },
        E: {
          subject: "Maths",
          category: "E",
          catType: "Addition - one digit",
          components: [
            {
              act_text: "Review - add one-digit numbers - sums to 10",
              comp: GII_MA_E1,
            },
            {
              act_text: "Review - ways to make a number - sums to 10",
              comp: GII_MA_E2,
            },
            {
              act_text: "Review - writing addition sentences - sums to 10",
              comp: GII_MA_E3,
            },
            {
              act_text: "	Add doubles",
              comp: GII_MA_E4,
            },
            {
              act_text: "Add one-digit numbers",
              comp: GII_MA_E5,
            },
            {
              act_text: "	Addition with pictures - sums to 20",
              comp: GII_MA_E6,
            },
            {
              act_text:
                "	Write addition sentences to describe pictures - sums to 20",
              comp: GII_MA_E7,
            },
            {
              act_text: "Addition input/output tables - sums to 20",
              comp: GII_MA_E8,
            },
            {
              act_text: "Add zero",
              comp: GII_MA_E9,
            },
            {
              act_text: "	Addition word problems - one digit",
              comp: GII_MA_E10,
            },
            {
              act_text: "Complete the addition sentence - one digit",
              comp: GII_MA_E11,
            },
            {
              act_text: "	Write the addition sentence - one digit",
              comp: GII_MA_E12,
            },
            {
              act_text: "	Balance addition equations - one digit",
              comp: GII_MA_E13,
            },
            {
              act_text: "	Add three or more one-digit numbers",
              comp: GII_MA_E14,
            },
            {
              act_text: "	Add three or more one-digit numbers - word problems",
              comp: GII_MA_E15,
            },
            {
              act_text: "Identify repeated addition in arrays: sums to 10",
              comp: GII_MA_E16,
            },
            {
              act_text: "Write addition sentences for arrays: sums to 10",
              comp: GII_MA_E16,
            },
            {
              act_text: "Identify repeated addition in arrays: sums to 25",
              comp: GII_MA_E16,
            },
            {
              act_text: "Write addition sentences for arrays: sums to 25",
              comp: GII_MA_E16,
            },
          ],
        },
        F: {
          subject: "Maths",
          category: "F",
          catType: "Subtraction - one digit",
          components: [
            {
              act_text: "	Review - subtract one-digit numbers - up to 10",
              comp: null,
            },
            {
              act_text: "Review - ways to subtract - up to 10",
              comp: G2_MS_F4,
            },
            {
              act_text: "	Review - writing subtraction sentences - up to 10",
              comp: null,
            },
            {
              act_text: "Subtract doubles",
              comp: G2_MS_F6,
            },
            {
              act_text:
                "Subtract a one-digit number from a two-digit number up to 18",
              comp: null,
            },
            {
              act_text: "Subtraction with pictures",
              comp: null,
            },
            {
              act_text:
                "Write subtraction sentences to describe pictures - up to 18",
              comp: null,
            },
            {
              act_text: "	Subtraction input/output tables - up to 18",
              comp: G2_MS_F8,
            },
            {
              act_text: "Subtract zero/all",
              comp: null,
            },
            {
              act_text: "Subtraction word problems - up to 18",
              comp: G2_MS_F10,
            },
            {
              act_text: "	Complete the subtraction sentence - up to 18",
              comp: G2_MS_F11,
            },
            {
              act_text: "Write the subtraction sentence - up to 18",
              comp: G2_MS_F12,
            },
            {
              act_text: "Balance subtraction equations - up to 18",
              comp: G2_MS_F13,
            },
          ],
        },
        G: {
          subject: "Maths",
          category: "G",
          catType: "Addition - two digits",
          components: [
            {
              act_text: "Add multiples of 10",
              comp: null,
            },
            {
              act_text:
                "	Add a two-digit and a one-digit number - without regrouping",
              comp: null,
            },
            {
              act_text: "	Add a two-digit and a one-digit number - with regrouping",
              comp: null,
            },
            {
              act_text: "	Add two two-digit numbers - without regrouping",
              comp: null,
            },
            {
              act_text: "	Add two two-digit numbers - with regrouping",
              comp: null,
            },
            {
              act_text: "	Write addition sentences to describe pictures",
              comp: null,
            },
            {
              act_text: "	Addition input/output tables - up to two digits",
              comp: null,
            },
            {
              act_text: "Ways to make a number using addition",
              comp: null,
            },
            {
              act_text: "Addition word problems - up to two digits",
              comp: null,
            },
            {
              act_text: "	Complete the addition sentence - up to two digits",
              comp: null,
            },
            {
              act_text: "Write the addition sentence - up to two digits",
              comp: null,
            },
            {
              act_text: "Balance addition equations - up to two digits",
              comp: null,
            },
            {
              act_text: "	Add three or more numbers up to two digits each",
              comp: null,
            },
            {
              act_text:
                "	Add three or more numbers up to two digits - word problems",
              comp: null,
            },
          ],
        },
        H: {
          subject: "Maths",
          category: "H",
          catType: "Addition - two digits",
          components: [
            {
              act_text: "	Subtract multiples of 10",
              comp: null,
            },
            {
              act_text:
                "	Subtract a one-digit number from a two-digit number - without regrouping",
              comp: null,
            },
            {
              act_text:
                "	Subtract a one-digit number from a two-digit number - with regrouping",
              comp: null,
            },
            {
              act_text: "Subtract two two-digit numbers - without regrouping",
              comp: G2_MS_H4,
            },
            {
              act_text: "Subtract two two-digit numbers - with regrouping",
              comp: G2_MS_H5,
            },
            {
              act_text:
                "Write subtraction sentences to describe pictures - up to two digits",
              comp: null,
            },
            {
              act_text: "Subtraction input/output tables - up to two digits",
              comp: null,
            },
            {
              act_text: "Ways to make a number using subtraction",
              comp: null,
            },
            {
              act_text: "	Subtraction word problems - up to two digits",
              comp: null,
            },
            {
              act_text: "	Complete the subtraction sentence - up to two digits",
              comp: null,
            },
            {
              act_text: "Write the subtraction sentence - up to two digits",
              comp: null,
            },
            {
              act_text: "	Balance subtraction equations - up to two digits",
              comp: null,
            },
          ],
        },
        I: {
          subject: "Maths",
          category: "I",
          catType: "Properties",
          components: [
            {
              act_text: "Related addition facts",
              comp: null,
            },
            {
              act_text: "Related subtraction facts",
              comp: null,
            },
            {
              act_text: "Fact families",
              comp: null,
            },
            {
              act_text: "Addition and subtraction terms",
              comp: null,
            },
          ],
        },
        J: {
          subject: "Maths",
          category: "J",
          catType: "Place values",
          components: [
            {
              act_text: "Place value models - tens and ones",
              comp: null,
            },
            {
              act_text: "Place value - tens and ones",
              comp: null,
            },
            {
              act_text: "	Regroup tens and ones",
              comp: null,
            },
            {
              act_text: "	Regroup tens and ones - ways to make a number",
              comp: null,
            },
            {
              act_text: "	Convert to/from a number - tens and ones",
              comp: null,
            },
            {
              act_text: "Convert between place values - tens and ones",
              comp: null,
            },
          ],
        },
        K: {
          subject: "Maths",
          category: "K",
          catType: "Estimation and rounding",
          components: [
            {
              act_text: "Estimate to the nearest ten",
              comp: null,
            },
            {
              act_text: "Round to the nearest ten",
              comp: null,
            },
            {
              act_text: "Estimate sums",
              comp: null,
            },
          ],
        },

        L: {
          subject: "Maths",
          category: "L",
          catType: "Money",
          components: [
            {
              act_text: "Coin values",
              comp: null,
            },
            {
              act_text: "Count money - up to 10 rupees",
              comp: null,
            },
            {
              act_text: "Count money - up to 50 rupees",
              comp: null,
            },
            {
              act_text: "	Equivalent amounts of money - up to 10 rupees",
              comp: null,
            },
            {
              act_text: "	Equivalent amounts of money - up to 50 rupees",
              comp: null,
            },
            {
              act_text: "Exchanging coins",
              comp: null,
            },
            {
              act_text: "	Comparing groups of coins",
              comp: null,
            },
            {
              act_text: "Add and subtract money - word problems - up to 10 rupees",
              comp: null,
            },
            {
              act_text: "Which picture shows more - up to 10 rupees",
              comp: null,
            },
            {
              act_text: "Which picture shows more - up to 50 rupees",
              comp: null,
            },
            {
              act_text: "	Least number of coins",
              comp: null,
            },
            {
              act_text: "Purchases - do you have enough money - up to 10 rupees",
              comp: null,
            },
            {
              act_text: "Purchases - do you have enough money - up to 50 rupees",
              comp: null,
            },
            {
              act_text: "Making change",
              comp: null,
            },
          ],
        },

        M: {
          subject: "Maths",
          category: "M",
          catType: "Time",
          components: [
            {
              act_text: "Days of the week",
              comp: null,
            },
            {
              act_text: "Seasons",
              comp: null,
            },
            {
              act_text: "Read a calender",
              comp: null,
            },
            {
              act_text: "Month of the year",
              comp: null,
            },
            {
              act_text: "number of days in each month",
              comp: null,
            },
            {
              act_text: "relate time units",
              comp: null,
            },
            {
              act_text: "	A.M. or P.M.",
              comp: null,
            },
          ],
        },
        N: {
          subject: "Maths",
          category: "N",
          catType: "Data and graphs",
          components: [
            {
              act_text: "	Which tally chart is correct?",
              comp: null,
            },
            {
              act_text: "Interpret tally charts",
              comp: null,
            },
          ],
        },
        O: {
          subject: "Maths",
          category: "O",
          catType: "Geometry",
          components: [
            {
              act_text: "	Name the two-dimensional shape",
              comp: null,
            },
            {
              act_text: "Select two-dimensional shapes",
              comp: null,
            },
            {
              act_text: "Count sides and vertices",
              comp: null,
            },
            {
              act_text: "Compare sides and vertices",
              comp: null,
            },
            {
              act_text: "Name the three-dimensional shape",
              comp: null,
            },
            {
              act_text: "Select the three-dimensional shape",
              comp: null,
            },
            {
              act_text: "Count vertices, edges and faces",
              comp: null,
            },
            {
              act_text: "Compare vertices, edges and faces",
              comp: null,
            },
            {
              act_text: "Flip, turn and slide",
              comp: null,
            },
          ],
        },
        P: {
          subject: "Maths",
          category: "P",
          catType: "Measurement",
          components: [
            {
              act_text: "Long and short",
              comp: null,
            },
            {
              act_text: "Tall and short",
              comp: null,
            },
            {
              act_text: "	Light and heavy",
              comp: null,
            },
            {
              act_text: "	Holds more or less",
              comp: null,
            },
            {
              act_text: "Compare size, weight and capacity",
              comp: null,
            },
            {
              act_text: "	Choose the appropriate measuring tool",
              comp: null,
            },
            {
              act_text: "Measure using objects",
              comp: null,
            },
            {
              act_text: "Measure using a centimetre ruler",
              comp: null,
            },
          ],
        },
        Q: {
          subject: "Maths",
          category: "Q",
          catType: "Logical reasoning",
          components: [
            {
              act_text: "Guess the number",
              comp: null,
            },
          ],
        },
        R: {
          subject: "Maths",
          category: "R",
          catType: "Probability",
          components: [
            {
              act_text: "	More, less and equally likely",
              comp: null,
            },
            {
              act_text: "Certain, probable, unlikely and impossible",
              comp: null,
            },
          ],
        },

        S: {
          subject: "Maths",
          category: "S",
          catType: "Mixed operations",
          components: [
            {
              act_text: "Add and subtract numbers up to 20",
              comp: null,
            },
            {
              act_text:
                "	Addition and subtraction - ways to make a number - up to 20",
              comp: null,
            },
            {
              act_text: "	Addition and subtraction word problems - up to 20",
              comp: null,
            },
            {
              act_text: "Addition and subtraction - balance equations - up to 20",
              comp: null,
            },
            {
              act_text: "Input/output tables - write the rule - up to 20",
              comp: null,
            },
            {
              act_text: "	Add and subtract numbers up to 100",
              comp: null,
            },
            {
              act_text:
                "	Addition and subtraction - ways to make a number - up to 100",
              comp: null,
            },
            {
              act_text: "	Addition and subtraction word problems - up to 100",
              comp: null,
            },
            {
              act_text: "Addition and subtraction - balance equations - up to 100",
              comp: null,
            },
            {
              act_text: "	Input/output tables - write the rule - up to 100",
              comp: null,
            },
            {
              act_text: "Which sign (+ or -) makes the number sentence true?",
              comp: null,
            },
            {
              act_text: "Write addition and subtraction sentences",
              comp: null,
            },
          ],
        },
      },
      Class3: {
        A: {
          subject: "Maths",
          category: "A",
          catType: "NUmbers and comparaing",
          components: [
            {
              act_text: "Even or odd",
              comp: null,
            },
            {
              act_text: "	Even or odd: arithmetic rules",
              comp: null,
            },
            {
              act_text: "Skip-counting puzzles",
              comp: null,
            },
            {
              act_text: "Number sequences",
              comp: null,
            },
            {
              act_text: "Ordinal numbers to 100th",
              comp: null,
            },
            {
              act_text: "Write numbers in words",
              comp: null,
            },
            {
              act_text: "Comparing numbers",
              comp: null,
            },
            {
              act_text: "Which number is greatest/least?",
              comp: null,
            },
            {
              act_text: "Put numbers in order",
              comp: null,
            },
          ],
        },
        B: {
          subject: "Maths",
          category: "B",
          catType: "Place values",
          components: [
            {
              act_text: "Place value models up to hundreds",
              comp: null,
            },
            {
              act_text: "Place value names up to hundreds",
              comp: null,
            },
            {
              act_text: "Place value models up to thousands",
              comp: null,
            },
            {
              act_text: "Value of a digit",
              comp: null,
            },
            {
              act_text: "Convert to/from a number",
              comp: null,
            },
            {
              act_text: "	Convert between place values",
              comp: null,
            },
            {
              act_text: "	Convert from expanded form",
              comp: null,
            },
            {
              act_text: "	Convert between standard and expanded form",
              comp: null,
            },
            {
              act_text: "Place value word problems",
              comp: null,
            },
          ],
        },
        C: {
          subject: "Maths",
          category: "C",
          catType: "Addition",
          components: [
            {
              act_text: "Add two numbers up to three digits",
              comp: GIII_MA_C1,
            },
            {
              act_text: "	Addition input/output tables - up to three digits",
              comp: GIII_MA_C2,
            },
            {
              act_text: "Add two numbers up to three digits - word problems",
              comp: GIII_MA_C3,
            },
            {
              act_text: "Complete the addition sentence - up to three digits",
              comp: GIII_MA_C4,
            },
            {
              act_text: "	Balance addition equations - up to three digits",
              comp: GIII_MA_C5,
            },
            {
              act_text: "Add three or more numbers up to three digits each",
              comp: GIII_MA_C6,
            },
            {
              act_text:
                "Add three or more numbers up to three digits - word problems",
              comp: GIII_MA_C7,
            },
            {
              act_text: "	Addition patterns over increasing place values",
              comp: GIII_MA_C8,
            },
            {
              act_text: "Addition: fill in the missing digits",
              comp: GIII_MA_C9,
            },
          ],
        },
        D: {
          subject: "Maths",
          category: "D",
          catType: "Subtraction",
          components: [
            {
              act_text: "	Subtract numbers up to three digits",
              comp: G3_MS_D1,
            },
            {
              act_text: "	Subtraction input/output tables - up to three digits",
              comp: G3_MS_D2,
            },
            {
              act_text: "Subtract numbers up to three digits - word problems",
              comp: G3_MS_D3,
            },
            {
              act_text: "Complete the subtraction sentence - up to three digits",
              comp: G3_MS_D4,
            },
            {
              act_text: "	Balance subtraction equations - up to three digits",
              comp: G3_MS_D5,
            },
            {
              act_text: "Subtraction patterns over increasing place values",
              comp: G3_MS_D6,
            },
            {
              act_text: "Subtraction: fill in the missing digits",
              comp: null,
            },
          ],
        },
        E: {
          subject: "Maths",
          category: "E",
          catType: "Understand multiplication",
          components: [
            {
              act_text: "Count equal groups",
              comp: null,
            },
            {
              act_text: "	Identify multiplication expressions for equal groups",
              comp: null,
            },
            {
              act_text: "Write multiplication sentences for equal groups",
              comp: null,
            },
            {
              act_text: "Relate addition and multiplication for equal groups",
              comp: null,
            },
            {
              act_text: "Identify multiplication expressions for arrays",
              comp: null,
            },
            {
              act_text: "	Write multiplication sentences for arrays",
              comp: null,
            },
            {
              act_text: "Make arrays to model multiplication",
              comp: null,
            },
            {
              act_text: "Write multiplication sentences for number lines",
              comp: null,
            },
          ],
        },
        F: {
          subject: "Maths",
          category: "F",
          catType: "Multiplication skill builders",
          components: [
            {
              act_text: "Multiply by 0",
              comp: null,
            },
            {
              act_text: "Multiply by 1",
              comp: null,
            },
            {
              act_text: "Multiply by 2",
              comp: null,
            },
            {
              act_text: "Multiply by 3",
              comp: null,
            },
            {
              act_text: "Multiply by 4",
              comp: null,
            },
            {
              act_text: "Multiply by 5",
              comp: null,
            },
            {
              act_text: "Multiply by 6",
              comp: null,
            },
            {
              act_text: "Multiply by 7",
              comp: null,
            },
            {
              act_text: "Multiply by 8",
              comp: null,
            },
            {
              act_text: "Multiply by 9",
              comp: null,
            },
            {
              act_text: "Multiply by 10",
              comp: null,
            },
          ],
        },
        G: {
          subject: "Maths",
          category: "G",
          catType: "Multiplication fluency",
          components: [
            {
              act_text: "Multiplication tables for 2, 3, 4, 5, 10",
              comp: null,
            },
            {
              act_text: "Multiplication facts for 2, 3, 4, 5, 10: true or false?",
              comp: null,
            },
            {
              act_text: "	Multiplication facts for 2, 3, 4, 5, 10: sorting",
              comp: null,
            },
            {
              act_text: "Multiplication facts for 6, 7, 8, 9",
              comp: null,
            },
            {
              act_text: "Multiplication facts for 6, 7, 8, 9: true or false?",
              comp: null,
            },
            {
              act_text: "Multiplication facts for 6, 7, 8, 9: sorting",
              comp: null,
            },
            {
              act_text: "	Multiplication facts up to 10",
              comp: null,
            },
            {
              act_text: "	Multiplication facts up to 10: true or false?",
              comp: null,
            },
            {
              act_text: "	Multiplication facts up to 10: sorting",
              comp: null,
            },
            {
              act_text: "Multiplication sentences up to 10: true or false?",
              comp: null,
            },
            {
              act_text: "Multiplication facts up to 10: find the missing factor",
              comp: null,
            },
            {
              act_text: "Multiplication facts up to 10: select the missing factors",
              comp: null,
            },
            {
              act_text: "Squares up to 10 x 10",
              comp: null,
            },
          ],
        },
        H: {
          subject: "Maths",
          category: "H",
          catType: "Multiplication",
          components: [
            {
              act_text: "Multiplication sentences",
              comp: null,
            },
            {
              act_text: "	Multiply numbers ending in zeroes",
              comp: null,
            },
            {
              act_text: "	Multiplication input/output tables",
              comp: null,
            },
            {
              act_text: "Multiplication word problems",
              comp: null,
            },
            {
              act_text: "Multiplication word problems: find the missing factor",
              comp: null,
            },
            {
              act_text: "	Multiply one-digit numbers by two-digit numbers",
              comp: null,
            },
            {
              act_text:
                "Multiply one-digit numbers by two-digit numbers: word problems",
              comp: null,
            },
            {
              act_text: "	Multiply one-digit numbers by three-digit numbers",
              comp: null,
            },
            {
              act_text:
                "M	Multiply one-digit numbers by three-digit numbers: word problems",
              comp: null,
            },
            {
              act_text: "Box multiplication",
              comp: null,
            },
            {
              act_text: "Lattice multiplication",
              comp: null,
            },
          ],
        },
        I: {
          subject: "Maths",
          category: "I",
          catType: "Understand division",
          components: [
            {
              act_text: "Divide by counting equal groups",
              comp: null,
            },
            {
              act_text: "Write division sentences for groups",
              comp: null,
            },
            {
              act_text: "Relate multiplication and division for groups",
              comp: null,
            },
            {
              act_text: "Write division sentences for arrays",
              comp: null,
            },
            {
              act_text: "Relate multiplication and division for arrays",
              comp: null,
            },
          ],
        },
        J: {
          subject: "Maths",
          category: "J",
          catType: "Divison skill builders",
          components: [
            {
              act_text: "Divide by 1",
              comp: null,
            },
            {
              act_text: "Divide by 2",
              comp: null,
            },
            {
              act_text: "Divide by 3",
              comp: null,
            },
            {
              act_text: "Divide by 4",
              comp: null,
            },
            {
              act_text: "Divide by 5",
              comp: null,
            },
            {
              act_text: "Divide by 6",
              comp: null,
            },
            {
              act_text: "Divide by 7",
              comp: null,
            },
            {
              act_text: "Divide by 8",
              comp: null,
            },
            {
              act_text: "Divide by 9",
              comp: null,
            },
            {
              act_text: "Divide by 10",
              comp: null,
            },
          ],
        },
        K: {
          subject: "Maths",
          category: "K",
          catType: "Divison fluency",
          components: [
            {
              act_text: "Division facts for 2, 3, 4, 5, 10",
              comp: null,
            },
            {
              act_text: "Division facts for 2, 3, 4, 5, 10: true or false?",
              comp: null,
            },
            {
              act_text: "Division facts for 2, 3, 4, 5, 10: sorting",
              comp: null,
            },
            {
              act_text: "Division facts for 6, 7, 8, 9",
              comp: null,
            },
            {
              act_text: "Division facts for 6, 7, 8, 9: true or false?",
              comp: null,
            },
            {
              act_text: "Division facts for 6, 7, 8, 9: sorting",
              comp: null,
            },
            {
              act_text: "Division facts up to 10",
              comp: null,
            },
            {
              act_text: "Division facts up to 10: true or false?",
              comp: null,
            },
            {
              act_text: "Division facts up to 10: sorting",
              comp: null,
            },
            {
              act_text: "Division facts up to 10: find the missing number",
              comp: null,
            },
            {
              act_text: "Division sentences up to 10: true or false?",
              comp: null,
            },
          ],
        },
        L: {
          subject: "Maths",
          category: "L",
          catType: "Division",
          components: [
            {
              act_text: "Complete the division table",
              comp: null,
            },
            {
              act_text: "WDivision input/output tables",
              comp: null,
            },
            {
              act_text: "Division word problems",
              comp: null,
            },
            {
              act_text: "Divisibility rules for 2, 5 and 10",
              comp: null,
            },
          ],
        },
        M: {
          subject: "Maths",
          category: "M",
          catType: "Data and graphs",
          components: [
            {
              act_text: "	Interpret line plots",
              comp: null,
            },
            {
              act_text: "Create line plots",
              comp: null,
            },
            {
              act_text: "Interpret pictographs",
              comp: null,
            },
            {
              act_text: "Create pictographs",
              comp: null,
            },
            {
              act_text: "	Sort shapes into a Venn diagram",
              comp: null,
            },
            {
              act_text: "Count shapes in a Venn diagram",
              comp: null,
            },
          ],
        },

        N: {
          subject: "Maths",
          category: "N",
          catType: "Money",
          components: [
            {
              act_text: "Count coins and notes - up to 500-rupee note",
              comp: null,
            },
            {
              act_text: "Which picture shows more?",
              comp: null,
            },
            {
              act_text: "Purchases - do you have enough money - up to 1,000 rupees",
              comp: null,
            },
            {
              act_text: "Making change",
              comp: null,
            },
            {
              act_text: "	Inequalities with money",
              comp: null,
            },
            {
              act_text: "Put money amounts in order",
              comp: null,
            },
            {
              act_text: "Add and subtract money amounts",
              comp: null,
            },
            {
              act_text: "Add money amounts - word problems",
              comp: null,
            },
            {
              act_text: "Price lists",
              comp: null,
            },
          ],
        },
        O: {
          subject: "Maths",
          category: "O",
          catType: "Time",
          components: [
            {
              act_text: "	Match analogue clocks and times",
              comp: null,
            },
            {
              act_text: "Match digital clocks and times",
              comp: null,
            },
            {
              act_text: "Read clocks and write times",
              comp: null,
            },
            {
              act_text: "A.M. or P.M.",
              comp: null,
            },
            {
              act_text: "	Elapsed time",
              comp: null,
            },
            {
              act_text: "Elapsed time word problems",
              comp: null,
            },
            {
              act_text: "	Time patterns",
              comp: null,
            },
            {
              act_text: "Read a calendar",
              comp: null,
            },
            {
              act_text: "	Reading schedules",
              comp: null,
            },
            {
              act_text: "Timelines",
              comp: null,
            },
          ],
        },
        P: {
          subject: "Maths",
          category: "P",
          catType: "Measurement",
          components: [
            {
              act_text: "Measure using a centimetre ruler",
              comp: null,
            },
            {
              act_text: "Which metric unit of length is appropriate?",
              comp: null,
            },
            {
              act_text: "	Compare and convert metric units of length",
              comp: null,
            },
            {
              act_text: "	Conversion tables",
              comp: null,
            },
            {
              act_text: "Metric mixed units",
              comp: null,
            },
            {
              act_text: "Light and heavy",
              comp: null,
            },
            {
              act_text: "	Holds more or less",
              comp: null,
            },
            {
              act_text: "Compare weight and capacity",
              comp: null,
            },
            {
              act_text: "Read a thermometer",
              comp: null,
            },
            {
              act_text: "Reasonable temperature",
              comp: null,
            },
          ],
        },
        Q: {
          subject: "Maths",
          category: "Q",
          catType: "Geometry",
          components: [
            {
              act_text: "Identify two-dimensional shapes",
              comp: null,
            },
            {
              act_text: "	Count and compare sides and vertices",
              comp: null,
            },
            {
              act_text: "	Identify three-dimensional shapes",
              comp: null,
            },
            {
              act_text: "Count vertices, edges and faces",
              comp: null,
            },
            {
              act_text: "Identify faces of three-dimensional shapes",
              comp: null,
            },
            {
              act_text: "Is it a polygon?",
              comp: null,
            },
            {
              act_text: "	Reflection, rotation and translation",
              comp: null,
            },
            {
              act_text: "Symmetry",
              comp: null,
            },
            {
              act_text: "	Maps",
              comp: null,
            },
            {
              act_text: "Find the area of rectangles and squares",
              comp: null,
            },
            {
              act_text: "	Find the missing side length of a rectangle",
              comp: null,
            },
          ],
        },
        R: {
          subject: "Maths",
          category: "R",
          catType: "Properties",
          components: [
            {
              act_text: "Addition, subtraction, multiplication and division terms",
              comp: null,
            },
            {
              act_text: "Understanding parentheses",
              comp: null,
            },
            {
              act_text: "	Properties of addition",
              comp: null,
            },
            {
              act_text: "Solve using properties of addition",
              comp: null,
            },
            {
              act_text: "	Properties of multiplication",
              comp: null,
            },
            {
              act_text: "	Solve using properties of multiplication",
              comp: null,
            },
            {
              act_text: "	Distributive property: find the missing factor",
              comp: null,
            },
            {
              act_text: "Multiply using the distributive property",
              comp: null,
            },
            {
              act_text: "Relate addition and multiplication",
              comp: null,
            },
            {
              act_text: "	Relate multiplication and division",
              comp: null,
            },
          ],
        },
        S: {
          subject: "Maths",
          category: "S",
          catType: "Mixed opoerations",
          components: [
            {
              act_text: "Addition, subtraction, multiplication and division facts",
              comp: null,
            },
            {
              act_text:
                "	Complete the addition, subtraction, multiplication or division sentence",
              comp: null,
            },
            {
              act_text: "Multiplication and division facts up to 5: true or false?",
              comp: null,
            },
            {
              act_text:
                "Multiplication and division facts up to 10: true or false?",
              comp: null,
            },
            {
              act_text:
                "Multiplication and division facts up to 12: true or false?",
              comp: null,
            },
            {
              act_text:
                "	Multiplication and division sentences up to 12: true or false?",
              comp: null,
            },
            {
              act_text: "Add, subtract, multiply and divide",
              comp: null,
            },
            {
              act_text:
                "Addition, subtraction, multiplication and division word problems",
              comp: null,
            },
            {
              act_text: "Add and subtract data from tables",
              comp: null,
            },
            {
              act_text: "	Multi-step word problems",
              comp: null,
            },
            {
              act_text: "	Missing operators",
              comp: null,
            },
          ],
        },
        T: {
          subject: "Maths",
          category: "T",
          catType: "Estimation and rounding",
          components: [
            {
              act_text: "	Rounding",
              comp: null,
            },
            {
              act_text: "Round money amounts",
              comp: null,
            },
            {
              act_text: "Rounding puzzles",
              comp: null,
            },
            {
              act_text: "Estimate sums",
              comp: null,
            },
            {
              act_text: "Estimate sums: word problems",
              comp: null,
            },
            {
              act_text: "Estimate differences",
              comp: null,
            },
            {
              act_text: "Estimate differences: word problems",
              comp: null,
            },
            {
              act_text: "Estimate products",
              comp: null,
            },
            {
              act_text: "Estimate products: word problems",
              comp: null,
            },
            {
              act_text: "	Estimate sums, differences and products: word problems",
              comp: null,
            },
          ],
        },
        U: {
          subject: "Maths",
          category: "U",
          catType: "Logical resoning",
          components: [
            {
              act_text: "Guess the number",
              comp: null,
            },
            {
              act_text: "	Largest/smallest number possible",
              comp: null,
            },
            {
              act_text: "Find the order",
              comp: null,
            },
            {
              act_text: "Age puzzles",
              comp: null,
            },
            {
              act_text: "	Find two numbers based on sum and difference",
              comp: null,
            },
            {
              act_text:
                "	Find two numbers based on sum, difference, product and quotient",
              comp: null,
            },
          ],
        },
        V: {
          subject: "Maths",
          category: "V",
          catType: "Patterns",
          components: [
            {
              act_text: "Repeating patterns",
              comp: null,
            },
            {
              act_text: "Growing patterns",
              comp: null,
            },
            {
              act_text: "Find the next shape in a pattern",
              comp: null,
            },
            {
              act_text: "Complete a repeating pattern",
              comp: null,
            },
            {
              act_text: "Make a repeating pattern",
              comp: null,
            },
            {
              act_text: "Find the next row in a growing pattern",
              comp: null,
            },
          ],
        },
        W: {
          subject: "Maths",
          category: "W",
          catType: "Probaility",
          components: [
            {
              act_text: "More, less and equally likely",
              comp: null,
            },
            {
              act_text: "Certain, probable, unlikely and impossible",
              comp: null,
            },
            {
              act_text: "Combinations",
              comp: null,
            },
          ],
        },
      },
      Class4: {
        A: {
          subject: "Maths",
          category: "A",
          catType: "Number sense",
          components: [
            {
              act_text: "	Place values",
              comp: null,
            },
            {
              act_text: "Convert between place values",
              comp: null,
            },
            {
              act_text: "	Word names for numbers",
              comp: null,
            },
            {
              act_text: "Ordinal numbers to 100th",
              comp: null,
            },
            {
              act_text: "	Rounding",
              comp: null,
            },
            {
              act_text: "Even or odd: arithmetic rules",
              comp: null,
            },
            {
              act_text: "Inequalities with number lines",
              comp: null,
            },
            {
              act_text: "Compare numbers up to five digits",
              comp: null,
            },
          ],
        },
        B: {
          subject: "Maths",
          category: "B",
          catType: "Addition",
          components: [
            {
              act_text: "Add numbers up to five digits",
              comp: GIV_MA_B1,
            },
            {
              act_text: "Add numbers up to five digits: word problems",
              comp: GIV_MA_B2,
            },
            {
              act_text: "Addition: fill in the missing digits",
              comp: GIV_MA_B3,
            },
            {
              act_text: "Properties of addition",
              comp: GIV_MA_B4,
            },
            {
              act_text: "Add three or more numbers up to five digits each",
              comp: GIV_MA_B5,
            },
            {
              act_text: "Addition patterns over increasing place values",
              comp: GIV_MA_B6,
            },
            {
              act_text: "Choose numbers with a particular sum",
              comp: GIV_MA_B7,
            },
            {
              act_text: "Estimate sums",
              comp: GIV_MA_B8,
            },
            {
              act_text: "Estimate sums: word problems",
              comp: GIV_MA_B9,
            },
          ],
        },

        C: {
          subject: "Maths",
          category: "C",
          catType: "Subtraction",
          components: [
            {
              act_text: "Subtract numbers up to five digits",
              comp: G4_MS_C1,
            },
            {
              act_text: "Subtract numbers up to five digits: word problems",
              comp: G4_MS_C2,
            },
            {
              act_text: "Subtraction: fill in the missing digits",
              comp: G4_MS_C3,
            },
            {
              act_text: "Subtraction patterns over increasing place values",
              comp: G4_MS_C4,
            },
            {
              act_text: "	Choose numbers with a particular difference",
              comp: G4_MS_C5,
            },
            {
              act_text: "Estimate differences",
              comp: G4_MS_C6,
            },
            {
              act_text: "	Estimate differences: word problems",
              comp: G4_MS_C7,
            },
          ],
        },
        D: {
          subject: "Maths",
          category: "D",
          catType: "Multiplication",
          components: [
            {
              act_text: "Multiplication facts up to 10",
              comp: null,
            },
            {
              act_text: "Multiplication facts up to 10: find the missing factor",
              comp: null,
            },
            {
              act_text: "	Compare numbers using multiplication",
              comp: null,
            },
            {
              act_text: "	Multiply 1-digit numbers by 3-digit",
              comp: null,
            },
            {
              act_text: "	Multiply 1-digit numbers by 3-digit or 4-digit numbers",
              comp: null,
            },
            {
              act_text: "Multiply 1-digit numbers by larger numbers",
              comp: null,
            },
            {
              act_text: "	Multiplication patterns over increasing place values",
              comp: null,
            },
            {
              act_text: "Properties of multiplication",
              comp: null,
            },
            {
              act_text: "Estimate products - multiply by 1-digit numbers",
              comp: null,
            },
            {
              act_text: "Estimate products - multiply by larger numbers",
              comp: null,
            },
            {
              act_text: "	Estimate products: word problems",
              comp: null,
            },
            {
              act_text: "	Box multiplication",
              comp: null,
            },
            {
              act_text: "	Lattice multiplication",
              comp: null,
            },
            {
              act_text:
                "Multiply a two-digit number by a two-digit number: complete the missing steps",
              comp: null,
            },
            {
              act_text: "	Multiply a two-digit number by a two-digit number",
              comp: null,
            },
            {
              act_text:
                "	Multiply a two-digit number by a two-digit number: word problems",
              comp: null,
            },
            {
              act_text:
                "	Multiply a two-digit number by a three-digit number: complete the missing steps",
              comp: null,
            },
            {
              act_text: "	Multiply a two-digit number by a three-digit number",
              comp: null,
            },
            {
              act_text:
                "	Multiply a two-digit number by a three-digit number: word problems",
              comp: null,
            },
            {
              act_text: "Multiply numbers ending in zeroes",
              comp: null,
            },
            {
              act_text: "Multiply numbers ending in zeroes: word problems",
              comp: null,
            },
            {
              act_text: "Multiply three numbers",
              comp: null,
            },
          ],
        },
        E: {
          subject: "Maths",
          category: "E",
          catType: "Division",
          components: [
            {
              act_text: "Division facts to 10",
              comp: null,
            },
            {
              act_text: "Division facts to 10: word problems",
              comp: null,
            },
            {
              act_text: "Properties of division",
              comp: null,
            },
            {
              act_text: "Divide larger numbers",
              comp: null,
            },
            {
              act_text: "Divide larger numbers: word problems",
              comp: null,
            },
            {
              act_text: "Complete the division table",
              comp: null,
            },
            {
              act_text: "	Interpret remainders",
              comp: null,
            },
            {
              act_text: "	Choose numbers with a particular quotient",
              comp: null,
            },
            {
              act_text: "Divide numbers ending in zeroes",
              comp: null,
            },
            {
              act_text: "Estimate quotients: word problems",
              comp: null,
            },
            {
              act_text: "	Divisibility rules",
              comp: null,
            },
            {
              act_text: "	Divisibility rules: word problems",
              comp: null,
            },
            {
              act_text: "Division patterns over increasing place values",
              comp: null,
            },
          ],
        },
        F: {
          subject: "Maths",
          category: "F",
          catType: "Mixed operations",
          components: [
            {
              act_text: "Add, subtract, multiply and divide",
              comp: null,
            },
            {
              act_text:
                "Addition, subtraction, multiplication and division word problems",
              comp: null,
            },
            {
              act_text:
                "Estimate sums, differences, products and quotients: word problems",
              comp: null,
            },
            {
              act_text: "	Multi-step word problems",
              comp: null,
            },
            {
              act_text: "	Word problems with extra or missing information",
              comp: null,
            },
            {
              act_text: "	Solve word problems using guess-and-check",
              comp: null,
            },
            {
              act_text:
                "	Choose numbers with a particular sum, difference, product or quotient",
              comp: null,
            },
            {
              act_text: "Mentally add and subtract numbers ending in zeroes",
              comp: null,
            },
          ],
        },
        G: {
          subject: "Maths",
          category: "G",
          catType: "Logical reasoning",
          components: [
            {
              act_text: "Find two numbers based on sum, difference",
              comp: null,
            },
            {
              act_text:
                "Find two numbers based on sum, difference, product and quotient",
              comp: null,
            },
            {
              act_text: "	Find the order",
              comp: null,
            },
          ],
        },
        H: {
          subject: "Maths",
          category: "H",
          catType: "Data and graphs",
          components: [
            {
              act_text: "Read a table",
              comp: null,
            },
            {
              act_text: "	Interpret bar graphs",
              comp: null,
            },
            {
              act_text: "Create bar graphs",
              comp: null,
            },
            {
              act_text: "	Interpret line plots",
              comp: null,
            },
            {
              act_text: "Create line plots",
              comp: null,
            },
            {
              act_text: "Frequency charts",
              comp: null,
            },
            {
              act_text: "	Interpret stem-and-leaf plots",
              comp: null,
            },
            {
              act_text: "Create stem-and-leaf plots",
              comp: null,
            },
            {
              act_text: "Choose the best type of graph",
              comp: null,
            },
          ],
        },
        I: {
          subject: "Maths",
          category: "I",
          catType: "Patterns and sequence",
          components: [
            {
              act_text: "Complete an increasing number pattern",
              comp: null,
            },
            {
              act_text: "	Complete a geometric number pattern",
              comp: null,
            },
            {
              act_text: "	Number patterns: word problems",
              comp: null,
            },
            {
              act_text: "Number patterns: mixed review",
              comp: null,
            },
          ],
        },
        J: {
          subject: "Maths",
          category: "J",
          catType: "Money",
          components: [
            {
              act_text: "	Compare money amounts",
              comp: null,
            },
            {
              act_text: "Round money amounts",
              comp: null,
            },
            {
              act_text: "Add and subtract money amounts",
              comp: null,
            },
            {
              act_text: "Add, subtract, multiply and divide money amounts",
              comp: null,
            },
            {
              act_text: "	Making change",
              comp: null,
            },
            {
              act_text: "Price lists",
              comp: null,
            },
            {
              act_text: "Price lists with multiplication",
              comp: null,
            },
            {
              act_text: "Unit prices",
              comp: null,
            },
          ],
        },
        K: {
          subject: "Maths",
          category: "K",
          catType: "Units of measurement",
          components: [
            {
              act_text: "	Choose the appropriate metric unit of measure",
              comp: null,
            },
            {
              act_text: "Compare and convert metric units of length",
              comp: null,
            },
            {
              act_text: "Compare and convert metric units of mass",
              comp: null,
            },
            {
              act_text: "Compare and convert metric units of volume",
              comp: null,
            },
            {
              act_text: "Metric mixed units",
              comp: null,
            },
          ],
        },
        L: {
          subject: "Maths",
          category: "L",
          catType: "Time",
          components: [
            {
              act_text: "Convert time units",
              comp: null,
            },
            {
              act_text: "Add and subtract mixed time units",
              comp: null,
            },
            {
              act_text: "	A.M. or P.M.",
              comp: null,
            },
            {
              act_text: "Elapsed time",
              comp: null,
            },
            {
              act_text: "	Find start and end times: multi-step word problems",
              comp: null,
            },
            {
              act_text: "Convert between 12-hour and 24-hour time",
              comp: null,
            },
            {
              act_text: "Transportation schedules - 12-hour time",
              comp: null,
            },
            {
              act_text: "Transportation schedules - 24-hour time",
              comp: null,
            },
            {
              act_text: "	Time patterns",
              comp: null,
            },
          ],
        },
        M: {
          subject: "Maths",
          category: "M",
          catType: "Geometry",
          components: [
            {
              act_text: "Which two-dimensional figure is being described?",
              comp: null,
            },
            {
              act_text: "Identify three-dimensional figures",
              comp: null,
            },
            {
              act_text: "	Count vertices, edges and faces",
              comp: null,
            },
            {
              act_text: "	Identify faces of three-dimensional figure",
              comp: null,
            },
            {
              act_text: "	Which three-dimensional figure is being described?",
              comp: null,
            },
            {
              act_text: "	Nets of three-dimensional figures",
              comp: null,
            },
            {
              act_text: "	Number of sides in polygonse",
              comp: null,
            },
            {
              act_text: "	Identify lines of symmetry",
              comp: null,
            },
            {
              act_text: "Rotational symmetry",
              comp: null,
            },
          ],
        },
        N: {
          subject: "Maths",
          category: "N",
          catType: "Geometric measurement",
          components: [
            {
              act_text: "	Perimeter of rectangles",
              comp: null,
            },
            {
              act_text: "	Perimeter of polygons",
              comp: null,
            },
            {
              act_text: "	Perimeter of rectilinear shapes.",
              comp: null,
            },
            {
              act_text: "Perimeter: find the missing side length",
              comp: null,
            },
            {
              act_text: "Use perimeter to determine cost",
              comp: null,
            },
            {
              act_text: "	Find the area of figures made of unit squares",
              comp: null,
            },
            {
              act_text: "	Select figures with a given area",
              comp: null,
            },
            {
              act_text: "	Select two figures with the same area",
              comp: null,
            },
            {
              act_text: "	Create figures with a given area",
              comp: null,
            },
            {
              act_text: "Find the area or missing side length of a rectangle",
              comp: null,
            },
            {
              act_text: "	Area and perimeter: word problems",
              comp: null,
            },
          ],
        },
        O: {
          subject: "Maths",
          category: "O",
          catType: "Fractions",
          components: [
            {
              act_text: "Halves and quaters",
              comp: null,
            },
            {
              act_text: "Equal parts",
              comp: null,
            },
            {
              act_text: "	Area and perimeter: word problems",
              comp: null,
            },
            {
              act_text: "Elapsed time",
              comp: null,
            },
            {
              act_text: "Simple fractions: which shape matches the fraction?",
              comp: null,
            },
            {
              act_text: "	Simple fractions: parts of a group",
              comp: null,
            },
          ],
        },
        P: {
          subject: "Maths",
          category: "P",
          catType: "Probability",
          components: [
            {
              act_text: "	Understanding probability",
              comp: null,
            },
            {
              act_text: "Find the probability",
              comp: null,
            },
            {
              act_text: "	Make predictions",
              comp: null,
            },
            {
              act_text: "	Combinations",
              comp: null,
            },
          ],
        },
      },
      Class5: {
        A: {
          subject: "Maths",
          category: "A",
          catType: "Place values and number sense",
          components: [
            {
              act_text: "Place values",
              comp: null,
            },
            {
              act_text: "Convert place values",
              comp: GV_MA_A2,
            },
            {
              act_text: "Compare numbers",
              comp: GV_MA_A3,
            },
            {
              act_text: "Word names for numbers",
              comp: GV_MA_A4,
            },
            {
              act_text: "Rounding",
              comp: GV_MA_A5,
            },
            {
              act_text: "Even or odd: arthemetic rules",
              comp: GV_MA_A6,
            },
          ],
        },
        B: {
          subject: "Maths",
          category: "B",
          catType: "Addition and subtraction",
          components: [
            {
              act_text: "Add and subtract whole numbers",
              comp: GV_MA_B1,
            },
            {
              act_text: "Add and subtract whole numbers: word problems",
              comp: GV_MA_B2,
            },
            {
              act_text: "	Complete addition and subtraction sentences",
              comp: GV_MA_B3,
            },
            {
              act_text: "Fill in the missing digits",
              comp: GV_MA_B4,
            },
            {
              act_text: "	Choose numbers with a particular sum or difference",
              comp: GV_MA_B5,
            },
            {
              act_text: "Properties of addition",
              comp: GV_MA_B6,
            },
            {
              act_text: "Estimate sums and differences of whole numbers",
              comp: GV_MA_B7,
            },
            {
              act_text: "	Estimate sums and differences: word problems",
              comp: GV_MA_B8,
            },
          ],
        },
        C: {
          subject: "Maths",
          category: "C",
          catType: "Multiplication",
          components: [
            {
              act_text: "Multiply by one-digit numbers",
              comp: null,
            },
            {
              act_text: "Multiply by one-digit numbers: word problems",
              comp: null,
            },
            {
              act_text: "Multiplication patterns over increasing place values",
              comp: null,
            },
            {
              act_text: "Multiply numbers ending in zeroes",
              comp: null,
            },
            {
              act_text: "Multiply numbers ending in zeroes: word problems",
              comp: null,
            },
            {
              act_text: "	Properties of multiplication",
              comp: null,
            },
            {
              act_text: "Choose numbers with a particular product",
              comp: null,
            },
            {
              act_text: "Estimate products",
              comp: null,
            },
            {
              act_text: "Estimate products: word problems",
              comp: null,
            },
            {
              act_text: "	Box multiplication",
              comp: null,
            },
            {
              act_text: "Lattice multiplication",
              comp: null,
            },
            {
              act_text: "	Multiply by 2-digit numbers: complete the missing steps",
              comp: null,
            },
            {
              act_text: "	Multiply 2-digit numbers by 2-digit numbers",
              comp: null,
            },
            {
              act_text: "	Multiply 2-digit numbers by 3-digit numbers",
              comp: null,
            },
            {
              act_text: "Multiply 2-digit numbers by larger numbers",
              comp: null,
            },
            {
              act_text: "Multiply by 2-digit numbers: word numbers",
              comp: null,
            },
            {
              act_text: "Multiply three or four numbers",
              comp: null,
            },
            {
              act_text: "Multiply three or four numbers: word problems",
              comp: null,
            },
          ],
        },
        D: {
          subject: "Maths",
          category: "D",
          catType: "Division",
          components: [
            {
              act_text: "	Division facts to 12",
              comp: null,
            },
            {
              act_text: "	Division facts to 12: word problems",
              comp: null,
            },
            {
              act_text: "Divisibility rules",
              comp: null,
            },
            {
              act_text: "Divisibility rules: word problems",
              comp: null,
            },
            {
              act_text: "Divide by one-digit numbers",
              comp: null,
            },
            {
              act_text: "Divide by one-digit numbers: word problems",
              comp: null,
            },
            {
              act_text: "	Divide by one-digit numbers: interpret remainders",
              comp: null,
            },
            {
              act_text: "Estimate quotients: word problems",
              comp: null,
            },
            {
              act_text: "Division patterns over increasing place values",
              comp: null,
            },
            {
              act_text: "Divide numbers ending in zeroes",
              comp: null,
            },
            {
              act_text: "Divide numbers ending in zeroes: word problems",
              comp: null,
            },
            {
              act_text: "	Divide by two-digit numbers",
              comp: null,
            },
            {
              act_text: "	Divide by two-digit numbers: word problems",
              comp: null,
            },
            {
              act_text: "Choose numbers with a particular quotient",
              comp: null,
            },
          ],
        },
        E: {
          subject: "Maths",
          category: "E",
          catType: "Decimals",
          components: [
            {
              act_text: "What decimal number is illustrated?",
              comp: null,
            },
            {
              act_text: "Model decimals and fractions",
              comp: null,
            },
            {
              act_text: "	Understanding decimals expressed in words",
              comp: null,
            },
            {
              act_text: "Place values in decimal numbers",
              comp: null,
            },
            {
              act_text: "	Equivalent decimals",
              comp: null,
            },
            {
              act_text: "Round decimals",
              comp: null,
            },
            {
              act_text: "	Decimal number lines",
              comp: null,
            },
            {
              act_text: "Compare decimals on number lines",
              comp: null,
            },
            {
              act_text: "	Compare decimal numbers",
              comp: null,
            },
            {
              act_text: "	Put decimal numbers in order",
              comp: null,
            },
            {
              act_text: "Convert fractions to decimals",
              comp: null,
            },
            {
              act_text: "Convert decimals to fractions",
              comp: null,
            },
          ],
        },
        F: {
          subject: "Maths",
          category: "F",
          catType: "Fractions",
          components: [
            {
              act_text: "	Fractions review",
              comp: null,
            },
            {
              act_text: "Unit fractions: modelling word problems",
              comp: null,
            },
            {
              act_text: "Unit fractions: word problems",
              comp: null,
            },
            {
              act_text: "Fractions of a whole: modelling word problems",
              comp: null,
            },
            {
              act_text: "	Fractions of a whole: word problems",
              comp: null,
            },
            {
              act_text: "	Fractions of a group: word problems",
              comp: null,
            },
            {
              act_text: "Equivalent fractions",
              comp: null,
            },
            {
              act_text: "Patterns of equivalent fractions",
              comp: null,
            },
            {
              act_text: "Write fractions in lowest terms",
              comp: null,
            },
            {
              act_text: "Compare fractions",
              comp: null,
            },
            {
              act_text: "Put fractions in order",
              comp: null,
            },
            {
              act_text: "Fractions of a number",
              comp: null,
            },
            {
              act_text: "Fractions of a number: word problems",
              comp: null,
            },
            {
              act_text: "Mixed numbers",
              comp: null,
            },
          ],
        },
        G: {
          subject: "Maths",
          category: "G",
          catType: "Mixed operations",
          components: [
            {
              act_text: "	Add, subtract, multiply and divide whole numbers",
              comp: null,
            },
            {
              act_text:
                "	Add, subtract, multiply and divide whole numbers: word problems",
              comp: null,
            },
          ],
        },
        H: {
          subject: "Maths",
          category: "H",
          catType: "Problem solving",
          components: [
            {
              act_text: "	Multi-step word problems",
              comp: null,
            },
            {
              act_text: "	Word problems with extra or missing information",
              comp: null,
            },
            {
              act_text: "Guess-and-check problems",
              comp: null,
            },
            {
              act_text: "	Find the order",
              comp: null,
            },
            {
              act_text: "Use Venn diagrams to solve problems",
              comp: null,
            },
          ],
        },
        I: {
          subject: "Maths",
          category: "I",
          catType: "Money",
          components: [
            {
              act_text: "	Add and subtract money amounts",
              comp: null,
            },
            {
              act_text: "Add and subtract money: word problems",
              comp: null,
            },
            {
              act_text: "	Multiply money amounts: word problems",
              comp: null,
            },
            {
              act_text: "Divide money amounts: word problems",
              comp: null,
            },
            {
              act_text: "Price lists",
              comp: null,
            },
            {
              act_text: "Unit prices",
              comp: null,
            },
          ],
        },
        J: {
          subject: "Maths",
          category: "J",
          catType: "Number sequences",
          components: [
            {
              act_text: "	Complete an increasing number sequence",
              comp: null,
            },
            {
              act_text: "	Complete a geometric number sequence",
              comp: null,
            },
            {
              act_text: "	Use a rule to complete a number sequence",
              comp: null,
            },
            {
              act_text: "	Number sequences: word problems",
              comp: null,
            },
            {
              act_text: "Number sequences: mixed review",
              comp: null,
            },
          ],
        },
        K: {
          subject: "Maths",
          category: "K",
          catType: "Data and graphs",
          components: [
            {
              act_text: "Read a table",
              comp: null,
            },
            {
              act_text: "	Interpret line graphs",
              comp: null,
            },
            {
              act_text: "	Create line graphs",
              comp: null,
            },
            {
              act_text: "	Interpret bar graphs",
              comp: null,
            },
            {
              act_text: "	Create bar graphs",
              comp: null,
            },
            {
              act_text: "	Interpret pictographs",
              comp: null,
            },
            {
              act_text: "Create pictographs",
              comp: null,
            },
            {
              act_text: "Interpret histograms",
              comp: null,
            },
            {
              act_text: "Create histograms",
              comp: null,
            },
            {
              act_text: "Interpet line plots",
              comp: null,
            },
            {
              act_text: "	Create line plots",
              comp: null,
            },
            {
              act_text: "	Frequency charts",
              comp: null,
            },
            {
              act_text: "	Interpret stem-and-leaf plots",
              comp: null,
            },
            {
              act_text: "Create stem-and-leaf plots",
              comp: null,
            },
            {
              act_text: "	Choose the best type of graph",
              comp: null,
            },
          ],
        },
        L: {
          subject: "Maths",
          category: "L",
          catType: "Probability",
          components: [
            {
              act_text: "	Understanding probability",
              comp: null,
            },
            {
              act_text: "Find the probability",
              comp: null,
            },
            {
              act_text: "Make predictions",
              comp: null,
            },
            {
              act_text: "Combinations",
              comp: null,
            },
          ],
        },
        M: {
          subject: "Maths",
          category: "M",
          catType: "Time",
          components: [
            {
              act_text: "Convert time units",
              comp: null,
            },
            {
              act_text: "Add and subtract mixed time units",
              comp: null,
            },
            {
              act_text: "	Elapsed time",
              comp: null,
            },
            {
              act_text: "Find start and end times: word problems",
              comp: null,
            },
            {
              act_text: "Convert between 12-hour and 24-hour time",
              comp: null,
            },
            {
              act_text: "Schedules and timelines - 12-hour time",
              comp: null,
            },
            {
              act_text: "Schedules - 24-hour time",
              comp: null,
            },
            {
              act_text: "Time patterns",
              comp: null,
            },
          ],
        },
        N: {
          subject: "Maths",
          category: "N",
          catType: "Units of measurement",
          components: [
            {
              act_text: "Choose the appropriate metric unit of measure",
              comp: null,
            },
            {
              act_text: "	Compare and convert metric units of length",
              comp: null,
            },
            {
              act_text: "Compare and convert metric units of mass",
              comp: null,
            },
            {
              act_text: "	Compare and convert metric units of volume",
              comp: null,
            },
            {
              act_text: "	Choose the more reasonable temperature",
              comp: null,
            },
            {
              act_text: "Metric mixed units",
              comp: null,
            },
          ],
        },
        O: {
          subject: "Maths",
          category: "O",
          catType: "Geometry",
          components: [
            {
              act_text: "Which figure is being described?",
              comp: null,
            },
            {
              act_text: "Number of sides in polygons",
              comp: null,
            },
            {
              act_text: "Regular and irregular polygons",
              comp: null,
            },
            {
              act_text: "Types of angles",
              comp: null,
            },
            {
              act_text: "Measure angles with a protractor",
              comp: null,
            },
            {
              act_text: "Lines of symmetry",
              comp: null,
            },
            {
              act_text: "Rotational symmetry",
              comp: null,
            },
            {
              act_text: "Reflection, rotation and translation",
              comp: null,
            },
            {
              act_text: "Identify three-dimensional figures",
              comp: null,
            },
            {
              act_text: "Count vertices, edges and faces",
              comp: null,
            },
            {
              act_text: "Nets of three-dimensional figures",
              comp: null,
            },
            {
              act_text:
                "Three-dimensional figures viewed from different perspectives",
              comp: null,
            },
          ],
        },
        P: {
          subject: "Maths",
          category: "P",
          catType: "Geometric measurement",
          components: [
            {
              act_text: "Perimeter",
              comp: null,
            },
            {
              act_text: "Perimeter: find the missing side lengths",
              comp: null,
            },
            {
              act_text: "Area of squares and rectangles",
              comp: null,
            },
            {
              act_text: "Area and perimeter of figures on grids",
              comp: null,
            },
            {
              act_text: "	Area and perimeter: word problems",
              comp: null,
            },
            {
              act_text: "Use area and perimeter to determine cost",
              comp: null,
            },
            {
              act_text: "Volume of figures made of unit cubes",
              comp: null,
            },
          ],
        },
      },
    };

    /* src/MenuItems.svelte generated by Svelte v3.37.0 */

    const { console: console_1 } = globals;
    const file$1 = "src/MenuItems.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[2] = list[i];
    	child_ctx[4] = i;
    	return child_ctx;
    }

    // (9:2) {#each object.components as obj, i}
    function create_each_block$1(ctx) {
    	let li;
    	let a;
    	let t0_value = /*object*/ ctx[0].category + "";
    	let t0;
    	let t1;
    	let t2_value = /*i*/ ctx[4] + 1 + "";
    	let t2;
    	let t3;
    	let t4_value = /*obj*/ ctx[2].act_text + "";
    	let t4;
    	let a_style_value;
    	let t5;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			li = element("li");
    			a = element("a");
    			t0 = text(t0_value);
    			t1 = text(".");
    			t2 = text(t2_value);
    			t3 = space();
    			t4 = text(t4_value);
    			t5 = space();
    			attr_dev(a, "style", a_style_value = "background: " + (/*obj*/ ctx[2].comp == null ? "#ff000069" : "#00800069") + " ;color: black;  padding : 2px 5px ");
    			attr_dev(a, "class", "svelte-polfp2");
    			add_location(a, file$1, 11, 6, 268);
    			set_style(li, "margin-bottom", "2px");
    			add_location(li, file$1, 9, 4, 177);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, a);
    			append_dev(a, t0);
    			append_dev(a, t1);
    			append_dev(a, t2);
    			append_dev(a, t3);
    			append_dev(a, t4);
    			append_dev(li, t5);

    			if (!mounted) {
    				dispose = listen_dev(
    					a,
    					"click",
    					function () {
    						if (is_function(/*click*/ ctx[1](null, /*obj*/ ctx[2].comp))) /*click*/ ctx[1](null, /*obj*/ ctx[2].comp).apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*object*/ 1 && t0_value !== (t0_value = /*object*/ ctx[0].category + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*object*/ 1 && t4_value !== (t4_value = /*obj*/ ctx[2].act_text + "")) set_data_dev(t4, t4_value);

    			if (dirty & /*object*/ 1 && a_style_value !== (a_style_value = "background: " + (/*obj*/ ctx[2].comp == null ? "#ff000069" : "#00800069") + " ;color: black;  padding : 2px 5px ")) {
    				attr_dev(a, "style", a_style_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(9:2) {#each object.components as obj, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let ul;
    	let li;
    	let h4;
    	let t0_value = /*object*/ ctx[0].catType + "";
    	let t0;
    	let t1;
    	let each_value = /*object*/ ctx[0].components;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			li = element("li");
    			h4 = element("h4");
    			t0 = text(t0_value);
    			t1 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(h4, "class", "svelte-polfp2");
    			add_location(h4, file$1, 7, 6, 104);
    			add_location(li, file$1, 7, 2, 100);
    			attr_dev(ul, "class", "svelte-polfp2");
    			add_location(ul, file$1, 6, 0, 93);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);
    			append_dev(ul, li);
    			append_dev(li, h4);
    			append_dev(h4, t0);
    			append_dev(ul, t1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*object*/ 1 && t0_value !== (t0_value = /*object*/ ctx[0].catType + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*object, click*/ 3) {
    				each_value = /*object*/ ctx[0].components;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("MenuItems", slots, []);
    	let { object } = $$props;
    	let { click } = $$props;
    	console.log(object.category);
    	const writable_props = ["object", "click"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<MenuItems> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("object" in $$props) $$invalidate(0, object = $$props.object);
    		if ("click" in $$props) $$invalidate(1, click = $$props.click);
    	};

    	$$self.$capture_state = () => ({ object, click });

    	$$self.$inject_state = $$props => {
    		if ("object" in $$props) $$invalidate(0, object = $$props.object);
    		if ("click" in $$props) $$invalidate(1, click = $$props.click);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [object, click];
    }

    class MenuItems extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, { object: 0, click: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MenuItems",
    			options,
    			id: create_fragment$2.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*object*/ ctx[0] === undefined && !("object" in props)) {
    			console_1.warn("<MenuItems> was created without expected prop 'object'");
    		}

    		if (/*click*/ ctx[1] === undefined && !("click" in props)) {
    			console_1.warn("<MenuItems> was created without expected prop 'click'");
    		}
    	}

    	get object() {
    		throw new Error("<MenuItems>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set object(value) {
    		throw new Error("<MenuItems>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get click() {
    		throw new Error("<MenuItems>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set click(value) {
    		throw new Error("<MenuItems>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Menu.svelte generated by Svelte v3.37.0 */

    const { Object: Object_1 } = globals;
    const file = "src/Menu.svelte";

    function get_each_context_4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	child_ctx[5] = i;
    	return child_ctx;
    }

    function get_each_context_3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	child_ctx[5] = i;
    	return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	child_ctx[5] = i;
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	child_ctx[5] = i;
    	return child_ctx;
    }

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	child_ctx[5] = i;
    	return child_ctx;
    }

    // (73:6) {:else}
    function create_else_block(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*componentName*/ ctx[0];

    	function switch_props(ctx) {
    		return { $$inline: true };
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (switch_value !== (switch_value = /*componentName*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(73:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (66:38) 
    function create_if_block_4(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_4 = Array(Object.keys(act_list.Class5).length);
    	validate_each_argument(each_value_4);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_4.length; i += 1) {
    		each_blocks[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*Object, act_list, handleClick*/ 4) {
    				each_value_4 = Array(Object.keys(act_list.Class5).length);
    				validate_each_argument(each_value_4);
    				let i;

    				for (i = 0; i < each_value_4.length; i += 1) {
    					const child_ctx = get_each_context_4(ctx, each_value_4, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_4(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_4.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_4.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(66:38) ",
    		ctx
    	});

    	return block;
    }

    // (59:39) 
    function create_if_block_3(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_3 = Array(Object.keys(act_list.Class4).length);
    	validate_each_argument(each_value_3);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*Object, act_list, handleClick*/ 4) {
    				each_value_3 = Array(Object.keys(act_list.Class4).length);
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3(ctx, each_value_3, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_3.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_3.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(59:39) ",
    		ctx
    	});

    	return block;
    }

    // (52:40) 
    function create_if_block_2(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_2 = Array(Object.keys(act_list.Class3).length);
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*Object, act_list, handleClick*/ 4) {
    				each_value_2 = Array(Object.keys(act_list.Class3).length);
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_2.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_2.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(52:40) ",
    		ctx
    	});

    	return block;
    }

    // (45:39) 
    function create_if_block_1(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_1 = Array(Object.keys(act_list.Class2).length);
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*Object, act_list, handleClick*/ 4) {
    				each_value_1 = Array(Object.keys(act_list.Class2).length);
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(45:39) ",
    		ctx
    	});

    	return block;
    }

    // (38:6) {#if showMenu === "GradeI"}
    function create_if_block(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = Array(Object.keys(act_list.Class1).length);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*Object, act_list, handleClick*/ 4) {
    				each_value = Array(Object.keys(act_list.Class1).length);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(38:6) {#if showMenu === \\\"GradeI\\\"}",
    		ctx
    	});

    	return block;
    }

    // (67:8) {#each Array(Object.keys(act_list.Class5).length) as _, i}
    function create_each_block_4(ctx) {
    	let menuitems;
    	let current;

    	menuitems = new MenuItems({
    			props: {
    				object: Object.values(act_list.Class5)[/*i*/ ctx[5]],
    				click: /*handleClick*/ ctx[2]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(menuitems.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(menuitems, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menuitems.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menuitems.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(menuitems, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_4.name,
    		type: "each",
    		source: "(67:8) {#each Array(Object.keys(act_list.Class5).length) as _, i}",
    		ctx
    	});

    	return block;
    }

    // (60:8) {#each Array(Object.keys(act_list.Class4).length) as _, i}
    function create_each_block_3(ctx) {
    	let menuitems;
    	let current;

    	menuitems = new MenuItems({
    			props: {
    				object: Object.values(act_list.Class4)[/*i*/ ctx[5]],
    				click: /*handleClick*/ ctx[2]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(menuitems.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(menuitems, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menuitems.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menuitems.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(menuitems, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3.name,
    		type: "each",
    		source: "(60:8) {#each Array(Object.keys(act_list.Class4).length) as _, i}",
    		ctx
    	});

    	return block;
    }

    // (53:8) {#each Array(Object.keys(act_list.Class3).length) as _, i}
    function create_each_block_2(ctx) {
    	let menuitems;
    	let current;

    	menuitems = new MenuItems({
    			props: {
    				object: Object.values(act_list.Class3)[/*i*/ ctx[5]],
    				click: /*handleClick*/ ctx[2]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(menuitems.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(menuitems, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menuitems.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menuitems.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(menuitems, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2.name,
    		type: "each",
    		source: "(53:8) {#each Array(Object.keys(act_list.Class3).length) as _, i}",
    		ctx
    	});

    	return block;
    }

    // (46:8) {#each Array(Object.keys(act_list.Class2).length) as _, i}
    function create_each_block_1(ctx) {
    	let menuitems;
    	let current;

    	menuitems = new MenuItems({
    			props: {
    				object: Object.values(act_list.Class2)[/*i*/ ctx[5]],
    				click: /*handleClick*/ ctx[2]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(menuitems.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(menuitems, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menuitems.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menuitems.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(menuitems, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(46:8) {#each Array(Object.keys(act_list.Class2).length) as _, i}",
    		ctx
    	});

    	return block;
    }

    // (39:8) {#each Array(Object.keys(act_list.Class1).length) as _, i}
    function create_each_block(ctx) {
    	let menuitems;
    	let current;

    	menuitems = new MenuItems({
    			props: {
    				object: Object.values(act_list.Class1)[/*i*/ ctx[5]],
    				click: /*handleClick*/ ctx[2]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(menuitems.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(menuitems, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menuitems.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menuitems.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(menuitems, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(39:8) {#each Array(Object.keys(act_list.Class1).length) as _, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1(ctx) {
    	let div4;
    	let div0;
    	let h2;
    	let t1;
    	let div3;
    	let div1;
    	let ul;
    	let li0;
    	let h4;
    	let t3;
    	let li1;
    	let button0;
    	let t5;
    	let li2;
    	let button1;
    	let t7;
    	let li3;
    	let button2;
    	let t9;
    	let li4;
    	let button3;
    	let t11;
    	let li5;
    	let button4;
    	let t13;
    	let div2;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	let mounted;
    	let dispose;

    	const if_block_creators = [
    		create_if_block,
    		create_if_block_1,
    		create_if_block_2,
    		create_if_block_3,
    		create_if_block_4,
    		create_else_block
    	];

    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*showMenu*/ ctx[1] === "GradeI") return 0;
    		if (/*showMenu*/ ctx[1] === "GradeII") return 1;
    		if (/*showMenu*/ ctx[1] === "GradeIII") return 2;
    		if (/*showMenu*/ ctx[1] === "GradeIV") return 3;
    		if (/*showMenu*/ ctx[1] === "GradeV") return 4;
    		return 5;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			h2.textContent = "WEXL";
    			t1 = space();
    			div3 = element("div");
    			div1 = element("div");
    			ul = element("ul");
    			li0 = element("li");
    			h4 = element("h4");
    			h4.textContent = "Menu";
    			t3 = space();
    			li1 = element("li");
    			button0 = element("button");
    			button0.textContent = "Grade I";
    			t5 = space();
    			li2 = element("li");
    			button1 = element("button");
    			button1.textContent = "Grade II";
    			t7 = space();
    			li3 = element("li");
    			button2 = element("button");
    			button2.textContent = "Grade III";
    			t9 = space();
    			li4 = element("li");
    			button3 = element("button");
    			button3.textContent = "Grade IV";
    			t11 = space();
    			li5 = element("li");
    			button4 = element("button");
    			button4.textContent = "Grade V";
    			t13 = space();
    			div2 = element("div");
    			if_block.c();
    			attr_dev(h2, "class", "svelte-anrgvv");
    			add_location(h2, file, 17, 4, 394);
    			attr_dev(div0, "class", "header svelte-anrgvv");
    			add_location(div0, file, 16, 2, 369);
    			attr_dev(h4, "class", "svelte-anrgvv");
    			add_location(h4, file, 22, 12, 487);
    			add_location(li0, file, 22, 8, 483);
    			attr_dev(button0, "class", "svelte-anrgvv");
    			add_location(button0, file, 23, 12, 557);
    			add_location(li1, file, 23, 8, 553);
    			attr_dev(button1, "class", "svelte-anrgvv");
    			add_location(button1, file, 25, 10, 649);
    			add_location(li2, file, 24, 8, 634);
    			attr_dev(button2, "class", "svelte-anrgvv");
    			add_location(button2, file, 28, 10, 752);
    			add_location(li3, file, 27, 8, 737);
    			attr_dev(button3, "class", "svelte-anrgvv");
    			add_location(button3, file, 31, 10, 857);
    			add_location(li4, file, 30, 8, 842);
    			attr_dev(button4, "class", "svelte-anrgvv");
    			add_location(button4, file, 33, 12, 949);
    			add_location(li5, file, 33, 8, 945);
    			attr_dev(ul, "class", "svelte-anrgvv");
    			add_location(ul, file, 21, 6, 470);
    			attr_dev(div1, "class", "menu svelte-anrgvv");
    			add_location(div1, file, 20, 4, 445);
    			attr_dev(div2, "class", "main svelte-anrgvv");
    			add_location(div2, file, 36, 4, 1045);
    			attr_dev(div3, "class", "content svelte-anrgvv");
    			add_location(div3, file, 19, 2, 419);
    			attr_dev(div4, "style", "height: 100vh; display: flex; flex-direction: column; width : 100vw;");
    			add_location(div4, file, 13, 0, 281);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div0);
    			append_dev(div0, h2);
    			append_dev(div4, t1);
    			append_dev(div4, div3);
    			append_dev(div3, div1);
    			append_dev(div1, ul);
    			append_dev(ul, li0);
    			append_dev(li0, h4);
    			append_dev(ul, t3);
    			append_dev(ul, li1);
    			append_dev(li1, button0);
    			append_dev(ul, t5);
    			append_dev(ul, li2);
    			append_dev(li2, button1);
    			append_dev(ul, t7);
    			append_dev(ul, li3);
    			append_dev(li3, button2);
    			append_dev(ul, t9);
    			append_dev(ul, li4);
    			append_dev(li4, button3);
    			append_dev(ul, t11);
    			append_dev(ul, li5);
    			append_dev(li5, button4);
    			append_dev(div3, t13);
    			append_dev(div3, div2);
    			if_blocks[current_block_type_index].m(div2, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(h4, "click", /*handleClick*/ ctx[2]("GradeI", null), false, false, false),
    					listen_dev(button0, "click", /*handleClick*/ ctx[2]("GradeI", null), false, false, false),
    					listen_dev(button1, "click", /*handleClick*/ ctx[2]("GradeII", null), false, false, false),
    					listen_dev(button2, "click", /*handleClick*/ ctx[2]("GradeIII", null), false, false, false),
    					listen_dev(button3, "click", /*handleClick*/ ctx[2]("GradeIV", null), false, false, false),
    					listen_dev(button4, "click", /*handleClick*/ ctx[2]("GradeV", null), false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div2, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			if_blocks[current_block_type_index].d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Menu", slots, []);
    	let componentName;
    	let showMenu = "GradeI";

    	const handleClick = (parameter, compName) => () => {
    		$$invalidate(1, showMenu = parameter);
    		$$invalidate(0, componentName = compName);
    	};

    	const writable_props = [];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Menu> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		act_list,
    		MenuItems,
    		componentName,
    		showMenu,
    		handleClick
    	});

    	$$self.$inject_state = $$props => {
    		if ("componentName" in $$props) $$invalidate(0, componentName = $$props.componentName);
    		if ("showMenu" in $$props) $$invalidate(1, showMenu = $$props.showMenu);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [componentName, showMenu, handleClick];
    }

    class Menu extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Menu",
    			options,
    			id: create_fragment$1.name
    		});
    	}
    }

    /* src/App.svelte generated by Svelte v3.37.0 */

    function create_fragment(ctx) {
    	let menu;
    	let current;
    	menu = new Menu({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(menu.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(menu, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(menu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("App", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Menu });
    	return [];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    const app = new App({
    	target: document.body,
    	props: {
    		name: 'world'
    	}
    });

    return app;

}());
//# sourceMappingURL=bundle.js.map
